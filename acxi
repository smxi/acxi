#!/usr/bin/perl
#########################################################################
# acxi - audio conversion program
#########################################################################

# Copyright (c) 2010-2019 - Harald Hope - smxi.org 
# Home page: https://github.com/smxi/acxi
# Forum support: https://techpatterns.com/forums/about1491.html
# Download url: https://smxi.org/acxi
#
# Based on flac2ogg.pl
# Copyright (c) 2004 - Jason L. Buberel - jason@buberel.org
# Copyright (c) 2007 - Evan Boggs - etboggs@indiana.edu
# Previous Home page (gone now): 
#   http://www.buberel.org/linux/batch-flac-to-ogg-converter.php
#
# Modified: 2018-12-05 - Cleaned up code, refactored
# Modified: 2011-07-26 - Harald Hope - Added patch for $ in file names; 
#   changed verbosity levels to fit future 3 release, got rid of 
#   $B_SILENT and $b_quiet
# Modified: 2011-03-23 - Odd Eivind Ebbesen - www.oddware.net - 
#   <oddebb at gmail dot com>
#   Added functionality for Flac conversion to MP3, preserving tags.
#########################################################################
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 3 of the License, or 
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
#
# Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
#########################################################################
# Given a source directory tree of original lossless music files 
# (flac, wav, etc), this program will recreate (or add to) a new 
# directory tree of ogg/mp3 files by recursively encoding only new 
# source files to destination types.
# The source and destination directories can be hard-coded using the 
# $SOURCE_DIRECTORY and $DESTINATION_DIRECTORY variables, or passed on 
# the command line, or can be set in the configuration file (recommended).  
#
# See USER MODIFIABLE VALUES for configuration information.

#########################################################################
### NO USER CHANGES IN THIS SECTION ###
#########################################################################
use strict;
use warnings;
# use diagnostics;
use 5.010;
use feature 'state';
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
use File::Basename;
use File::stat;
use File::Find;
use File::Copy qw(copy);
use File::Glob qw(:bsd_glob);
use File::Path qw(rmtree make_path);
use Cwd qw(getcwd);
use Data::Dumper;
# use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
#use feature 'unicode_strings';
# use open qw(:std :utf8); # don't use
# only use for debugging, some distros do not ship with core modules.
#use Data::Dumper qw(Dumper);

#### -------------------------------------------------------------------
#### PROGRAM GLOBALS - DO NOT TOUCH THESE!
#### -------------------------------------------------------------------

## SELF INFO ##
my $SELF_NAME = 'acxi';
my $SELF_VERSION = '3.3.17';
my $SELF_DATE = '2019-11-03';

## GLOBALS ##
my %run;
$run{'sync'} = 1;
my ($b_dest_changed,$b_force,$b_fork,$b_quiet,$b_test);
my ($print_line_heavy,$print_line_large,$print_line_small);
my ($quality,$autotag_multi,$silent_flac,$silent_ffmpeg,$silent_lame,
$silent_opus) = (7,'','','','','');
my ($extension,$exclude_append,@excludes,@extension_list,@found_list,$list_type);
my ($b_check_dest,$b_check_out) = (1,1);
my $b_win = ($^O =~ /win/i) ? 1 : 0; # detect if $^O returns windows 
my $path_separator = ($b_win) ? '\\' : '/';
## CONSTANTS ##
my $line_heavy = "===========================================================================\n";
my $line_small = "-----------------------------------------------------------------\n";
my $line_large = "---------------------------------------------------------------------------\n";

#########################################################################
### USER MODIFIABLE VALUES ###
#########################################################################
# User config file at:
# Global: /etc/acxi.conf
# User override files checked in the following order (first found used):
# $XDG_CONFIG_HOME/acxi.conf, $HOME/.config/acxi.conf, $HOME/.acxi.conf
#
# Set values like this:
# Do not use the $ preceding the variable name, or the semicolon or 
# single/double quote marks in the config file. Use this syntax for 
# config files:
# SOURCE_DIRECTORY=/home/fred/music/flac
# DESTINATION_DIRECTORY=/home/fred/music/ogg
#
# It's highly recommended to create a config file so you don't have to
# update the values below every time acxi updates.
#
# Anything in configs or in this section will be overridden if you use
# a startup argument.
#### -------------------------------------------------------------------
#### CUSTOM CONFIGURATION FILE LOCATION
#### -------------------------------------------------------------------
# NOTE: only use this if you are running Windows, or any OS without $HOME
# or $XDG_CONFIG_HOME environmental variables. acxi will look for file:
# acxi.conf inside that directory. 
my $CONFIG_DIRECTORY='';

#### -------------------------------------------------------------------
#### APPLICATION PATHS
#### -------------------------------------------------------------------
my $COMMAND_FLAC = '/usr/bin/flac'; 
my $COMMAND_FFMPEG = '/usr/bin/ffmpeg';
my $COMMAND_LAME = '/usr/bin/lame';
my $COMMAND_OGG = '/usr/bin/oggenc';
my $COMMAND_OPUS = '/usr/bin/opusenc';
# If you are not generating checksums, you do not need this.
my $COMMAND_MD5 = '/usr/bin/md5sum';
# metaflac is required for flac to mp3, to copy over the ID3 tags, or
# for ffp checksum generator.
# If you are not doing either, you don't need this.
my $COMMAND_METAFLAC = '/usr/bin/metaflac';

#### -------------------------------------------------------------------
#### ASSIGN DIRECTORY PATHS
#### -------------------------------------------------------------------
# Options: -s/--source path -d/--destination path
# $SOURCE_DIRECTORY is the original, working, like flac, wav, etc
# $DESTINATION_DIRECTORY is the processed, ie, ogg, mp3
# CHANGE TO FIT YOUR SYSTEM - do not end in /
# IMPORTANT: DESTINATION_DIRECTORY cannot be equal to SOURCE_DIRECTORY
my $SOURCE_DIRECTORY = '/path/to/source/directory';
my $DESTINATION_DIRECTORY = '/path/to/your/output/directory';

#### -------------------------------------------------------------------
#### EXCLUDES
#### -------------------------------------------------------------------

# this is the unique part of the exclude file name, not including the 
# .txt. All exclude file names used must contain this string value.
my $EXCLUDE_BASE = 'acxi-exclude';

# Option: --exclude 
# Takes a ^^ separated list of key words which will match terms in 
# your source directory you do not want synced or copied over to 
# destination. Separate items with ^^. Will match the entire path 
# so be aware. Note you can exclude directory names like artwork too.
# Sample: $EXCLUDE = 'millivanilli^^bonjovi^^artwork';
# Can also use a file with one exclude item per line. File name 
# must include the 'acxi-excludes' in it or it won't be used.
# you can use various excluldes to create various collections.
# Sample: $EXCLUDE = '/home/me/music/excludes/acxi-excludes-phone.txt';
my $EXCLUDE = '';

#### -------------------------------------------------------------------
#### CHECKSUM DATA
#### -------------------------------------------------------------------
# These are the file names MINUS the .ffp / .md5 extensions.
my $FFP_FILE='fingerprints';
my $MD5_FILE='md5sums';

#### -------------------------------------------------------------------
#### AUTO TAGGING
#### -------------------------------------------------------------------
# This is the file that contains the syntax found in auto.tag file. But
# you can call it something else if you prefer.
my $TAG_FILE='auto.tag';

#### -------------------------------------------------------------------
#### INPUT/OUTPUT
#### -------------------------------------------------------------------
# Options: -i/--input type ; -o/--output type
# The following are NOT case sensitive,ie flac/FLAC, txt/TXT will be 
# found. INPUT_TYPE and OUTPUT_TYPE will be forced to lower case 
# internally.
my $INPUT_TYPE = 'flac';
my $OUTPUT_TYPE = 'ogg';

# Option: -q/--quality number
# for flac: n can be 0-8. 0 produces largest file, is fastest, anything over 4
# is probably pointless since compression gain is very little vs time required.
# For mp3: n can be 0-9 (variable bit rate), 0 is largest file / highest quality
# For ogg: n can be between -1 and 10. Fractions allowed. 10 is the largest file 
# size / highest quality. 
# For opus: n can be 6-256. 256 is the largest file size / highest quality / 
# maximum bitrate. For flac 0-8 [0 biggest size, fastest], set to 4 because
# there is almost no size decrease with flac 5-8 but big cpu time increase.
my $QUALITY_FLAC = 4;
my $QUALITY_MP3 = 3;
my $QUALITY_OGG = 7;
my $QUALITY_OPUS = 144; # 128 claimed to be stereo transparent, 160 very good

# Option: -c/--copy and -a/--append (to append extension types to existing list.
## NOTE: if you want to override $COPY_TYPES in your config files, you
# must use this syntax:
# COPY_TYPES=doc,docx,bmp,png,doc,docx,jpg,jpeg,tif
# Add or remove types to copy over to ogg directories, do not include
# the input/output audio file types, only extra data types like txt.
# If you want no copying done, simply change to: $COPY_TYPES = 'none';
my $COPY_TYPES = 'gif,jpg,jpeg,png,txt';

#### -------------------------------------------------------------------
#### PRINT OUTPUT
#### -------------------------------------------------------------------
# OPtions: --basic -V/--verbose --full --log 0-4
# You can turn these to always on either here or in config file by setting to 
# desired verbosity level here directly, or in config file. 
# 0 = quiet/silent - no output at all; 
# 1 = default - single line per operation. This is the default, so you don't need 
#     to change it.
# 2 = verbose - but without the actual conversion data from codecs
# 3 = debug -  all available information.
# NOTE: with FORK > 1, conversion debugging output can be out of order.
my $LOG_LEVEL = 1;

#### -------------------------------------------------------------------
#### ADVANCED
#### -------------------------------------------------------------------

# For clean actions, do not clean items that are symbolic links in destination
my $CLEAN_INCLUDE_LINKS = 0;

# Options: --nlink --no-nlink
# Only change to 0 if you encounter file tree failures. This is for File::Find
# values:  0 - use nlink; 1 - don't use nlink [default, only change if you know
# why.
my $DONT_USE_NLINK = 1;

# Option: -F/--fork 0-xx
## number of forks/threads to use. 0 is default, and will not use forking
# note that debugging output gets strange with forking, so debug with fork = 0
# FORK = 1 results in slower times than using no forking so avoid that. 
my $FORK = 0;

# Only for maintainers, set to 0 in config file to disable.
my $ALLOW_UPDATES = 1;

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------
# this will be used to update the program and man page. You must have 
# write permissions to the file locations. Linux or BSD only.
# do not end paths with /

my $COMMAND_CURL='/usr/bin/curl';
my $MAN_DIRECTORY='/usr/local/share/man/man1';
my $SELF_DIRECTORY='/usr/local/bin';

#########################################################################
### END USER MODIFIABLE VALUES ###
#########################################################################

########################################################################
#### STARTUP
########################################################################

sub main {
	UserConfigs::set();
	get_options();
	set_display_data();
	SelfUpdater::update() if $run{'update'};
	Validation::check_user_values();
	set_basic_data();
	AutoTag::aggregate() if $run{'autotag-aggregate'};
	AutoTag::create_file() if $run{'autotag-create'};
	AutoTag::run_tagger() if $run{'autotag'};
	CleanCollection::process_destination() if $run{'clean'};
	SyncCollection::process_collection() if $run{'sync'};
	Checksums::process() if ($run{'checksum'} || $run{'checksum-verify'} );
	print_completion_message();
}

#########################################################################
### CLEAN/SYNC MUSIC DIRECTORIES ###-
#########################################################################

#### -------------------------------------------------------------------
#### AUTO-TAGGING
#### -------------------------------------------------------------------

## package AutoTag 
{
package AutoTag;
sub run_tagger {
	print $line_large;
	print "Starting auto-tagging in " . main::sourcer($SOURCE_DIRECTORY) . "...\n";
	get_tag_files();
	print $line_small;
	print "Completed auto-tagging.\n";
	print $line_large;
}
sub aggregate {
	print $line_large;
	print "Starting file aggregation from: " . main::sourcer($SOURCE_DIRECTORY) . "\n";
	print " to: " . main::sourcer($DESTINATION_DIRECTORY) . "\n";
	my @files = split /,/, $run{'ag-file'};
	# my $abs_path = Cwd::abs_path($SOURCE_DIRECTORY);
	chdir Cwd::getcwd(); #$SOURCE_DIRECTORY;
	foreach (@files){
		aggregate_file($_);
	}
	print $line_small;
	print "Completed file aggregation.\n";
	print $line_large;
	exit;
}
sub aggregate_file {
	($extension) = @_;
	my ($path,@files);
	my ($dir,$file,$file_working,$name);
	$list_type = 'file';
	@found_list = ();
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	print $line_small;
	print "Aggregating file type $extension...\n";
	print $line_small;
	foreach $file (sort @found_list) {
		$b_dest_changed = 1;
		$file_working = $file;
		$file_working =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		$dir = File::Basename::dirname($file_working);
		$name = File::Basename::basename($file_working);
		if ($run{'aggregate-file'}){
			$path = $DESTINATION_DIRECTORY . $path_separator . $dir . '.' . $name;
		}
		else {
			$path = $DESTINATION_DIRECTORY . $path_separator . $dir;
			if (! -d $path){
				File::Path::make_path($path) or die qq("Arg... can't make: $path\n") if !$b_test;
			}
			$path .= $path_separator . $name;
			#say 'path: ', $path;
		}
		say $file_working;
		say $file if $LOG_LEVEL > 3;
		File::Copy::copy($file, $path) if !$b_test;
		push @files, $file;
		$path = '';
	}
	if (!@found_list){
		print "No $extension type files found.\n";
	}
	print $line_small;
	# print Data::Dumper::Dumper \@files;
	print "Finished copying over $extension type files to " . main::sourcer("$DESTINATION_DIRECTORY" . "\n");
	
}
sub create_file {
	print $line_large;
	print "Creating $TAG_FILE in " . main::sourcer("$SOURCE_DIRECTORY") . "...\n";
	make_file();
	print $line_small;
	print "Completed file creation.\n";
	print $line_large;
}
sub get_tag_files {
	my ($item,$print_file,$result,$working_dir);
	$list_type = 'file';
	$extension = $TAG_FILE;
	@found_list = ();
	File::Find::find( \&main::wanted, "$SOURCE_DIRECTORY");
	my $start_dir = Cwd::getcwd();
	foreach $item (sort @found_list) {
		$print_file = $working_dir = $item;
		$print_file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
		# $working_dir =~ s/[^\/]+$//;
		$working_dir = File::Basename::dirname($item);
		chdir "$start_dir";
		chdir "$working_dir";
		if ($LOG_LEVEL > 3){
			say Cwd::getcwd();
			system 'pwd';
		}
		print "Processing: $print_file...\n";
		process_tags();
		$b_dest_changed = 1;
	}
	if (!@found_list) {
		print "No $TAG_FILE files found.\n";
	}
}
sub process_tags {
	my @tags = main::reader($TAG_FILE,'strip');
	my ($args,$error_message,@image_args,@images,@main_tags,
	@track_tags,@working);
	my ($b_image_check,$b_tracks);
	my ($cmd,$comments,$tag) = ('','','');
	state %set;
	foreach (@tags){
		@working=split /%:/, $_;
		#print Data::Dumper::Dumper \@working;
		next if ! $working[1];
		print "@working\n" if $LOG_LEVEL > 3;
		$working[1] =~ s/"/\\\"/g;
		$working[1] =~ s/\$/\\\$/g;
		if ($working[0] =~ /^(TITLE|TRACKNUMBER|VERSION|PART)$/){
			$tag = qq(--set-tag=$working[0]="$working[1]");
			push @track_tags, $tag;
		}
		elsif ($working[0] ne 'FILE') {
			# delete all previous items for key, to avoid multi tagging
			if ($b_tracks && (!$set{$working[0]} || $working[1] eq 'UNSET')){
				if ($working[0] eq 'IMAGE'){
					@images = (); # reset the images completely
				}
				else {
					@main_tags = grep {!/^--set-tag=$working[0]/} @main_tags;
				}
				next if $working[1] eq 'UNSET';
			}
			# then set the key flag again
			$set{$working[0]} = 1;
			if ($working[0] eq 'IMAGE'){
				$tag = qq($working[1]);
				push @images, $tag;
			}
			else {
				$tag = qq(--set-tag=$working[0]="$working[1]");
				push @main_tags, $tag;
			}
		}
		elsif ($working[0] eq 'FILE'){
			## NOTE: we have to unescape $ in paths for -e tests, but leave it escaped
			## for qq cmd strings. Why? Shell expands it, perl does not.
			my $temp = $working[1];
			$temp =~ s/\\\$/\$/g;
			print " Tagging \"$temp\"... ";
			main::error_handler('file-missing',"Missing file: $temp",1) if ! -e "$temp";
			# note: must be set here, not in qx to avoid quote errors
			# single quotes, in case contains $ symbol
			#say File::stat::stat("$working[1]")->size;
			$cmd = qq($COMMAND_METAFLAC --remove-all-tags "$working[1]");
			print "\n", $cmd, "\n" if $LOG_LEVEL > 3;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
			}
			if ($run{'remove-images'}){
				print "Removing images... ";
				$cmd = qq($COMMAND_METAFLAC --remove --block-type=PICTURE,PADDING --dont-use-padding "$working[1]");
				if (!$b_test){
					qx($cmd);
					if ($? > 0){
						$error_message = "$COMMAND_METAFLAC returned error: $?";
						main::error_handler('application-error', $error_message,1);
					}
				}
				print "\n", $cmd, "\n" if $LOG_LEVEL > 3;
			}
			#say File::stat::stat("$working[1]")->size;
			# disable for now, the test for type isn't working, metaflac is making types
			# 3 regardless of actual type.
			@image_args = image_handler("$working[1]",@images) if @images;
			@track_tags = (@main_tags,@image_args,@track_tags);
			$args = join ' ', @track_tags;
			@track_tags = ();
			@image_args = ();
			# reset all detected @main items
			foreach (keys %set) {
				$set{$_} = 0;
			}
			$cmd = qq($COMMAND_METAFLAC $args "$working[1]");
			print "\n", $cmd, "\n" if $LOG_LEVEL > 3;
			$b_tracks = 1;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
				say 'File tagged';
			}
			#say File::stat::stat("$working[1]")->size;
		}
	}
}
# note: metaflac is ignring type integer and assigning 3, not sure why
sub image_handler {
	my ($file,@images) = @_;
	my ($size,@args,@result,$working);
	my $cmd = qq($COMMAND_METAFLAC --list --block-type=PICTURE "$file");
	
	@result = qx($cmd);
	@result = grep {/type:.*\(PICTURE\)/} @result if @result;
	# filename: type: 6 (PICTURE) 3||||images/cover.jpg
	# --import-picture-from="3||||front.jpg"
	foreach (@images){
		$working = (split /\|/, $_)[-1];
		if (@result){
			print "\n  Skipping $working (pre-existing image data)... ";
		}
		else {
			if (-e $working){
				$size = sprintf("%.1f", File::stat::stat("$working")->size / 1024);
				push @args, qq(--import-picture-from="$_");
				print "\n  Embedding $working ($size KiB)... ";
			}
			else {
				print "\n  File $working not found... ";
			}
		}
	}
	return @args;
}
sub make_file {
	my ($file,@files);
	chdir $SOURCE_DIRECTORY;
	my $source_dir = $SOURCE_DIRECTORY;
	#$source_dir =~ s|([\(\)\$])|\\$1|g;
	$source_dir =~ s|^\Q$source_dir$path_separator\E||;
	say $source_dir;
	print "Checking for pre-existing $TAG_FILE... ";
	if ($b_test){
		print "Running test mode.\n";
	}
	elsif (-e $source_dir . $path_separator . $TAG_FILE){
		main::error_handler('file-exists', "File $TAG_FILE already exists in:\n$source_dir",1);
	}
	else {
		print "none found. Proceeding.\n";
	}
	if ($LOG_LEVEL > 3){
		say Cwd::getcwd();
		system 'pwd';
	}
	print "Creating $TAG_FILE file... ";
	$extension = $INPUT_TYPE;
	$list_type = 'file';
	@found_list = ();
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	print "\n" if $LOG_LEVEL > 2;
	foreach $file (sort @found_list) {
		$b_dest_changed = 1;
		$file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		say $file if $LOG_LEVEL > 2;
		push @files, $file;
	}
	if (@files){
		@files = sort @files; # can be a problem, if track number comes last!
		print "Processing.\n";
		populate_file(\@files);
	}
	else {
		print "No files found to process.\n";
	}
}
sub populate_file {
	my ($files) = @_;
	my (@multi,@replaygain,@tags);
	my ($b_first,$j,$holder,$starter) = (1,0,'','');
	my $counter=0;
	my @collection = (
	'## RECORDING NAME/CREATORS ##',
	'ALBUM','# Name to sort under','ALBUMSORT',
	'ARTIST','# Multi-Artist only','ALBUMARTIST',
	'COMPOSER','# Classical fields','CONDUCTOR','OPUS',
	'# Band members, etc.', 'PERFORMER','PERFORMER','PERFORMER','PERFORMER',
	'## RECORDING COMMENTS. Note: COMMENT preferred over DESCRIPTION ##',
	'COMMENT','COMMENT','COMMENT','COMMENT',
	 '## DISPLAY IMAGES ##',
	 '# Please see sample auto.tag file for more information on IMAGE',
	 '# Path to image file from where auto.tag file is located. Will be',
	 '# set as default type 3, cover image. ',
	 '# Example: IMAGE%:images/cover.jpg', 
	 '# To remove all embedded images:',
	 '# metaflac --remove --block-type=PICTURE,PADDING --dont-use-padding *.flac',
	 'IMAGE',
	'## RECORDING INFO ##',
	# note: VENUE and LABEL better handled by xiph spec: LOCATION and ORGANIZATION
	# Include YEAR to make conversion to mp3 tagging cleaner
	'GENRE','RATING','DATE','YEAR','LOCATION','PRODUCER','PUBLISHER',
	'# e.g. record label, taper group,, etc. ','ORGANIZATION',
	'## TECHNICAL INFORMATION ##',
	'ENCODING',
	'# Useful for tapers etc','SOURCE','SOURCE','SOURCE',
	'# Media recording taken from, eg, cassette, tape, dat, vinyl','SOURCEMEDIA',
	);
	my @discs = ('DISCNUMBER','DISCSUBTITLE','TRACKTOTAL');
	my @disc = ('','## DISC INFO ##',
	'# Leave DISCNUMBER, DISCTOTAL empty if 1 disc set',
	'DISCTOTAL',
	'# Do not leave TRACKTOTAL empty, this is per disc track totals for players',
	@discs,'',
	'## TRACK INFO ##', 
	'# Use of any of above tags between track blocks will switch to the new value.',
	'# To make the value empty use: UNSET as the field value.',
	'# TRACKNUMBER and FILE required, title not known?: suggest TITLE%:Unknown ');
	my @track = ('','TRACKNUMBER','TITLE','VERSION','PART','FILE');
	@collection = map {$_ .= '%:' if /^[A-Z]/; $_;} @collection;
	@disc = map {$_ .= '%:' if /^[A-Z]/; $_;} @disc;
	@discs = map {$_ .= '%:' if /^[A-Z]/; $_;} @discs;
	if ($run{'autotag-single'} && @$files){
		@disc = map {$_ .= scalar (@$files) if $_ eq 'TRACKTOTAL%:'; $_;} @disc;
	}
	if ($run{'autotag-multi'} && @$files){
		$autotag_multi =~ s/%/[1-9]/g;
		$autotag_multi =~ s/@/[A-Z]/g;
		# print "$autotag_multi\n";
		foreach (@$files){
			if (/^($autotag_multi)/i){
				$starter = $1;
				$counter++;
			}
			else {
				main::error_handler('autotag-multi',
				 "$autotag_multi filename start pattern not found in file!!",'');
			}
			if ($holder ne $starter){
				$j++;
				$holder = $starter;
				$multi[$j] = 1;
				$counter = 0;
				#say "$starter $j";
			}
			else {
				$multi[$j]++;
			}
		}
		shift @multi;# get rid of first element
		($counter,$j,$holder,$starter) = (0,0,'','');
		if (scalar @multi > 1){
			@disc = map {$_ .= scalar (@multi) if $_ eq 'DISCTOTAL%:'; $_;} @disc;
			@disc = map {$_ .= $multi[0] if $_ eq 'TRACKTOTAL%:'; $_;} @disc;
			@disc = map {$_ .= 1 if $_ eq 'DISCNUMBER%:'; $_;} @disc;
		}
	}
	#print Data::Dumper::Dumper \@multi, "\n";
	@tags = (@collection,@disc);
	@track = map {$_ .= '%:' if /^[A-Z]/; $_;} @track;
	my @disc_working;
	foreach (@$files){
		$counter++;
		my @track_working = @track;
		if ($run{'autotag-multi'} && scalar @multi > 1){
			if (/^($autotag_multi)/i){
				$starter = $1;
			}
			if ($holder ne $starter){
				$holder = $starter;
				# say "$starter";
				if (!$b_first){
					$counter = 1;
					$j++;
					@disc_working = @discs;
					$disc_working[0] .= $j+1;
					$disc_working[2] .= $multi[$j];
					@tags = (@tags,'',@disc_working);
				}
				$b_first = 0;
			}
		}
		if ($run{'autotag-single'} || $run{'autotag-multi'}){
			$track_working[1] = $track[1] . $counter;
		}
		$track_working[5] = $track[5] . $_;
		if (!$run{'no-replaygain'}){
			@replaygain = get_replaygain($_);
			# we want the replaygain data right before FILE
			splice (@track_working, 5, 0, @replaygain) if @replaygain;
		}
		@tags = (@tags,@track_working);
	}
	if ($b_test){
		print join "\n", @tags, "\n";
	}
	else {
		main::writer($TAG_FILE,\@tags);
	}
}
sub get_replaygain {
	my ($input_file) = @_;
	my (@tags);
	my %replaygain = main::get_flac_tags('replaygain',$input_file);
	foreach (keys %replaygain){
		push @tags, "$_%:$replaygain{$_}" if $replaygain{$_};
	}
	return @tags;
}
# --preserve-modtime --remove-all-tags --remove-tag
## end of AutoTag
}

#### -------------------------------------------------------------------
#### CHECKSUMS
#### -------------------------------------------------------------------

## package Checksums 
{
package Checksums;
sub process {
	print $line_large;
	print "Starting checksum processing in " . main::sourcer("$SOURCE_DIRECTORY") . "...\n";
	process_directories();
	print $line_small;
	print "Completed checksum processing.\n";
	print $line_large;
}
sub process_directories {
	my (@files,$item,$print_src,$result);
	$list_type = 'dir';
	print $line_small;
	print "Checking directories...\n";
	@found_list = ();
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	my $start_dir = Cwd::getcwd();
	say 'start dir: ', $start_dir if $LOG_LEVEL > 3;
	foreach $item (sort @found_list) {
		my $b_valid;
		$print_src = $item;
		$print_src =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
		$print_src = main::sourcer("$print_src");
		#if ($LOG_LEVEL > 2){
		#	say Cwd::getcwd();
		#	system 'pwd';
		#}
		chdir "$start_dir";
		chdir "$item";
		if ($LOG_LEVEL > 3){
			say 'srcdir: ', $SOURCE_DIRECTORY;
			say 'item: ', $item;
			say 'cwd: ', Cwd::getcwd();
			system 'pwd';
		}
		print "Processing: $print_src...\n";
		@files = main::globber("*.{flac,FLAC}");
		#print "\n", Data::Dumper::Dumper @files, "\n";
		if (grep -f, @files){
			delete_checksums() if $run{'checksum-delete'};
			generate_checksums() if $run{'checksum'};
			$b_dest_changed = 1;
		}
		else {
			print " No $INPUT_TYPE files\n";
		}
		verify_checksums(@files) if $run{'checksum-verify'};
	}
}
sub generate_checksums {
	my ($error_message,@output);
	system('pwd') if $LOG_LEVEL > 3;
	print " Generating checksums: ";
	print "$MD5_FILE.md5: ";
	# system("$COMMAND_MD5 *.* > $MD5_FILE.md5");
	@output = qx($COMMAND_MD5 *.*);
	if ($? == -1 || $? > 0){
		$error_message = "$COMMAND_MD5 returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	else {
		chomp (@output = grep {$_ !~ m^($TAG_FILE|\.ffp|\.md5)^} @output);
		if (!$b_test){
			main::writer("$MD5_FILE.md5",\@output);
			print "created; " ;
		}
		else {
			print "\n", join( "\n", @output),"\n";
		}
	}
	print "$FFP_FILE.ffp: ";
	if (!$run{'no-ffp'}){
		#system("$COMMAND_METAFLAC --show-md5sum *.flac > $FFP_FILE.ffp");
		@output = qx($COMMAND_METAFLAC --show-md5sum *.flac);
		if ($? == -1 || $? > 0){
			$error_message = "$COMMAND_METAFLAC returned error: $?";
			main::error_handler('application-error', $error_message,1);
		}
		else {
			chomp (@output);
			if (!$b_test){
				main::writer("$FFP_FILE.ffp",\@output);
				say "created" ;
			}
			else {
				print "\n", join( "\n", @output),"\n";
			}
		}
	}
	else {
		say "skipped" ;
	}
}
sub verify_checksums {
	my (@files) = @_;
	verify_flacs() if !$run{'no-ffp'} && grep -f, @files;
	verify_md5();
}
# NOTE: something is wrong with how flac outputs to stderr and
# creates invisible text strings, maybe unicode related
sub verify_flacs {
	my ($error_message,@errors);
	print " Verifying $INPUT_TYPE files (be patient): ";
	# note, flac sends output to stderr
	# NOTE: $_ =~ s/([^\x20-\x7E])/sprintf '\x{%02x}', ord $1/eg;
	# shows the weird hidden text this command creates
	#say 'cwd: ', Cwd::getcwd();
	if ( ! (grep -f, main::globber("*.$INPUT_TYPE") ) ){
		print "No $INPUT_TYPE files found.\n";
		return;
	}
	my @results = qx($COMMAND_FLAC -wt *.flac 2>&1);
	if ($? > 0){
		$error_message = "$COMMAND_FLAC returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	#print scalar @results, "\n", "@results","\n";
	chomp @results;
# 	foreach (@results){
# 		$_ =~ s/([^\x20-\x7E])/sprintf '\x{%02x}', ord $1/eg;
# 		print "##$_##\n";
# 	}
	#@results = grep {/\.$INPUT_TYPE:\s/i} @results;
	# track.flac: testing, 33% completetesting, 65% completetesting, 98% completeok
	#@results = map {
	my $i = 0;
	my ($holder,$b_start,@temp);
	foreach (@results){
		#print length($_), "\n";
		$_ =~ s/\s+$//;
		#print "${_}::\n";
		next if /^\s*$/;
		$b_start = 1 if !$b_start && $_ =~ /\.$INPUT_TYPE:/;
		next if !$b_start;
		$_ =~ s/(testing.*complete|\x{08})//gi;
		$_ =~ s/[^[:print:]]+//g;
		#print length($_), "\n";
		# the idiocy of flac output is hard to put into words
		# not only do they use those backspace hidden things, but
		# sometimes they decide to put the ok/failed on its own line!!!
		if (/\.$INPUT_TYPE:\s[a-z]+/i){
			push @temp, $_;
			$i++;
		}
		elsif(/\.$INPUT_TYPE:$/i){
			$holder = $_;
			$i++;
			#print "$i $holder\n";
		}
		else {
			#print "$i $_\n";
			$temp[$i-1] = $holder . ' ' . $_;
		}
	}
	@results = @temp;
	#print scalar @results, "\n", "@results","\n";
	# NOTE: cases found where ok and rest of string prints on next line!!
	@errors = grep {!/\.$INPUT_TYPE: ok$/i} @results;
	@results = grep {/\.$INPUT_TYPE: ok$/i} @results;
	#print scalar @results, "\n", "@errors","\n";
	#print "errors:\n", join "\n", @errors, "\n";
	if (@errors){
		print "\n  ERROR!\n   The following files show errors:\n   ", join "\n    ", @errors, "\n";
	}
	if (@results){
		if ($LOG_LEVEL > 1){
			print "\n  Verified files:\n    ",  join "\n    ", @results, "\n";
		}
		else {
			print "Verified\n";
		}
	}
	else {
		print "No verified $INPUT_TYPE files\n";
	}
}
sub verify_md5 {
	my (@data,@errors,@results,@working);
	my ($b_bad,$b_break,$cmd,$hash,$hash2,$error_message,$msg,$result);
	my @checksums = main::globber("*.{md5,md5.txt}");
	foreach my $file (@checksums){
		print " Checking checksums in: $file: ";
		@data = main::reader("$file",'strip');
		#print "data\n", join ("\n", @data), "\n";
		$b_break = 0;
		foreach my $track (@data){
			#print "track: $track\n";
			($hash,$hash2) = ('','');
			$track =~ /^([a-f0-9]+)([\s\*]+)(.*)$/;
			if ($1 && $3){
				$hash = $1;
				$track = $3;
				# convert to local paths, windows vs nix
				$track =~ s^[/|\\]^$path_separator^g;
				if ($LOG_LEVEL > 1){
					print "\n" if !$b_break;
					print "   Checking: $track: ";
					$b_break = 1;
				}
				if (-e "$track"){
					$cmd = qq($COMMAND_MD5 "$track");
					$result = qx($cmd);
					$hash2 = (split /\s/, $result)[0];
				}
				else {
					$hash2 = 'missing';
				}
				if ($hash2){
					if ( $hash eq $hash2) {
						print "Matched\n" if $LOG_LEVEL > 1;
					}
					else {
						print "\n" if !$b_break;
						print "   $track: " if $LOG_LEVEL < 2;
						$msg = ($hash2 ne 'missing') ? "FAILED" : "FAILED: File Not Found";
						print "$msg\n";
						$b_bad = 1;
						$b_break = 1;
					}
					if ($LOG_LEVEL > 2){
						print "   MD5 Test: $hash Actual: $hash2\n";
					}
				}
			}
		}
		print "All Files Matched\n" if !$b_bad && $LOG_LEVEL < 2;
	}
}
sub delete_checksums {
	my $error_message = '';
	# note: some checksum generators tack on a .txt to the filename.
	my @checksums = main::globber("*.{ffp,ffp.txt,md5,md5.txt}");
	# print Data::Dumper::Dumper @checksums, "\n";
	foreach my $file (@checksums){
		print " Deleting $file: ";
		if ($b_test){
			say "test deletion";
		}
		elsif (unlink($file)){
			say "deleted";
		}
		else {
			main::error_handler('checksum-delete', "Failed to delete: $file");
		}
	}
}
}

#### -------------------------------------------------------------------
#### CLEANING
#### -------------------------------------------------------------------

## package CleanCollection
{
package CleanCollection;

sub process_destination {
	print $line_large;
	print "Starting cleanup of " . main::sourcer("$DESTINATION_DIRECTORY") . "...\n";
	process_type('directory');
	process_type('file');
	print $line_small;
	print "Completed cleanup checks.\n";
	print $line_large;
	exit if !$run{'clean-sync'};
}
sub process_type {
	my ($type) = @_;
	my ($b_deleted,$item,$result);
	$list_type = ($type eq 'directory') ? 'dir-clean': 'file-clean';
	print $line_small;
	print "Checking $type removal...\n";
	@found_list = ();
	File::Find::find( \&main::wanted, $DESTINATION_DIRECTORY);
	@found_list = grep { ! -l $_; $_} @found_list if ! $CLEAN_INCLUDE_LINKS;
	if (@found_list && confirm_deletion($type)){
		foreach $item (sort @found_list) {
			$result = 'UNSET';
			print "Deleting $type: $item\n";
			$result = File::Path::rmtree("$item") if !$b_test;
			$b_deleted = 1;
			$b_dest_changed = 1;
			print "Delete $type result: $result\n" if $LOG_LEVEL > 1;
		}
	}
	main::print_not_found("$type-cleaned") if ! $b_deleted;
}
sub confirm_deletion {
	my ($type) = @_;
	my ($b_confirm,$response) = (0,'');
	print $line_small;
	print join("\n", @found_list),"\n";
	print $line_small;
	print "The preceding $type items will be deleted. Deletions cannot\n";
	print "be restored! BE AWARE!!\n";
	print "Please type 'delete' + 'enter' to remove them, or hit 'enter' to skip.\n";
	print "If you are unsure, hit 'enter' to see the file list.\n" if $type eq 'directory';
	chomp($response = <STDIN>);
	if (lc($response) eq 'delete'){
		print "Are you SURE you want to delete these items?\n";
		print "Type 'yes' + 'enter' to confirm, or hit 'enter' to skip.\n";
		chomp($response = <STDIN>);
		return 1 if lc($response) eq 'yes';
	}
	print "Skipping deletion for this $type group.\n";
	return 0;
}
## end package 
}

#### -------------------------------------------------------------------
#### SYNCING
#### -------------------------------------------------------------------

## package SyncCollection 
{
package SyncCollection; 

sub process_collection {
	my (@extension_files);
	eval $print_line_heavy;
	if ( $LOG_LEVEL > 1 ) {
		print "Syncing " . main::sourcer("$DESTINATION_DIRECTORY") . " (destination) with\n";
		print "  " . main::sourcer("$SOURCE_DIRECTORY") . " (source)...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Starting sync of " . main::sourcer("$SOURCE_DIRECTORY");
		print "\n to " . main::sourcer("$DESTINATION_DIRECTORY") . "\n";
	}
	update_directories();
	$list_type = 'file';
	foreach (@extension_list) {
		eval $print_line_large;
		$extension = $_;
		@found_list = ();
		File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
		# print Dumper \@found_list;
		if ( $LOG_LEVEL > 1 ) {
			print "PROCESSING DATA TYPE: $extension\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\n" . main::dotify("Processing $extension data type");
		}
		if (@found_list){
			update_files();
		}
		else {
			main::print_not_found('extension');
		}
	}
}
# Recreate the directory hierarchy.
sub update_directories {
	my ($b_created,$dest_dir,$dir,$result);
	$list_type = 'dir';
	@found_list = ();
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	eval $print_line_large;
	# print Dumper \@found_list;
	if ( $LOG_LEVEL > 1 ) {
		print "Checking if $SELF_NAME needs to create destination directories...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print main::dotify("Updating destination directories");
	}
	foreach $dir (sort @found_list) {
		#print "\nd1:$dir\n";
		$result = 'UNSET';
		next if $dir eq $SOURCE_DIRECTORY || $dir eq $DESTINATION_DIRECTORY;
		$dir =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||; # strip out source path
		next if !$dir;
		$dest_dir = $DESTINATION_DIRECTORY . $path_separator . $dir;
		#print "d2:$dir\n";
		# check to see if the destination dir already exists
		if ( ! stat("$dest_dir") ) {
			# stat failed so create the directory
			eval $print_line_small;
			if ( $LOG_LEVEL > 1 ) {
				print "CREATING NEW DIRECTORY:\n $dest_dir\n";
			}
			elsif ( $LOG_LEVEL > 0 ) {
				print "\nCreating new directory: $dest_dir";
			}
			$dest_dir =~ s/\`/\'/g; # get rid of weird characters
			$result = mkdir("$dest_dir") if !$b_test;
			$b_created = 1;
			$b_dest_changed = 1;
			print "Create Directory result: $result\n" if $LOG_LEVEL > 1;
		}
	}
	main::print_not_found('dirs') if ! $b_created;
}

sub update_files {
	my ($b_created);
	my ($dest_file,$file,$result,$action,$src_file) = ('','','','','');
	my ($dest_info,$dest_mod_time,$src_info, $src_mod_time) = ('',0,'',0);
	my $pm = new Parallel::ForkManager($FORK) if $b_fork;
	foreach $file (sort @found_list) {
		next if ! $file;
		$dest_file = $src_file = $file;
		#print "\nIF: $src_file\n";
		$dest_file =~ s|^$SOURCE_DIRECTORY|$DESTINATION_DIRECTORY|;
		$dest_file =~ s/\`/\'/g;
		# $dest_file =~ s/\$/\\\$/g;
		# get rid of escape sequences in case someone used them: \40
		# $src_file =~ s/\0//g; 
		$dest_file =~ s/\0//g;
		# Figure out what the destination file would be...
		if ( lc($extension) eq $INPUT_TYPE ){
			$dest_file =~ s/\.$INPUT_TYPE$/\.$OUTPUT_TYPE/i;
		}
		#print "OF: $dest_file\n";
		($action,$result,$dest_mod_time,$src_mod_time ) = ('UNSET','UNSET',0,0);
		# Now stat the destinationFile, and see if it's date is more recent
		# than that of the original file. If so, we re-encode.
		# We also re-encode if the user supplied --force
		$src_info = File::stat::stat("$src_file") or 
		  main::error_handler('stat-infile', "No $src_file: $!",1);
		$src_mod_time = $src_info->mtime if $src_info;
		$dest_info = File::stat::stat("$dest_file");
		if ( $dest_info ) {
			$dest_mod_time = $dest_info->mtime;
			#  :: FORCE: $b_force
# 			print "DEST_MOD: $dest_mod_time :: SRC_MOD: $src_mod_time\n"; 
# 		} else {
# 			print "NOT EXISTS: $dest_file \n"; 
# 			print "P1: $file ==> \n  $dest_file\n"; 
		}
		# If the destination file does not exist, or the user specified force,
		# or the srcfile is more recent then the dest file, we encode/copy.
		# print "src-mt: $src_mod_time dest-mt:$dest_mod_time\n";
		if ( !$dest_info || $b_force || ( $src_mod_time > $dest_mod_time) ) {
			# these have to be set before the forking
			$b_created = 1;
			$b_dest_changed = 1;
			if ( lc($extension) eq $INPUT_TYPE ){
				$pm->start and next if $b_fork; # do the fork 
				my @returns = convert_file($src_file, $dest_file);
				$result = $returns[0];
				$action = $returns[1];
				$pm->finish if $b_fork;
			} 
			else {
				$action = 'Copy';
				$result = copy_file($file, $src_file, $dest_file);
			}
			# NOTE: for forking > 1, this will not print out for the output/input conversion files 
			print "$action result: $result\n" if $LOG_LEVEL > 1;
		} 
	}
	# wait for all the forks to finish before terminating 
	# the parent.. otherwise terminating the parent force kills 
	# all the forks 
	$pm->wait_all_children if $b_fork;
	main::print_not_found('files') if ! $b_created;
}

sub copy_file {
	my ($file, $src_file, $dest_file) = @_;
	my $result = 'UNSET';
	my ($src_print,$dest_print) = ($src_file, $dest_file);
	$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	eval $print_line_small;
	if ( $LOG_LEVEL > 1 ) {
		print "COPY: $src_print ==> \n";
		print "      $dest_print\n"; 
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "\nCopying $src_print...";
	}
	if (!$b_test){
		$result = File::Copy::copy($src_file, $dest_file) or 
			main::error_handler('cp-file', "cp failure: $src_file =>\n$dest_file\nCode: $!",1);
	}
	return $result;
}

sub convert_file { 
	my ($src_file, $dest_file) = @_;
	my ($src_print,$dest_print) = ($src_file, $dest_file);
	my ($result,$cmd,$action) = (1000,'','unset'); 
	# escape characters for conversion processing
	$src_file =~ s/"/\\"/g;
	$dest_file =~ s/"/\\"/g;
	$src_file =~ s/`/\\`/g;
	$dest_file =~ s/`/\\`/g;
	$src_file =~ s/\$/\\\$/g;
	$dest_file =~ s/\$/\\\$/g;
	$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	# with forking, the printing gets messed up unless it's done 
	# just like this.
	if (!$b_fork){
		eval $print_line_small;
		if ( $LOG_LEVEL > 1 ) {
			print "ENCODE: $src_print ==> \n";
			print "        $dest_print\n"; 
		}
		elsif ( $LOG_LEVEL > 0 ) {
			# add line break only when file exists
			print main::dotify("\nEncoding $src_print to $OUTPUT_TYPE");
		}
	}
	if ( $OUTPUT_TYPE eq 'flac' ){
		$action = 'To flac';
		if (!$b_test){
			qx($COMMAND_FFMPEG $silent_ffmpeg -y -i "$src_file" -aq $quality "$dest_file" );
			$result = $?;
		}
	}
	
	elsif ( $OUTPUT_TYPE eq 'ogg' ){
		$action = 'To ogg';
		# ffmpeg -i 'file.flac'  -map_metadata:s:a 0:g 'file.ogg'
		# my $meta_data = '--map_metadata:s:a 0:g';
		if (!$run{'ffmpeg'} && !$b_test){
			qx($COMMAND_OGG $silent_flac -q $quality -o "$dest_file" "$src_file");
			$result = $?;
		}
		if ($run{'ffmpeg'} && !$b_test){
			qx($COMMAND_FFMPEG $silent_ffmpeg -y -i "$src_file" -map_metadata:s:a 0:s -aq $quality "$dest_file")
		}
	}
	elsif ( $OUTPUT_TYPE eq 'opus' ){
		$action = 'To opus';
		if (!$b_test){
			qx($COMMAND_OPUS $silent_opus --bitrate $quality "$src_file" "$dest_file");
			$result = $?;
		}
	}
	elsif ( $OUTPUT_TYPE eq 'mp3' ){
		$action = 'To mp3';
		if (!$b_test){
			# Modified: Odd @2011-03-23 01:51:26 - Include ID3 copying
			$cmd = main::flac2mp3_cmd("$src_file","$dest_file");
			qx($cmd);
			$result = $?;
		}
	}
	if ($b_fork){
		eval $print_line_small;
		if ( $LOG_LEVEL > 1 ) {
			print "ENCODED: $src_print ==> \n";
			print "        $dest_print\n"; 
			print "$action result: $result\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			# add line break only when file exists
			print main::dotify("\nEncoded $src_print to $OUTPUT_TYPE");
		}
	}
	# this return only works with non forking
	return ($result,$action); 
}
## end package 
}

#### -------------------------------------------------------------------
#### TAGGING
#### -------------------------------------------------------------------

# Added: Odd @2011-03-23 01:52:31
sub flac2mp3_cmd {
	my ($i_file, $o_file) = @_;
	my %tags = get_flac_tags('standard',"$i_file");
	my $lame_params = '';
	# print Dumper \%tags;
	if ($tags{'TRACKNUMBER'} && $tags{'TRACKTOTAL'}){
		$tags{'TRACKNUMBER'} .= "/$tags{'TRACKTOTAL'}";
	}
	if ($tags{'DISKNUMBER'} && $tags{'DISKTOTAL'}){
		$lame_params .= "--tv \"TPOS=$tags{'DISKNUMBER'}/$tags{'DISKTOTAL'}\" ";
	}
	$lame_params .= " --ta \"$tags{'ARTIST'}\" --tl \"$tags{'ALBUM'}\"";
	$lame_params .= " --tt \"$tags{'TITLE'}\" --tg \"$tags{'GENRE'}\"";
	$lame_params .= " --ty \"$tags{'DATE'}\" --tn \"$tags{'TRACKNUMBER'}\" - \"$o_file\"";
	# $lame_params .= " --tt \"$tags{'TRACKTOTAL'}\" --tg \"$tags{'DISKNUMBER'}\"";
	my $cmd = "$COMMAND_FLAC $silent_flac -d -c \"$i_file\" | ";
	$cmd .= "$COMMAND_LAME $silent_lame -h -V $quality $lame_params";
	return $cmd;
}

# Added: Odd @2011-03-23 01:52:17
# args: $type: standard|replaygain; $i_file: file to work on
# For this function to work reliably, it should be passed tag queries in the order of:
# artist, album, title, genre, date, tracknumber
sub get_flac_tags {
	my ($type,$i_file) = @_;
	my (%tag_list,@tags,@working);
	if ($type eq 'standard'){
		@tags = ('ARTIST', 'ALBUM', 'TITLE','GENRE', 'DATE', 'TRACKNUMBER', 
		'TRACKTOTAL','DISKNUMBER','DISKTOTAL');
	}
	elsif ($type eq 'replaygain'){
		@tags = ('REPLAYGAIN_TRACK_PEAK','REPLAYGAIN_TRACK_GAIN',
		'REPLAYGAIN_ALBUM_PEAK','REPLAYGAIN_ALBUM_GAIN','WAVEFORMATEXTENSIBLE_CHANNEL_MASK');
	}
	my $cmd = "$COMMAND_METAFLAC \"$i_file\" ";
	foreach (@tags){
		$cmd .= "--show-tag=\"$_\" ";
	}
	my @orig_tags = qx($cmd);
	chomp @orig_tags;
	foreach (@orig_tags) {
		@working = split /=/,$_;
		$tag_list{$working[0]} = $working[1];
	}
	# create missing hash keys
	foreach (@tags){
		$tag_list{$_} = '' if ! defined $tag_list{$_};
	}
	# print Dumper \%tag_list;
	return %tag_list;
}

#########################################################################
### PROGRAM TOOLS ###
#########################################################################

#### -------------------------------------------------------------------
#### UTILITIES
#### -------------------------------------------------------------------

# $1 - Perl module to check
sub check_module {
	my ($module) = @_;
	my $b_present = 0;
	eval "require $module";
	$b_present = 1 if !$@;
	return $b_present;
}

sub dotify {
	my $string = $_[0];
	while (length($string) < 53){
		$string .= '.';
	}
	$string .= ' ';
	return $string;
}

# args: 1 - string value to glob
# Note: because of spaces and other strange user file paths, need to use 
# bsd glob, which returns space agnostic globs, as you'd expect. 
sub globber {
	#my @files = glob qq{"$_[0]"};
	#print Data::Dumper::Dumper @files;
	#return @files;
	return <$_[0]>;
}

# returns either printed source, or in case of ., return full path
sub sourcer {
	($_[0] eq '.' ) ? Cwd::getcwd() : $_[0];
}
# arg: 1 - full file path, returns array of file lines.
# 2 - 'strip': strip and clean data
# note: chomp has to chomp the entire action, not just <$fh>
sub reader {
	my ($file,$strip) = @_;
	open( my $fh, '<', $file ) or error_handler('open', $file, $!);
	chomp(my @rows = <$fh>);
	if ($strip && @rows){
		@rows = grep {!/^\s*#|^\s*$/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	return @rows;
}

# NOTE: File::Find will not follow symbolic links
sub wanted {
	return if -l; # skip symbolic links
	return if $File::Find::name =~ m/\Qlost+found\E/;
	if ($list_type eq 'dir' || $list_type eq 'file'){
		return if $File::Find::name =~ m/^\Q$DESTINATION_DIRECTORY\E/;
		return if $File::Find::name =~ m/\/\./; # skip any dot files/directories
		return if $run{'sync'} && @excludes && ( grep {$File::Find::name =~ /\Q$_\E/} @excludes );
		if ($list_type eq 'dir'){
			return if ! -d; # only directories
		}
		elsif ($list_type eq 'file') {
			return if -d; # skip directories
			# extension can be either a full file name, or extension
			return if $File::Find::name !~ /(\.|\/)$extension$/i;
		}
	}
	elsif ($list_type eq 'dir-clean' || $list_type eq 'file-clean'){
		if ($list_type eq 'dir-clean') {
			return if ! -d; # skip non directories
		}
		else {
			return if -d; # skip non directories
		}
		my $working = $File::Find::name;
		$working =~ s|^\Q$DESTINATION_DIRECTORY\E|$SOURCE_DIRECTORY|;
		$working =~ s/\.$OUTPUT_TYPE$/\.$INPUT_TYPE/i if $list_type eq 'file-clean';
		#print '1: ', "$File::Find::name\n$working\n";
		return unless ! -e $working || (@excludes && (grep {$File::Find::name =~ /\Q$_\E/} @excludes) );
		# print '2: ', "$File::Find::name\n";
	}
	# print $File::Find::name . "\n";
	push (@found_list, $File::Find::name);
	return;
}

# arg: 1 file full  path to write to; 2 - arrayof data to write. 
# note: turning off strict refs so we can pass it a scalar or an array reference.
sub writer {
	my ($path, $ref_content) = @_;
	my ($content);
	no strict 'refs';
	# print Dumper $ref_content, "\n";
	if (ref $ref_content eq 'ARRAY'){
		$content = join "\n", @$ref_content or die "failed with error $!";
	}
	else {
		$content = scalar $ref_content;
	}
	open(my $fh, ">", $path) or 
	 error_handler('open',"$path failed to open for writing.\nMessage: $!",1);
	print $fh $content;
	close $fh;
}

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------

## package SelfUpdater
{
package SelfUpdater;
my $self_source = "$SELF_DIRECTORY$path_separator$SELF_NAME";
my $man_source = "$MAN_DIRECTORY$path_separator$SELF_NAME.1";

sub update {
	print $line_large;
	print "Starting $SELF_NAME self updater.\n";
	validate();
	grab();
	print "Completed self updates.\n";
	print $line_large;
	exit 0;
}
sub grab {
	my ($cmd,@content);
	print "Downloading $SELF_NAME.\n";
	$cmd = "$COMMAND_CURL -L https:/smxi.org/acxi";
	print $line_small;
	@content = qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Self update error: curl returns: $?.",1);
	}
	chomp(@content);
	print $line_small;
	print "Verifying $SELF_NAME data... ";
	if (! grep {/###\*\*EOF\*\*###/} @content){
		main::error_handler('self-updater',"Self update error: Download data corrupted.",1);
	}
	else {
		print "Verified.\nWriting to $SELF_NAME location... ";
		main::writer($self_source,\@content);
		print "File updated\n";
	}
	print "Downloading $SELF_NAME.1 man page.\n";
	$cmd = "$COMMAND_CURL -L https:/smxi.org/acxi.1";
	print $line_small;
	@content = qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Man update error: curl returns: $?.",1);
	}
	chomp(@content);
	print $line_small;
	print "Verifying $SELF_NAME.1 data... ";
	if (! grep {/\Qis a fork and full rewrite of flac2ogg.pl.\E/} @content){
		main::error_handler('self-updater',"Man update error: Download data corrupted.",1);
	}
	else {
		print "Verified.\nWriting to $SELF_NAME.1 location... ";
		main::writer($man_source,\@content);
		print "File updated\n";
	}
}
sub validate {
	print "Validating data... ";
	if (!$ALLOW_UPDATES){
		main::error_handler('self-updater',"Self Updater has been disabled by package maintainer.",1);
	}
	if (!-e $self_source){
		main::error_handler('self-updater',"Only updating $SELF_NAME at $self_source supported.",1);
	}
	if (!-e $man_source){
		main::error_handler('self-updater',"Only updating man at $man_source supported.",1);
	}
	if (!-x $COMMAND_CURL){
		main::error_handler('self-updater',"Downloader: $COMMAND_CURL missing or not executable.",1);
	}
	if (!-w $self_source){
		main::error_handler('self-updater',"$self_source is not writeable. Need superuser rights?",1);
	}
	if (!-w $man_source){
		main::error_handler('self-updater',"$man_source is not writeable. Need superuser rights?.",1);
	}
	print "Valid\n";
}
}

#### -------------------------------------------------------------------
#### VALIDATION - ERROR HANDLING
#### -------------------------------------------------------------------

## Args: 1: error id; 2: error message; 3: extt 0/1 [f/t]
sub error_handler {
	my ($error,$message,$b_exit) = @_;
	my ($br,$error_text) = ("\n",'');
	state $b_valid = 1;
	state $error_no = 0;
	if ($error eq 'unsupported-type'){$error_no = 2;$b_valid=0;}
	elsif ($error eq 'dest-dir'){$error_no = 1;$b_valid=0;}
	elsif ($error eq 'dest-eq-src-dir'){$error_no = 9;$b_valid=0;$br=''}
	elsif ($error eq 'missing-app'){$error_no = 3;$b_valid=0;}
	elsif ($error eq 'quality-invalid'){$error_no = 4;$b_valid=0;}
	elsif ($error eq 'bad-level'){$error_no = 5;$b_valid=0;}
	elsif ($error eq 'bad-fork'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-nlink'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-exclude-file'){$error_no = 19;$b_valid=0;}
	elsif ($error eq 'self-updater'){$error_no = 17;}
	elsif ($error eq 'open'){$error_no = 14;}
	elsif ($error eq 'file-exists'){$error_no = 16;}
	elsif ($error eq 'file-missing'){$error_no = 15;}
	elsif ($error eq 'stat-infile'){$error_no = 6;}
	elsif ($error eq 'missing-arg'){$error_no = 7;
		$message = "Option: $message";$br=''}
	elsif ($error eq 'application-error'){$error_no = 11;}
	elsif ($error eq 'checksum-delete'){$error_no = 12;}
	elsif ($error eq 'invalid-options'){$error_no = 13;$br=''}
	elsif ($error eq 'unsupported-option'){$error_no = 8;$br=''}
	elsif ($error eq 'autotag-multi'){$error_no = 18;}
	elsif ($error eq 'missing-perl-module'){$error_no = 10;
		$message = "Perl Module not found in system: $message";}
	if ($error eq 'validation-errors'){
		if (!$b_valid ){
			$message = "${br}Failed pretests. Please correct the listed errors.\n";
		}
		else {
			$message = "Pretests passed. Continuing.\n" if $LOG_LEVEL > 0;
			$b_exit = 0;
		}
	}
	else {
		$message = "${br}Error $error_no: $message\n";
	}
	print "$message" if $message;
	exit $error_no if $b_exit;
}

## package Validation 
{
package Validation;
my ($b_valid_in_out) = (0);
sub check_user_values {
	start_text();
	check_log_level();
	check_nlink();
	check_fork();
	check_excludes();
	check_src_dest_directories();
	check_in_out_types();
	if ($b_valid_in_out){
		check_quality() if $b_check_out;
		check_application_paths();
	}
	main::error_handler('validation-errors', '',1);
}
sub start_text {
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_heavy;
		print "Running $SELF_NAME pretests.\n";
	}
}
sub check_in_out_types {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_large;
		print main::dotify("Checking input and output types");
	}
	if ($run{'ffmpeg'} && ($INPUT_TYPE !~ /^(flac)$/ || $OUTPUT_TYPE !~ m/^(ogg)$/i) ){
		$b_error = 1;
		$error_message .= "\n  The input/output type combination you entered is not supported: ";
		$error_message .= "in: $INPUT_TYPE out: $OUTPUT_TYPE";
	}
	if ((!$run{'checksum'} && !$run{'checksum-verify'} && 
	 $INPUT_TYPE !~ m/^(flac|raw|shn|wav)$/i) ||
	 (($run{'checksum'} || $run{'checksum-verify'} || $run{'autotag'}) && 
	 $INPUT_TYPE !~ m/^(flac)$/i)){
		$b_error = 1;
		$error_message .= "\n  The input type you entered is not supported: ";
		$error_message .= "$INPUT_TYPE";
	}
	if ( $b_check_out && $OUTPUT_TYPE !~ m/^(flac|mp3|ogg|opus)$/i ){
		$b_error = 1;
		$error_message .= "\n  The output type you entered is not supported: ";
		$error_message .= "$OUTPUT_TYPE";
	}
	if ( $b_check_out && $OUTPUT_TYPE eq lc('mp3') && $INPUT_TYPE ne lc('flac') ){
		$b_error = 1;
		$error_message .= "\n  The output type $OUTPUT_TYPE you entered ";
		$error_message .= "only supports input type: flac";
	}
	if ($b_check_out && $INPUT_TYPE =~ m/^(raw|shn)$/ && $OUTPUT_TYPE ne lc('flac')){
		$b_error = 1;
		$error_message .= "\n  The input type $INPUT_TYPE you entered ";
		$error_message .= "only supports output type: flac";
	}
	if ( $b_error ){
		main::error_handler('unsupported-type',$error_message,0);
	}
	else {
		$b_valid_in_out = 1;
		if ( $LOG_LEVEL > 0 ) {
			print "Valid: $INPUT_TYPE(in) $OUTPUT_TYPE(out)\n";
		}
	}
}
sub check_src_dest_directories {
	my $missing_dirs = '';
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_large;
		print main::dotify("Checking source / destination directories");
	}
	if ( ! -d $SOURCE_DIRECTORY ){
		$b_error = 1;
		$missing_dirs .= "\n  Source Directory: $SOURCE_DIRECTORY";
	}
	if ( $b_check_dest && ! -d $DESTINATION_DIRECTORY ){
		$b_error = 1;
		$missing_dirs .= "\n  Destination Directory: $DESTINATION_DIRECTORY";
	}
	if ( $b_error ) {
		my $error_message = "The paths for the following directories are missing:";
		$error_message .= "$missing_dirs";
		$error_message .= "\nPlease check the directory paths you provided.";
		main::error_handler('dest-dir',$error_message,0);
	} 
	elsif ( $LOG_LEVEL > 0 ) {
		print "Directories: exist\n";
	}
	if ($b_check_dest && !$b_error && $DESTINATION_DIRECTORY eq $SOURCE_DIRECTORY){
		$error_message = "Destination directory cannot be same as Source directory!";
		main::error_handler('dest-eq-src-dir',$error_message,0);
	}
}
sub check_application_paths {
	my ($b_error,$error_message) = (0,'');
	my $app_paths = ''; 
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking required tools paths");
	}
	if ($b_check_out && $OUTPUT_TYPE eq 'flac') {
		$app_paths .= "$COMMAND_FFMPEG";
		if ( ! -x "$COMMAND_FFMPEG" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_FFMPEG";
		}
	}
	elsif ($b_check_out && ($OUTPUT_TYPE eq 'ogg' || $OUTPUT_TYPE eq 'opus' ) ) {
		if (!$run{'ffmpeg'}){
			if ($OUTPUT_TYPE eq 'ogg'){
				$app_paths .= "\n $COMMAND_OGG";
				if ( ! -x "$COMMAND_OGG" ) {
					$b_error = 1;
					$error_message .= "\n  Encoding application not available: $COMMAND_OGG";
				}
			}
			elsif ($OUTPUT_TYPE eq 'opus'){
				$app_paths .= "\n $COMMAND_OPUS";
				if (!$run{'ffmpeg'}){
					if ( ! -x "$COMMAND_OPUS" ) {
						$b_error = 1;
						$error_message .= "\n  Encoding application not available: $COMMAND_OPUS";
					}
				}
			}
		}
		else {
			$app_paths .= "\n $COMMAND_FFMPEG";
			if ( ! -x "$COMMAND_FFMPEG" ) {
				$b_error = 1;
				$error_message .= "\n  Encoding application not available: $COMMAND_FFMPEG";
			}
		}
	}
	elsif ($b_check_out && $OUTPUT_TYPE eq 'mp3' ) {
		$app_paths .= "\n $COMMAND_LAME ";
		if ( ! -x "$COMMAND_LAME" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_LAME";
		}
		$app_paths .= "$COMMAND_FLAC ";
		if ( ! -x "$COMMAND_FLAC" ) {
			$b_error = 1;
			$error_message .= "\n  Input processor $COMMAND_FLAC needed by lame ";
			$error_message .= "not available.";
		}
		$app_paths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_METAFLAC not found. Required to copy ";
			$error_message .= "ID3 tags from Flac to MP3.";
		}
	}
	elsif ($run{'checksum'} || $run{'checksum-verify'}){
		$app_paths .= "$COMMAND_MD5 ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_MD5" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_MD5 not found. Required to generate ";
			$error_message .= "md5 checksum files.";
		}
		if ($run{'checksum'}){
			$app_paths .= "$COMMAND_METAFLAC ";
			# Added: Odd @2011-03-23 01:55:28
			if ( ! -x "$COMMAND_METAFLAC" ) {
				$b_error = 1;
				$error_message .= "\n  $COMMAND_METAFLAC not found. Required to generate ";
				$error_message .= "ffp checksum files.";
			}
		}
		if ($run{'checsum-verify'}){
			$app_paths .= "$COMMAND_FLAC ";
			if (! -x "$COMMAND_FLAC"){
				$b_error = 1;
				$error_message .= "\n  $COMMAND_FLAC not found. Required to verify ";
				$error_message .= "$INPUT_TYPE files.";
			}
		}
	}
	elsif ($run{'autotag'}){
		$app_paths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_METAFLAC not found. Required to auto-tag ";
			$error_message .= "collection files.";
		}
	}
	if ( $b_error ) {
		main::error_handler('missing-app',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Available: $app_paths\n";
	}
}
sub check_quality{
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking quality support for $OUTPUT_TYPE");
	}
	## NOTE: this is not used
	if ( lc($OUTPUT_TYPE) eq 'flac') {
		if ($QUALITY_FLAC !~ m/^[0-8]$/ ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "0 to 8 quality levels. You entered: $QUALITY_FLAC";
		}
		else {
			$quality = $QUALITY_FLAC;
		}
	}
	if ( lc($OUTPUT_TYPE) eq 'ogg') {
		if ($QUALITY_OGG !~ m/^-?[0-9]+(\.[0-9]+)?$/ || 
		 $QUALITY_OGG < -1 || $QUALITY_OGG > 10 ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "-1 to 10 quality levels. You entered: $QUALITY_OGG";
		}
		else {
			$quality = $QUALITY_OGG;
		}
	}
	# supports fractional quality levels
	elsif ( lc($OUTPUT_TYPE) eq 'opus') {
		if ($QUALITY_OPUS !~ m/^[0-9]+$/ || $QUALITY_OPUS < 6|| $QUALITY_OPUS > 256 ){
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "6 to 256 bitrate quality levels. You entered: $QUALITY_OPUS";
		}
		else {
			$quality = $QUALITY_OPUS;
		}
	}
	elsif ( lc($OUTPUT_TYPE) eq 'mp3') {
		if ( $QUALITY_MP3 !~ m/^[0-9]$/ ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports 0-9 quality levels. ";
			$error_message .= "You entered: $QUALITY_MP3";
		}
		else {
			$quality = $QUALITY_MP3;
		}
	}
	if ( $b_error ) {
		main::error_handler('quality-invalid',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $quality ($OUTPUT_TYPE)\n";
	}
}
sub check_log_level {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking log/screen output level");
	}
	if ( $LOG_LEVEL !~ m/^([0-4])$/ ) {
		$b_error = 1;
		$error_message .= "\n  LOG_LEVEL only supports 0-4. ";
		$error_message .= "You used: $LOG_LEVEL";
	}
	if ( $b_error ) {
		main::error_handler('bad-level',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $LOG_LEVEL\n";
	}
}
sub check_nlink {
	my ($b_error,$error_message) = (0,'');
	if (defined $DONT_USE_NLINK && $DONT_USE_NLINK ne '0' ){
		if ( $LOG_LEVEL > 0 ) {
			print main::dotify("Checking DONT_USE_NLINK value");
		}
		if ( $DONT_USE_NLINK !~ m/^[01]$/ ) {
			$b_error = 1;
			$error_message .= "\n  DONT_USE_NLINK only supports 0-1. ";
			$error_message .= "You used: $DONT_USE_NLINK";
		}
		if ( $b_error ) {
			main::error_handler('bad-nlink',$error_message,0);
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "Supported: $DONT_USE_NLINK\n";
		}
	}
}
sub check_fork {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking FORK value");
	}
	if ( $FORK !~ m/^[0-9]+$/) {
		$b_error = 1;
		$error_message .= "\n  FORK requires value: 0 or more. ";
		$error_message .= "You used: $FORK";
	}
	if ( $b_error ) {
		main::error_handler('bad-fork',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $FORK\n";
	}
}
sub check_excludes {
	my ($b_error,$error_message) = (0,'');
	if ($EXCLUDE){
		if ( $LOG_LEVEL > 0 ) {
			print main::dotify("Checking EXCLUDE data");
		}
		if ( $EXCLUDE =~ /\Q$EXCLUDE_BASE\E/){
			if ( ! -e $EXCLUDE){
				$b_error = 1;
				$error_message .= "\n  You must provide a valid exclude file path. ";
				$error_message .= "You used: $EXCLUDE";
			}
		}
		else {
			if ($EXCLUDE =~ /\Q^^^^\E/ || $EXCLUDE =~ /\Q^^\E$/){
				$b_error = 1;
				$error_message .= "\n  You have an empty value in your EXCLUDE data. ";
				$error_message .= "You used: $EXCLUDE";
			}
		}
		if ( $b_error ) {
			main::error_handler('bad-exclude-file',$error_message,0);
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "Supported: $FORK\n";
		}
	}
}
# end Validation
}

#### -------------------------------------------------------------------
#### PRINT HELP/VERSION/MESSAGES
#### -------------------------------------------------------------------
sub print_completion_message {
	eval $print_line_heavy;
	if ( $b_dest_changed ) {
		if ( $LOG_LEVEL > 1 ) {
			print "All done updating. Enjoy your music!\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\nUpdating completed. Enjoy your music!\n";
		}
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "\nThere was nothing to update today in your collection.\n";
	}
	exit 0;
}

sub print_not_found {
	my ($message,$none);
	if ( $_[0] eq 'files'){
		$message = "No files to update of type: $extension\n";
		$none = "None to update";
	}
	elsif ( $_[0] eq 'extension'){
		$message = "No files found of type: $extension\n";
		$none = "None found";
	}
	elsif ($_[0] eq 'dirs') {
		$message = "No new directories required. Continuing...\n";
		$none = "None required";
	}
	elsif ($_[0] eq 'directory-cleaned') {
		$message = "No directories to remove. Continuing...\n";
		$none = "None to remove\n";
	}
	elsif ($_[0] eq 'file-cleaned') {
		$message = "No files to remove. Continuing...\n";
		$none = "None to remove\n";
	}
	if ( $LOG_LEVEL > 1 ) {
		print $message;
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print $none;
	}
}

sub print_help {
	# so it shows the user config data if present
	UserConfigs::set(); 
	# but this should override the config data so follows
	set_basic_data();
	my $output = "$SELF_NAME v: $SELF_VERSION :: Supported Options:\n";
	$output .= "Examples: $SELF_NAME -q 8 --destination /music/main/ogg\n";
	$output .= "$SELF_NAME --input flac --output ogg -a md5\n";
	$output .= "$SELF_NAME --copy doc,docx,bmp\n";
	$output .= $line_small;
	$output .= "Syncing options:\n";
	$output .= "--append, -a      Add extenssion type(s) to existing extension copy list.\n";
	$output .= "                  1 or more, comma separated, no spaces.\n";
	$output .= "--clean           Clean directories and files from destination not found in\n";
	$output .= "                  source music directory. Will show you directories/files to\n";
	$output .= "                  be deleted then ask you to confirm (twice) that you want to\n";
	$output .= "                  remove that set of files or directories. Exits at end.\n";
	$output .= "                  optional value 'sync' is used: --clean sync";
	$output .= "--copy, -c        List of alternate data types to copy to Output type\n";
	$output .= "                  directories. Comma separated, no spaces. See sample above.\n";
	$output .= "                  Current copy types: ";
	$output .= (length(join(' ',@extension_list))>40) ? "\n                  " : '';
	$output .= "@extension_list\n";
	$output .= "--destination, -d Path to the directory where you want the processed\n";
	$output .= "                  (eg, ogg) files to go.\n";
	$output .= "                  Current value: $DESTINATION_DIRECTORY\n";
	$output .= "--exclude, -x     Exclude a list of unique strings separated by ^^. Excludes\n";
	$output .= "                  sync/copy action to destination directory. Replaces\n";
	$output .= "                  \$EXCLUDE values if present. Anything matching in file path\n";
	$output .= "                  will be excluded. Can also be path to a file of excludes.\n";
	$output .= "                  Sample: --exclude='artwork^^Daisy Queen^^Bon Jovi'\n";
	$output .= "                  Sample: --exclude='/home/me/music/excludes/$EXCLUDE_BASE.txt\n";
	$output .= "--exclude-append, -X\n";
	$output .= "                  Append an item to the list of excludes or file.\n";
	$output .= "                  Sample: --exclude-append='My Sharona^^Dancing Queen'\n";
	$output .= "--ffmpeg          Force flac to ogg/opus conversions to use ffmpeg. Useful if\n";
	$output .= "                  you want to include embedded images to oggs (Experimental).\n";
	$output .= "--force, -f       Force overwrite the mp3/ogg/opus/jpg/txt/etc. files, even\n"; 
	$output .= "                  if they already exist.\n";
	$output .= "--fork, -F        [0-x] - Number of forks/threads to use. 0 default, disables.\n";
	$output .= "                  Requires Perl module: Parallel::ForkManager. Current: $FORK\n";
	$output .= "--input, -i       Input type: flac, wav, raw, shn. shn requires codec shorten. \n";
	$output .= "                  raw, shn only output to flac.\n";
	$output .= "                  Current value: $INPUT_TYPE\n";
	$output .= "--output, -o      Output type: mp3, ogg, opus. mp3 requires input type flac.\n";
	$output .= "                  Current value: $OUTPUT_TYPE\n";
	$output .= "--quality n, -q n flac: n between 0 and 8. 8 best, but > 4 generally pointless.\n";
	$output .= "                  ogg: n between -1 and 10. Fractions ok. 10 best quality.\n";
	$output .= "                  opus: n between 6-256. Variable bit rate. 256 best quality.\n";
	$output .= "                  mp3: n between 0-9. Variable bit rate, 0 best quality.\n";
	$output .= "                  Current values: $QUALITY_MP3 (mp3); $QUALITY_OGG (ogg); $QUALITY_OPUS (opus)\n";
	$output .= "--source, -s      Path to the top-most directory containing your source files.\n";
	$output .= "                  Current value: $SOURCE_DIRECTORY\n";
	$output .= $line_small;
	$output .= "Specialized options:\n";
	$output .= "--aggregate, -G   [filename|extension] Copy file name or extension type to\n";
	$output .= "                  --destination directory. If no argument given, copies over\n";
	$output .= "                  $TAG_FILE. Do not use . in extension (jpg good, .jpg bad)\n";
	$output .= "                  You can supply more than one filename or extension:\n";
	$output .= "                  (file name): acxi -d ~/music/cdinfo --aggregate info.txt\n";
	$output .= "                  (extension): acxi -d ~/music/cdinfo --aggregate jpg\n";
	$output .= "                  (several): acxi -d ~/music/cdinfo --aggregate png,jpg,info.txt\n";
	$output .= "--autotag, -A     Requires auto.tag formatted file in each directory. Flac only.\n";
	$output .= "                  Deletes all existing tags, then creates a fully tagged set of\n";
	$output .= "                  files.\n";
	$output .= "--autotag-create, -C\n";
	$output .= "                  Create $TAG_FILE template in source directory. Will be\n";
	$output .= "                  populated with file names for recording filled in already in\n";
	$output .= "                  track listing. Preserves existing REPLAYGAIN values.\n";
	$output .= "--autotag-create-multi, -M [disc ID]\n";
	$output .= "                  Required argument tells logic how to determine your disc\n";
	$output .= "                  numbering method. % is used to indicate the value is a number\n";
	$output .= "                  between 1-9. @ is used to indicate a letter between A-Z. \n";
	$output .= "                  Will complete TRACKTOTAL, DISCNUMBER, TRACKNUMBER values\n";
	$output .= "                  in auto.tag file, which saves a time.\n";
	$output .= "                  Samples: -M d% [d1track02.flac]; -M d%- [d2-track04.flac];\n";
	$output .= "                  -M % [112.flac]; -M 2015-03-21.d%. [2015-03-21.d1.track03.flac]\n";
	$output .= "                  -M @ [A12.flac]; -M d@- [da-track02.flac];\n";
	$output .= "                  Flac input type only.\n";
	$output .= "--autotag-create-single, -S\n";
	$output .= "                  For single disc recordings, will also add TRACKTOTAL and\n";
	$output .= "                  TRACKNUMBER counts when creating and populating the\n";
	$output .= "                  $TAG_FILE file.\n";
	$output .= "--checksum, -K    Create .ffp and .md5 checksum files in your source directory.\n";
	$output .= "                  Checksum files are only created inside directories where flac\n";
	$output .= "                  files are found. Use --checksum-delete if you also want\n";
	$output .= "                  to delete existing checksum files. Only flac type\n";
	$output .= "                  is supported.\n";
	$output .= "                  Do not use together with cleaning/syncing options!\n";
	$output .= "--checksum-delete, -D\n";
	$output .= "                  Delete all existing .ffp, .md5, .ffp.txt, and md5.txt files\n";
	$output .= "                  before creating the new checksum files. Files only deleted in\n";
	$output .= "                  directories where flac files are found.\n";
	$output .= "--checksum-verify, -V\n";
	$output .= "                  Verifies FLAC files and confirms MD5 file data matches actual\n";
	$output .= "                  files found. Can be run alone or with --checksum options.\n";
	$output .= "--nlink           Set \$File::Find::dont_use_nlink = 0. Expert use only.\n";
	$output .= "--no-nlink        Set \$File::Find::dont_use_nlink = 1 [default].\n";
	$output .= "                  Expert use only.\n";
	$output .= "--no-ffp          Skips ffp processing on --checksum or --checksum-verify.\n";        
	$output .= "--no-replaygain   Does not preserve REPLAYGAIN values for autotag-create.\n";
	$output .= "--remove-images   Remove all embedded images and image padding from file\n";
	$output .= "                  before autotagging.\n";
	if ($ALLOW_UPDATES){
		$output .= "--update, -U      Update $SELF_NAME and man page. Set paths if not Linux.\n";
		$output .= "                  Current values: $SELF_NAME: $SELF_DIRECTORY\n";
		$output .= "                  man $SELF_NAME.1: $MAN_DIRECTORY\n";
	}
	$output .= $line_small;
	$output .= "Display output and debugging options:\n";
	$output .= "--basic           Basic single line per operation screen output, default value.\n";
	$output .= "                  Same as --log 1\n";
	$output .= "--full            Full screen output, including full verbosity of \n";
	$output .= "                  flac/lame/oggenc/opusenc conversion process for mp3, ogg,\n";
	$output .= "                  or opus output. Same as --log 3\n";
	$output .= "--debug           Trigger advanced output debugging data. Same as --log 4\n";
	$output .= "--help, -h        This help menu.\n";
	$output .= "--log             [0-4] Dynamically set LOG_LEVEL. Current value: $LOG_LEVEL\n";
	$output .= "--quiet           Turns off all screen output, except for error messages.\n";
	$output .= "                  Same as --log 0\n";
	$output .= "--test            Test copy, sync, autotag, checksum without actually doing \n";
	$output .= "                  the action. Also activates --full for more verbose outputs.\n";
	$output .= "--verbose         Without full verbosity of full, no flac/lame/oggenc/opusenc\n";
	$output .= "                  for conversion process screen output. More verbose than\n";
	$output .= "                  --basic. Same as --log 2\n";
	$output .= "--version, -v     Show $SELF_NAME version.\n";
	$output .= $line_small;
	$output .= "User Configs ";
	if (!$CONFIG_DIRECTORY){
		$output .= "(checked in this order):\n/etc/$SELF_NAME.conf\n";
		$output .= "\$XDG_CONFIG_HOME/$SELF_NAME.conf\n";
		$output .= "\$HOME/.config/$SELF_NAME.conf\n";
		$output .= "\$HOME/.$SELF_NAME.conf\n";
	}
	else {
		$output .= "(manually set):\n$CONFIG_DIRECTORY/$SELF_NAME.conf\n";
	}
	$output .= "Requires this syntax (any user modifiable variable can be used)\n";
	$output .= "SOURCE_DIRECTORY=/home/me/music/flac\n";
	$output .= "DESTINATION_DIRECTORY=/home/me/music/ogg\n";
	$output .= "Do not use \$, \", or \' in config options or values (except in path names).\n";
	$output .= "\n";
	print $output;
	exit 0;
}

sub print_version {
	print "$SELF_NAME version: $SELF_VERSION ($SELF_DATE)\n";
	exit 0;
}

#### -------------------------------------------------------------------
#### SET RUNTIME VALUES
#### -------------------------------------------------------------------
sub set_basic_data {
	# if --copy/-c is set, then use that data instead of default copy types
	if ( defined $COPY_TYPES ){
		@extension_list = split( /,\s*/, $COPY_TYPES );
	}
	$DESTINATION_DIRECTORY =~ s|/$||;
	$SOURCE_DIRECTORY =~ s|/$||;
	$CONFIG_DIRECTORY =~ s|/$|| if $CONFIG_DIRECTORY;
	$INPUT_TYPE = lc($INPUT_TYPE) if $INPUT_TYPE;
	$OUTPUT_TYPE = lc($OUTPUT_TYPE) if $OUTPUT_TYPE;
	@extension_list = (@extension_list,$INPUT_TYPE);
	$File::Find::dont_use_nlink = $DONT_USE_NLINK;
	# note: tests show fork == 1 slower than no forking!!
	if ( $FORK > 0 ){
		if (!check_module('Parallel::ForkManager')){
			error_handler('missing-perl-module', 'Parallel::ForkManager',1);
		}
		else {
			import Parallel::ForkManager;
			$b_fork = 1;
		}
	}
	if ($EXCLUDE){
		if ($EXCLUDE =~ /\Q$EXCLUDE_BASE\E/){
			@excludes = reader($EXCLUDE, 'strip');
		}
		else {
			@excludes = split /\Q^^\E/, $EXCLUDE;
		}
		if ($exclude_append){
			my @temp = split /\Q^^\E/, $exclude_append;
			@excludes = (@excludes,@temp);
		}
		# print Data::Dumper::Dumper \@excludes, "\n";
	}
}

sub set_display_data {
	if ( $LOG_LEVEL < 3 ) {
		if ( $OUTPUT_TYPE eq 'mp3' ) {
			$silent_flac = '--silent'; # flac output 
			$silent_lame = '--silent'; # lame output
		}
		elsif ( !$run{'ffmpeg'} && $OUTPUT_TYPE eq 'ogg' ) {
			$silent_flac = '--quiet'; # for oggenc output
		}
		elsif ( ($run{'ffmpeg'} && $OUTPUT_TYPE =~ /^(ogg)$/ ) || $OUTPUT_TYPE eq 'flac' ) {
			# -nostats -loglevel 0
			# -hide_banner -loglevel panic
			# -v quiet
			$silent_ffmpeg = '-hide_banner -loglevel panic'; # 
		}
		elsif ( $OUTPUT_TYPE eq 'opus' ) {
			$silent_opus = '--quiet'; # for oggenc output
		}
	}
	if ( $LOG_LEVEL < 2 ) {
		$print_line_heavy = '';
		$print_line_large = '';
		$print_line_small = '';
	}
	else {
		$print_line_heavy = 'print $line_heavy';
		$print_line_large = 'print $line_large';
		$print_line_small = 'print $line_small';
	}
}

# get defaults from user config files if present
## Package UserConfigs
{
package UserConfigs;

sub set {
	my (@config_files,$file,$user_config);
	# set list of supported config files
	@config_files = ("/etc/$SELF_NAME.conf");
	if ($ENV{'XDG_CONFIG_HOME'} && -r "$ENV{XDG_CONFIG_HOME}/$SELF_NAME.conf"){
		$user_config = "$ENV{'XDG_CONFIG_HOME'}/$SELF_NAME.conf";
	}
	elsif ( -r "$ENV{HOME}/.config/$SELF_NAME.conf"){
		$user_config = "$ENV{HOME}/.config/$SELF_NAME.conf";
	}
	elsif (-r "$ENV{HOME}/.$SELF_NAME.conf"){
		$user_config = "$ENV{HOME}/.$SELF_NAME.conf";
	}
	elsif (-r "$CONFIG_DIRECTORY/$SELF_NAME.conf"){
		$user_config = "$CONFIG_DIRECTORY/$SELF_NAME.conf";
	}
	@config_files = (@config_files,$user_config) if $user_config;
	foreach $file (@config_files) {
		next unless -r $file && open (my $fh,'<',$file);
		while (<$fh>) {
			chomp;                  # no newline
			s/#.*//;                # no comments
			s/^\s+//;               # no leading white
			s/\s+$//;               # no trailing white
			s/('|"|\$|\s)//g;       # get rid of all non valid characters
			next unless length;     # anything left?
			my ($var, $value) = split(/\s*=\s*/, $_, 2);
			if (defined $var && defined $value){
				assign_value($var, $value);
			}
		}
	}
}
sub assign_value {
	my ($var,$value) = @_;
	if ($var eq 'COMMAND_CURL'){$COMMAND_CURL = $value;}
	elsif ($var eq 'COMMAND_FLAC'){$COMMAND_FLAC = $value;}
	elsif ($var eq 'COMMAND_FFMPEG'){$COMMAND_FFMPEG = $value;}
	elsif ($var eq 'COMMAND_LAME'){$COMMAND_LAME = $value;}
	elsif ($var eq 'COMMAND_METAFAC'){$COMMAND_METAFLAC = $value;}
	elsif ($var eq 'COMMAND_OGG'){$COMMAND_OGG = $value;}
	elsif ($var eq 'COMMAND_OPUS'){$COMMAND_OPUS = $value;}
	elsif ($var eq 'CLEAN'){
		$value =~ s/^(yes|1|true|enable|on)$/1/;
		$value =~ s/^(no|0|false|disable|off)$/0/;
		if ($value =~ /^[10]$/){
			$run{'clean'} = $value;
			$run{'clean-sync'} = $value;
		}}
	elsif ($var eq 'CLEAN_INCLUDE_LINKS'){
		$value =~ s/^(yes|1|true|enable|on)$/1/;
		$value =~ s/^(no|0|false|disable|off)$/0/;
		$CLEAN_INCLUDE_LINKS = $value if $value =~ /^[10]$/;
	}
	elsif ($var eq 'SOURCE_DIRECTORY' || $var eq 'DIR_PREFIX_SOURCE'){
		$SOURCE_DIRECTORY = $value;}
	elsif ($var eq 'DESTINATION_DIRECTORY' || $var eq 'DIR_PREFIX_DEST'){
		$DESTINATION_DIRECTORY = $value;}
	elsif ($var eq 'MAN_DIRECTORY'){$MAN_DIRECTORY = $value}
	elsif ($var eq 'SELF_DIRECTORY'){$SELF_DIRECTORY = $value}
	elsif ($var eq 'INPUT_TYPE'){$INPUT_TYPE = $value;}
	elsif ($var eq 'LOG_LEVEL'){$LOG_LEVEL = $value;}
	elsif ($var eq 'OUTPUT_TYPE'){$OUTPUT_TYPE = $value;}
	# legacy configs, sets both
	elsif ($var eq 'QUALITY'){$QUALITY_OGG = $value;$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_FLAC'){$QUALITY_FLAC = $value}
	elsif ($var eq 'QUALITY_MP3'){$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_OGG'){$QUALITY_OGG = $value;}
	elsif ($var eq 'QUALITY_OPUS'){$QUALITY_OPUS = $value;}
	elsif ($var eq 'COPY_TYPES' || $var eq 'USER_TYPES'){
		$COPY_TYPES = $value;}
	elsif ($var eq 'DONT_USE_NLINK'){$DONT_USE_NLINK = $value}
	elsif ($var eq 'FORK'){$FORK = $value}
	elsif ($var eq 'FFP_FILE'){$FFP_FILE = $value}
	elsif ($var eq 'MD5_FILE'){$MD5_FILE = $value}
	elsif ($var eq 'TAG_FILE'){$TAG_FILE = $value}
	elsif ($var eq 'EXCLUDE'){$EXCLUDE = $value}
	elsif ($var eq 'EXCLUDE_BASE'){$EXCLUDE_BASE = $value}
}
# end ConfigData
}

# Get Options and set values, this overrides defaults 
# from top globals and config files
sub get_options{
	my (@args) = @_;
	my ($msg);
	GetOptions (
	"G|aggregate:s" => sub { 
		my ($opt,$arg) = @_;
		$b_check_out = 0;
		if ( $arg ){
			if ($arg eq 'file'){
				$run{'aggregate-file'} = 1;
				$arg = $TAG_FILE;
			}
			$run{'ag-file'} = $arg;
		}
		else {
			$run{'ag-file'} = $TAG_FILE;
		}
		$run{'autotag-aggregate'} = 1;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
	},
	"a|append:s" => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES .= ',' . $arg if $arg;},
	"A|autotag" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"C|autotag-create" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag-create'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"M|autotag-create-multi:s" => sub { 
		my ($opt,$arg) = @_;
		if (!$arg || $arg !~ /%|@/){
			$msg = "$opt requires multidisk file name identifier. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$autotag_multi = $arg;
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag-create'} = 1;
		$run{'autotag-multi'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"S|autotag-create-single" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag-create'} = 1;
		$run{'autotag-single'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"basic|default" => sub { 
		$LOG_LEVEL = 1 },
	"K|checksum" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 1;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"D|checksum-delete" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 1;
		$run{'checksum-delete'} = 1; 
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'V|checksum-verify' => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum-verify'} = 1;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"clean:s" => sub { 
		my ($opt,$arg) = @_;
		$run{'clean-sync'} = 1 if $arg && $arg eq 'sync';
		$run{'clean'} = 1 },
	"clean-include-links" => sub { 
		$CLEAN_INCLUDE_LINKS = 1 },
	"clean-exclude-links" => sub { 
		$CLEAN_INCLUDE_LINKS = 0 },
	# accepts null value so users can not copy anything
	"c|copy:s" => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES = $arg;},
	"debug" => sub { 
		$LOG_LEVEL = 4},
	"d|destination:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$DESTINATION_DIRECTORY = $arg },
	"x|exclude:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires exclude list or file.",1) if ! $arg;
		$arg = '' if $arg eq 'unset';
		$EXCLUDE = $arg },
	"exclude-append:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires exclude list.",1) if ! $arg;
		$exclude_append = $arg },
	"f|force" => sub { 
		$b_force = 1 },
	"ffmpeg" => sub { 
		$run{'ffmpeg'} = 1 },
	"F|fork:i" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires fork count integer.",1) if not defined $arg;
		$FORK = $arg; },
	"full" => sub { 
		$LOG_LEVEL = 3 },
	"h|help|?" => sub { 
		print_help();},
	"i|input:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$INPUT_TYPE = $arg },
	"log:i" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt log level integer.",1) if not defined $arg;
		$LOG_LEVEL = $arg; },
	"o|output:s" => sub {
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$OUTPUT_TYPE = $arg;},
	"nlink" => sub { 
		$DONT_USE_NLINK = 0 },
	"no-ffp" => sub { 
		$run{'no-ffp'} = 1 },
	"no-nlink" => sub { 
		$DONT_USE_NLINK = 1 },
	"no-replaygain" => sub { 
		$run{'no-replaygain'} = 1 },
	"q|quality:f" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires number.",1) if ! defined $arg || $arg !~ /^-?[0-9\.]+$/;
		# validate these later
		$QUALITY_FLAC = $arg;
		$QUALITY_MP3 = $arg;
		$QUALITY_OGG = $arg;
		$QUALITY_OPUS = $arg;}, 
	"s|source:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$SOURCE_DIRECTORY = $arg;},
	"quiet|silent" => sub { 
		$b_quiet = 1; 
		$LOG_LEVEL = 0 },
	"remove-images" => sub { 
		$run{'remove-images'} = 1 },
	"test" => sub { 
		$LOG_LEVEL = 3;
		$b_test = 1 },
	'U|update'=> sub { 
		$run{'update'} = 1; 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 0;
		$run{'checksum-delete'} = 0; 
		$run{'checksum-verify'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';},
	"verbose" => sub { 
		$LOG_LEVEL = 2 },
	"v|version" => sub { 
		print_version(); },
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unsupported-option', "Unsupported option: $opt",1); }
	);
	if (($run{'checksum'} || $run{'checksum-verify'}) && ($run{'sync'} || 
	 $run{'clean'} || $run{'autotag-create'} || $run{'autotag-aggregate'})){
		error_handler('invalid-options', 
		 "You cannot use --checksum with any clean, sync, or autotag options.",1);
	}
	if ($run{'autotag'} && ($run{'sync'} || $run{'clean'} || 
	 $run{'autotag-aggregate'} || $run{'autotag-create'})){
		error_handler('invalid-options', 
		 "You cannot use --autotag with autotag-generate, clean, or sync options.",1);
	}
	if ($run{'autotag-create'} && ($run{'sync'} || $run{'clean'} || 
	 $run{'checksum'} || $run{'checksum-verify'} || $run{'autotag'})){
		error_handler('invalid-options', 
		 "You cannot use --autotag-generate with autotag, clean, sync, or checksum options.",1);
	}
	if (!$run{'sync'} && $run{'ffmpeg'}){
		error_handler('invalid-options', 
		 "You can only use --ffmpeg with sync operations.",1);
	}
}

#########################################################################
### EXECUTE / PROCESS MUSIC ###
#########################################################################

main();

###**EOF**###
