#!/usr/bin/env perl
#########################################################################
# acxi - audio conversion program
#########################################################################

# Copyright (c) 2010-2021 - Harald Hope - smxi.org 
# Home page: https://github.com/smxi/acxi
# Forum support: https://techpatterns.com/forums/about1491.html
# Download url: https://smxi.org/acxi
#
# Based on flac2ogg.pl
# Copyright (c) 2004 - Jason L. Buberel - jason@buberel.org
# Copyright (c) 2007 - Evan Boggs - etboggs@indiana.edu
# Previous Home page (gone now): 
#   http://www.buberel.org/linux/batch-flac-to-ogg-converter.php
#
# Modified: 2018-12-05 - Cleaned up code, refactored
# Modified: 2011-07-26 - Harald Hope - Added patch for $ in file names; 
#   changed verbosity levels to fit future 3 release, got rid of 
#   $B_SILENT and $b_quiet
# Modified: 2011-03-23 - Odd Eivind Ebbesen - www.oddware.net - 
#   <oddebb at gmail dot com>
#   Added functionality for Flac conversion to MP3, preserving tags.
#########################################################################
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 3 of the License, or 
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
#
# Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
#########################################################################
# Given a source directory tree of original lossless music files 
# (flac, wav, etc), this program will recreate (or add to) a new 
# directory tree of ogg/mp3 files by recursively encoding only new 
# source files to destination types.
# The source and destination directories can be hard-coded using the 
# $SOURCE_DIRECTORY and $DESTINATION_DIRECTORY variables, or passed on 
# the command line, or can be set in the configuration file (recommended).  
#
# See USER MODIFIABLE VALUES for configuration information.

#########################################################################
### NO USER CHANGES IN THIS SECTION ###
#########################################################################
use strict;
use warnings;
# use diagnostics;
use 5.010;
use feature 'state';
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
use File::Basename;
use File::stat;
use File::Find;
use File::Copy qw(copy);
use File::Glob qw(:bsd_glob);
use File::Path qw(rmtree make_path);
use Cwd qw(getcwd);
use Data::Dumper;
# use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
# use feature 'unicode_strings';
# use open qw(:std :utf8); # don't use
# only use for debugging, some distros do not ship with core modules.
# use Data::Dumper qw(Dumper);
## if can't find any other way to get rid of lost+found errors, enable this:
# no warnings 'File::Find';

#### -------------------------------------------------------------------
#### PROGRAM GLOBALS - DO NOT TOUCH THESE!
#### -------------------------------------------------------------------

## SELF INFO ##
my $self_name='acxi';
my $self_version='3.4.01';
my $self_date='2021-09-22';

## GLOBALS ##
my %run;
$run{'sync'} = 1;
my ($b_debug,$b_dest_changed,$b_force,$b_fork,$b_quiet,$b_test);
my ($print_line_heavy,$print_line_large,$print_line_small);
my ($quality,$autotag_multi,$silent_flac,$silent_ffmpeg,$silent_lame,
$silent_opus) = (7,'','','','','');
my ($codec,$embed_image,$extension,$exclude_append,@excludes,@excludes_stripped,
@extension_list,@found_list,$list_type,@source_glob,@tags,$start_dir);
# default: recurse infinite for File::Find; start tag list track numbers at 1
my ($padding,$recurse,$start) = ('',-1,1);
my ($b_check_dest,$b_check_out) = (1,1);
my $b_win = ($^O =~ /win/i) ? 1 : 0; # detect if $^O returns windows 
my $path_separator = ($b_win) ? '\\' : '/';
## CONSTANTS ##
my $line_heavy = "===========================================================================";
my $line_small = "-----------------------------------------------------------------";
my $line_large = "---------------------------------------------------------------------------";

#########################################################################
### USER MODIFIABLE VALUES ###
#########################################################################
# User config file at:
# Global: /etc/acxi.conf
# User override files checked in the following order (first found used):
# $XDG_CONFIG_HOME/acxi.conf, $HOME/.config/acxi.conf, $HOME/.acxi.conf
#
# Set values like this:
# Do not use the $ preceding the variable name, or the semicolon or 
# single/double quote marks in the config file. Use this syntax for 
# config files:
# SOURCE_DIRECTORY=/home/fred/music/flac
# DESTINATION_DIRECTORY=/home/fred/music/ogg
#
# It's highly recommended to create a config file so you don't have to
# update the values below every time acxi updates.
#
# Anything in configs or in this section will be overridden if you use
# a startup argument.
#### -------------------------------------------------------------------
#### CUSTOM CONFIGURATION FILE LOCATION
#### -------------------------------------------------------------------
# NOTE: only use this if you are running Windows, or any OS without $HOME
# or $XDG_CONFIG_HOME environmental variables. acxi will look for file:
# acxi.conf inside that directory. 
my $CONFIG_DIRECTORY='';

#### -------------------------------------------------------------------
#### APPLICATION PATHS
#### -------------------------------------------------------------------
my $COMMAND_FLAC = '/usr/bin/flac'; 
my $COMMAND_FFMPEG = '/usr/bin/ffmpeg';
my $COMMAND_LAME = '/usr/bin/lame';
my $COMMAND_OGG = '/usr/bin/oggenc';
my $COMMAND_OPUS = '/usr/bin/opusenc';
# If you are not generating checksums, you do not need this.
my $COMMAND_MD5 = '/usr/bin/md5sum';
# metaflac is required for flac to mp3, to copy over the ID3 tags, or
# for ffp checksum generator.
# If you are not doing either, you don't need this.
my $COMMAND_METAFLAC = '/usr/bin/metaflac';

#### -------------------------------------------------------------------
#### ASSIGN DIRECTORY PATHS
#### -------------------------------------------------------------------
# Options: -s/--source path -d/--destination path
# $SOURCE_DIRECTORY is the original, working, like flac, wav, etc
# $DESTINATION_DIRECTORY is the processed, ie, ogg, mp3
# CHANGE TO FIT YOUR SYSTEM - do not end in /
# IMPORTANT: DESTINATION_DIRECTORY cannot be equal to SOURCE_DIRECTORY
my $SOURCE_DIRECTORY = '/path/to/source/directory';
my $DESTINATION_DIRECTORY = '/path/to/your/output/directory';

#### -------------------------------------------------------------------
#### EXCLUDES
#### -------------------------------------------------------------------
# this is the unique part of the exclude file name, not including the 
# .txt. All exclude file names used must contain this string value.
my $EXCLUDE_BASE = 'acxi-exclude';

# Option: --exclude 
# Takes a ^^ separated list of key words which will match terms in 
# your source directory you do not want synced or copied over to 
# destination. Separate items with ^^. Will match the entire path 
# so be aware. Note you can exclude directory names like artwork too.
# Sample: $EXCLUDE = 'millivanilli^^bonjovi^^artwork';
# Can also use a file with one exclude item per line. File name 
# must include the 'acxi-excludes' in it or it won't be used.
# you can use various excluldes to create various collections.
# Sample: $EXCLUDE = '/home/me/music/excludes/acxi-excludes-phone.txt';
my $EXCLUDE = '';

#### -------------------------------------------------------------------
#### INPUT/OUTPUT
#### -------------------------------------------------------------------
# Options: -i/--input type ; -o/--output type
# The following are NOT case sensitive,ie flac/FLAC, txt/TXT will be 
# found. INPUT_TYPE and OUTPUT_TYPE will be forced to lower case 
# internally.
my $INPUT_TYPE = 'flac';
my $OUTPUT_TYPE = 'ogg';

# Option: -q/--quality number
# for flac: n can be 0-8. 0 produces largest file, is fastest, anything over 4
# is probably pointless since compression gain is very little vs time required.
# For mp3: n can be 0-9 (variable bit rate), 0 is largest file / highest quality
# For ogg: n can be between -1 and 10. Fractions allowed. 10 is the largest file 
# size / highest quality. 
# For opus: n can be 6-256. 256 is the largest file size / highest quality / 
# maximum bitrate. For flac 0-8 [0 biggest size, fastest], set to 4 because
# there is almost no size decrease with flac 5-8 but big cpu time increase.
my $QUALITY_AAC = 160;
my $QUALITY_FLAC = 4;
my $QUALITY_MP3 = 3;
my $QUALITY_OGG = 7;
my $QUALITY_OPUS = 144; # 128 claimed to be stereo transparent, 160 very good

# Frauenhofer codec considered best, but ffmeg native 'aac' will usually be 
# there.
my $CODEC_AAC = 'libfdk_aac';

# Option: -c/--copy and -a/--append (to append extension types to existing list.
## NOTE: if you want to override $COPY_TYPES in your config files, you
# must use this syntax:
# COPY_TYPES=doc,docx,bmp,png,doc,docx,jpg,jpeg,tif
# Add or remove types to copy over to ogg directories, do not include
# the input/output audio file types, only extra data types like txt.
# If you want no copying done, simply change to: $COPY_TYPES = 'none';
my $COPY_TYPES = 'gif,jpg,jpeg,png,txt';

#### -------------------------------------------------------------------
#### AUTO TAGGING
#### -------------------------------------------------------------------
# For -P/--prefill, can be overridden with config or --prefill-file []
my $INFO_FILE='info.txt';
# For -Xf, the rating shown in Quality: /[rating] item.
my $INFO_RATING = 4;
# This is the file that contains the syntax found in auto.tag file. But
# you can call it something else if you prefer.
my $TAG_FILE='auto.tag';

#### -------------------------------------------------------------------
#### CHECKSUM DATA
#### -------------------------------------------------------------------
# These are the file names MINUS the .ffp / .md5 extensions.
my $FFP_FILE='fingerprints';
my $MD5_FILE='md5sums';

#### -------------------------------------------------------------------
#### VERBOSITY LEVELS
#### -------------------------------------------------------------------
# Options: --quiet/--debug/-v, --verbosity 0-4
# You can turn these to always on either here or in config file by setting to 
# desired verbosity level here directly, or in config file. 
# 0 = [quiet/silent] - no output at all. File issue if something shows output.
# 1 = default - single line per operation. This is the default, so you don't
#     need to change it.
# 2 = more verbose, but without the actual conversion data from codecs
# 3 = adds codec conversion information.
# 4 = [debug] - adds specific debugger information. Certain debugger output may
# not work in Windows, but you rarely if ever need to see this level.
# NOTE: with FORK > 1, conversion debugging output can be out of order.
my $VERBOSITY = 1;

#### -------------------------------------------------------------------
#### ADVANCED
#### -------------------------------------------------------------------
# Options: --nlink --no-nlink
# Only change to 0 if you encounter file tree failures. This is for File::Find
# values:  0 - use nlink; 1 - don't use nlink [default, only change if you know
# why.
my $DONT_USE_NLINK = 1;

# Option: -F/--fork 0-xx
## number of forks/threads to use. 0 is default, and will not use forking
# note that debugging output gets strange with forking, so debug with fork = 0
# FORK = 1 results in slower times than using no forking so avoid that. 
my $FORK = 0;

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------

# Only for maintainers, set to 0 in config file to disable.
my $ALLOW_UPDATES = 1;

# this will be used to update the program and man page. You must have 
# write permissions to the file locations. Linux or BSD only.
# do not end paths with /
my $COMMAND_CURL='/usr/bin/curl';
my $MAN_DIRECTORY='/usr/local/share/man/man1';
my $SELF_DIRECTORY='/usr/local/bin';

#########################################################################
### END USER MODIFIABLE VALUES ###
#########################################################################

########################################################################
#### STARTUP
########################################################################

sub main {
	UserConfigs::set();
	get_options();
	set_display_data();
	SelfUpdater::update() if $run{'update'};
	Validation::run();
	set_basic_data();
	Aggregate::run() if $run{'aggregate'};
	AutoTag::create() if $run{'autotag-create'};
	AutoTag::run_tagger() if $run{'autotag'};
	Checksums::process() if ($run{'checksum'} || $run{'checksum-verify'});
	CleanCollection::process() if $run{'clean'};
	InfoFix::process() if $run{'infofix'};
	SyncCollection::process() if $run{'sync'};
	print_completion_message();
}

#########################################################################
### CLEAN/SYNC MUSIC DIRECTORIES ###-
#########################################################################

#### -------------------------------------------------------------------
#### AGGREGATE
#### -------------------------------------------------------------------

## Aggregate
{
package Aggregate;
sub run {
	say $line_large;
	say 'Starting file aggregation from: ' . main::sourcer($SOURCE_DIRECTORY);
	say ' to: ' . main::sourcer($DESTINATION_DIRECTORY);
	my @files = split /,/, $run{'ag-file'};
	# my $abs_path = Cwd::abs_path($SOURCE_DIRECTORY);
	# chdir Cwd::getcwd(); # $SOURCE_DIRECTORY;
	chdir $start_dir;
	foreach (@files){
		aggregate($_);
	}
	say $line_small;
	say 'Completed file aggregation.';
	say $line_large;
	exit;
}
sub aggregate {
	($extension) = @_;
	my ($path,@files);
	my ($dir,$file,$file_working,$name);
	$list_type = 'file';
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	say $line_small;
	say "Aggregating file type $extension...";
	say $line_small;
	foreach $file (sort { "\L$a" cmp "\L$b" } @found_list){
		$b_dest_changed = 1;
		$file_working = $file;
		$file_working =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		$dir = File::Basename::dirname($file_working);
		$name = File::Basename::basename($file_working);
		if ($run{'aggregate-file'}){
			$path = $DESTINATION_DIRECTORY . $path_separator . $dir . '.' . $name;
		}
		else {
			$path = $DESTINATION_DIRECTORY . $path_separator . $dir;
			if (! -d $path){
				File::Path::make_path($path) or die qq("Arg... can't make: $path\n") if !$b_test;
			}
			$path .= $path_separator . $name;
			# say 'path: ', $path;
		}
		say $file_working;
		say $file if $b_debug;
		File::Copy::copy($file, $path) if !$b_test;
		push @files, $file;
		$path = '';
	}
	if (!@found_list){
		say "No $extension type files found.";
	}
	say $line_small;
	# say Data::Dumper::Dumper \@files;
	say "Finished copying over $extension type files to " . main::sourcer("$DESTINATION_DIRECTORY");
}
}

#### -------------------------------------------------------------------
#### ANALYZE
#### -------------------------------------------------------------------

## Analyze
{
package Analyze;
my ($avg_kbs,$total_size,$total_size_raw,$total_time) = (0,0,0,0);
my ($flac_info) = ('');
my ($type,$ref,@files,@info,%results);
sub run {
	($type,$ref) = @_;
	my $dir = Cwd::getcwd; # resolves sym links
	# the caller has looped into directory with info file and flacs
	if ($type eq 'info'){
		@files = main::globber('*.flac');
	}
	# the caller is generating the flac list and passing it in here
	else {
		@files = @$ref;
	}
	if (!@files){
		main::error_handler('analyze',"No flac files found for quality test!\n",1);
	}
	else {
		undef(%results);
		undef(@info);
		($avg_kbs,$total_size,$total_size_raw,$total_time) = (0,0,0,0);
		($flac_info) = ('');
		process();
		if ($type eq 'info'){
			return info_data(); # returns updated INFO_FILE page contents array
		}
		else {
			generate_output(); # print output to screen
		}
	}
}
sub process {
	foreach my $flac_file (@files){
		# say "Getting metaflac for file: $flac_file";
		my @real;
		my $escaped = main::escape_item("$flac_file");
		my @flac = qx($COMMAND_METAFLAC --show-channels --show-sample-rate --show-bps --show-total-samples --show-md5sum "$escaped");
		if (scalar @flac != 5){
			main::error_handler('analyze',"Metaflac failed to get 4 items from file:\n '$flac_file'",0);
		}
		foreach (@flac){
			$_ =~ s/[\r\n]//g;
			push(@real,$_);
		}
		# say Data::Dumper::Dumper \@flac;
		if (@real && scalar @real > 3){
			my $duration = ($real[3]/$real[1]);
			$total_time += $duration;
			my @stat = stat($flac_file);
			# stat returns size in bytes
			my $size = $stat[7];
			$total_size += $size;
			# in kilobits per second, not bytes
			my $kbs = $size/$duration/1000*8;
			$kbs = sprintf("%.0f",$kbs);
			# say "$stat[7] $stat[11] $stat[12]";
			# say "s: $size kbs: $kbs";
			# say "duration: $duration seconds";
			if ($type eq 'data' || !$flac_info){
				my $flac_data = $real[2] . '/' . sprintf("%.1f", $real[1]/1000);
				$flac_info = "FLAC: $flac_data";
				$flac_info .= " ($real[0] channels)";
				if ($type eq 'data'){
					$flac_data .= '/' . $real[0] . 'ch';
					if (!grep {$_ eq $flac_data} @info){
						push(@info,$flac_data);
					}
				}
			}
			if ($type eq 'data'){
				my ($raw_time,$raw_size) = ($duration,$size);
				my $time_print = 'time: ' . main::print_time($duration);
				my $size_print = 'size: '. main::print_size($size/1024);
				my $kbs_print = 'kbs: '. $kbs;
				if ($VERBOSITY > 2){
					$time_print .= " ($raw_time seconds)"; 
					$size_print .= " ($raw_size B)";
				}
				$results{$flac_file} = [$flac_info,$time_print,$size_print,$kbs_print];
				if ($VERBOSITY > 1){
					my $ffp_print = 'ffp: ' . $real[4];
					splice(@{$results{$flac_file}},1,0,$ffp_print);
				}
			}
		}
	}
	# say "Result: $flac_info";
	$avg_kbs = sprintf("%.0f",$total_size*8/$total_time/1000);
	# back to KiB
	$total_size_raw = $total_size;
	$total_size = $total_size/1024;
}
# this will be inserted into $INFO_FILE
sub info_data {
	my ($b_head,$b_inserted,$counter) = (1,0,0);
	my (@data);
	foreach (@$ref){
		$counter++;
		$b_head = 0 if $b_head && $counter > 1 && /^\s*$/;
		# put the block under the top band info header block
		if (!$b_inserted && !$b_head && $flac_info && $counter > 3){
			my $quality = "Quality: /$INFO_RATING ()";
			push(@data,(
			'',
			$flac_info,
			$quality,
			'Time: ' . main::print_time($total_time),
			'Size: ' . main::print_size($total_size),
			'Average kb/s: ' . $avg_kbs,
			'Tracks: ' . scalar @files,
			'',
			));
			$b_inserted = 1;
		}
		push(@data,$_);
	}
	return @data;
}
sub generate_output {
	my $time = main::print_time($total_time);
	my $size = main::print_size($total_size);
	if ($VERBOSITY > 2){
		$time .= " ($total_time seconds)"; 
		$size .= " ($total_size_raw B)"; 
	}
	say '  Generating flac data:';
	$time = '  Time: ' . $time;
	$size = '  Size: ' . $size;
	$avg_kbs = '  Average kb/s: ' . $avg_kbs;
	my $track_count = '  Tracks: ' . scalar @files;
	my $flac_data = '  Info: ' . join(', ',sort @info);
	foreach my $key (sort keys %results){
		say "   File: $key:";
		if ($VERBOSITY > 1){
			say '    ', join("\n    ",@{$results{$key}});
		}
		else {
			say '    ', join(' ',@{$results{$key}});
		}
	}
	say $flac_data if defined $flac_data;
	say $time if defined $time;
	say $size if defined $size;
	say $avg_kbs if defined $avg_kbs;
	say $track_count if defined $track_count;
}
}

#### -------------------------------------------------------------------
#### AUTO-TAGGING
#### -------------------------------------------------------------------

## AutoTag 
{
package AutoTag;
sub run_tagger {
	say $line_large;
	if ($run{'embed-image'}){
		say 'Starting image embedding in: ' . main::sourcer($SOURCE_DIRECTORY);
		image_embedder();
		say $line_small;
		say 'Completed image embedding.';
	}
	if ($run{'update-tag'}){
		say 'Starting tag update in: ' . main::sourcer($SOURCE_DIRECTORY);
		tag_updater();
		say $line_small;
		say 'Completed tag update.';
	}
	else {
		say 'Starting auto-tagging in: ' . main::sourcer($SOURCE_DIRECTORY);
		get_tag_files();
		say $line_small;
		say 'Completed auto-tagging.';
	}
	say $line_large;
}
sub create {
	say $line_large;
	say "Creating $TAG_FILE in: " . main::sourcer("$SOURCE_DIRECTORY");
	make_tag_file();
	say $line_small;
	say 'Completed file creation.';
	say $line_large;
}
sub get_tag_files {
	my ($item,$print_file,$result,$working_dir);
	$list_type = 'file';
	$extension = $TAG_FILE;
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	foreach $item (sort { "\L$a" cmp "\L$b" } @found_list){
		$print_file = $working_dir = $item;
		$print_file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $VERBOSITY < 3;
		# $working_dir =~ s/[^\/]+$//;
		$working_dir = File::Basename::dirname($item);
		chdir "$start_dir";
		chdir "$working_dir";
		if ($b_debug){
			say Cwd::getcwd();
			system 'pwd';
		}
		say "Processing: $print_file";
		process_tags();
		$b_dest_changed = 1;
	}
	if (!@found_list){
		say "No $TAG_FILE files found.";
	}
}
sub process_tags {
	my @tags = main::reader($TAG_FILE,'strip');
	my ($args,$error_message,@image_args,@images,@main_tags,
	@track_tags,@working);
	my ($b_image_check,$b_tracks);
	my ($cmd,$comments,$tag) = ('','','');
	state %set;
	foreach (@tags){
		@working=split /%:/, $_;
		# say Data::Dumper::Dumper \@working;
		next if ! $working[1];
		say "@working" if $b_debug;
		# $working[1] =~ s/"/\\\"/g;
		# $working[1] =~ s/\$/\\\$/g;
		$working[1] = main::escape_item("$working[1]");
		if ($working[0] =~ /^(TITLE|TRACKNUMBER|VERSION|PART)$/){
			$tag = qq(--set-tag=$working[0]="$working[1]" );
			push(@track_tags,$tag);
		}
		elsif ($working[0] ne 'FILE'){
			# delete all previous items for key, to avoid multi tagging
			if ($b_tracks && (!$set{$working[0]} || $working[1] eq 'UNSET')){
				if ($working[0] eq 'IMAGE'){
					@images = (); # reset the images completely
				}
				else {
					@main_tags = grep {!/^--set-tag=$working[0]/} @main_tags;
				}
				next if $working[1] eq 'UNSET';
			}
			# then set the key flag again
			$set{$working[0]} = 1;
			if ($working[0] eq 'IMAGE'){
				$tag = qq($working[1]);
				push @images, $tag;
			}
			else {
				$tag = qq(--set-tag=$working[0]="$working[1]");
				push(@main_tags,$tag);
			}
		}
		elsif ($working[0] eq 'FILE'){
			## NOTE: we have to unescape $ in paths for -e tests, but leave it escaped
			## for qq cmd strings. Why? Shell expands it, perl does not.
			my $temp = $working[1];
			# $temp =~ s/\\\$/\$/g;
			# $temp =~ s/\\\"/"/g;
			$temp = main::unescape_item("$temp");
			print " Tagging \"$temp\"...";
			main::error_handler('file-missing',"Missing file: $temp",1) if ! -e "$temp";
			# note: must be set here, not in qx to avoid quote errors
			# single quotes, in case contains $ symbol
			# say File::stat::stat("$working[1]")->size;
			$cmd = qq($COMMAND_METAFLAC --remove-all-tags $padding "$working[1]");
			say "\n", $cmd if $b_debug;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
			}
			if ($run{'remove-images'}){
				image_remover("$working[1]");
			}
			# say File::stat::stat("$working[1]")->size;
			# disable for now, the test for type isn't working, metaflac is making types
			# 3 regardless of actual type.
			@image_args = image_handler("$working[1]",@images) if @images;
			@track_tags = (@main_tags,@image_args,@track_tags);
			$args = join ' ', @track_tags;
			@track_tags = ();
			@image_args = ();
			# reset all detected @main items
			foreach (keys %set){
				$set{$_} = 0;
			}
			$cmd = qq($COMMAND_METAFLAC $args "$working[1]");
			say "\n", $cmd if $b_debug;
			$b_tracks = 1;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
				else {
					say '  File tagged';
				}
			}
			else {
				say '  Test mode, no tag';
			}
			# say File::stat::stat("$working[1]")->size;
		}
	}
}
sub tag_updater {
	my ($args,$cmd,$error_message,$file,$print_file,
	$result,%tag_data,@working,$working_dir);
	my ($print_padding,$print_tags,$remove,$tag) = ('','','','');
	$print_padding = ' and padding' if $padding;
	foreach (@tags){
		@working = split /%:/, $_;
		$tag .= qq(--set-tag=$working[0]="$working[1]" ) if $working[1] ne 'UNSET';
		$remove .= qq(--remove-tag=$working[0] );
		$print_tags .= qq($working[0])
	}
	$list_type = 'file';
	$extension = $INPUT_TYPE;
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	chdir "$start_dir";
	chdir "$SOURCE_DIRECTORY";
	say "Updating tags:$print_tags... ";
	foreach $file (sort { "\L$a" cmp "\L$b" } @found_list){
		$print_file = $working_dir = $file;
		$print_file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $VERBOSITY < 3;
		print "Processing: $print_file...\n Tags$print_padding ";
		$file = main::escape_item("$file");
		$cmd = qq($COMMAND_METAFLAC $remove "$file");
		if (!$b_test){
			qx($cmd);
			if ($? > 0){
				$error_message = "$COMMAND_METAFLAC $padding returned error: $?";
				main::error_handler('application-error', $error_message,1);
			}
			print 'removed... ';
		}
		else {
			print 'remove: skip... ';
		}
		$cmd = qq($COMMAND_METAFLAC $tag "$file");
		if (!$b_test){
			# if the only action is to UNSET the tag, $tag will be empty
			if ($tag){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
			}
			say 'Tags updated.';
		}
		else {
			say 'Tags update: skip';
		}
	}
	if (!@found_list){
		say "No $INPUT_TYPE files found.";
	}
}
sub make_tag_file {
	my ($file,@files);
	chdir "$start_dir";
	#chdir $SOURCE_DIRECTORY;
	my $source_dir = $SOURCE_DIRECTORY;
	# $source_dir =~ s|([\(\)\$])|\\$1|g;
	$source_dir =~ s|^\Q$source_dir$path_separator\E||;
	# say "source1:  $source_dir";
	print "Checking for pre-existing $TAG_FILE... ";
	if ($b_test){
		say "Running test mode.";
	}
	elsif (-e $source_dir . $path_separator . $TAG_FILE){
		main::error_handler('file-exists', "File $TAG_FILE already exists in:\n$source_dir",1);
	}
	else {
		say "none found. Proceeding.";
	}
	if ($b_debug){
		say 'cwd: ', Cwd::getcwd();
		system 'pwd';
		say "start1: $start_dir"
	}
	print "Creating $TAG_FILE file... ";
	$extension = $INPUT_TYPE;
	$list_type = 'file';
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	say '' if $VERBOSITY > 2;
	foreach $file (sort { "\L$a" cmp "\L$b" } @found_list){
		$b_dest_changed = 1;
		$file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		say $file if $VERBOSITY > 2;
		push(@files, $file);
	}
	if (@files){
		@files = sort @files; # can be a problem, if track number comes last!
		say "Processing.";
		populate_tag_file(\@files);
	}
	else {
		say "No files found to process.";
	}
}

sub prefill_data {
	my ($b_performer,%info);
	# no blank lines in band/location/date block, stop after first blank line.
	my ($b_top_block) = (1);
	my @data = InfoFix::open_info_file('prefill');
	my $counter = 0;
	foreach (@data){
		$counter++;
		$_ = main::trimmer($_);
		$b_top_block = 0 if !$_;
		if ($counter == 1){
			$info{'artist'} = $_;
		}
		elsif ($b_top_block && $counter < 7 && $_ !~ /^(19|20)[0-9]{2}-/){
			$_ =~ s/,$//;
			$info{'location'} .= ', ' . $_ if $info{'location'};
			$info{'location'} = $_ if !$info{'location'};
		}
		elsif ($b_top_block && $counter < 7 && $_ =~ /^(((19|20)[0-9]{2})-[01][0-9]-[0-3][0-9])(.*)?/){
			$info{'date-print'} = $1;
			$info{'date-print'} .= $4 if $4;
			$info{'date'} = $1;
			$info{'year'} = $2;
		}
		elsif (!$b_top_block && $counter > 4 && $_ =~ /^([1-6]-[0-9]{1,2}|[0-9]{1,2})\.\s(.*?)(\s+[\[\(][0-9:\.\s]+[\]\)]\s*)?$/){
			push(@{$info{'tracks'}},$2);
		}
		elsif ($counter > 8 && /^(Band|(Band\s)?Line[\s-]?up|(Band\s)?Members|Performers|Personnel):/i){
			$b_performer = 1;
			next;
		}
		if ($b_performer && $_){
			push(@{$info{'performers'}},$_);
		}
		elsif ($b_performer && !$_){
			$b_performer = 0;
		}
	}
	$info{'location'} =~ s/,\s*$// if $info{'location'};
	# say Data::Dumper::Dumper \%info;
	return %info;
}
sub populate_tag_file {
	my ($files) = @_;
	my (@multi,@replaygain,@tags,%info);
	my ($b_first,$j,$holder,$starter) = (1,0,'','');
	my $counter=$start;
	%info = prefill_data() if $run{'prefill'};
	say Data::Dumper::Dumper \%info if $b_debug;
	my @collection = (
	'## RECORDING NAME/CREATORS ##',
	'ALBUM','# Name to sort under','ALBUMSORT',
	'ARTIST','# Multi-Artist only','ALBUMARTIST',
	'COMPOSER','# Classical fields','CONDUCTOR','OPUS',
	'# Band members, etc.', 'PERFORMER','PERFORMER','PERFORMER','PERFORMER',,
	'PERFORMER','PERFORMER','PERFORMER','PERFORMER','PERFORMER','PERFORMER',
	'## RECORDING COMMENTS. Note: COMMENT preferred over DESCRIPTION ##',
	'COMMENT','COMMENT','COMMENT','COMMENT','COMMENT',
	 '## DISPLAY IMAGES ##',
	 '# Please see sample auto.tag file for more information on IMAGE',
	 '# Path to image file from where auto.tag file is located. Will be',
	 '# set as default type 3, cover image. ',
	 '# Example: IMAGE%:images/cover.jpg', 
	 '# To remove all embedded images:',
	 '# metaflac --remove --block-type=PICTURE,PADDING --dont-use-padding *.flac',
	 'IMAGE',
	'## RECORDING INFO ##',
	# note: VENUE and LABEL better handled by xiph spec: LOCATION and ORGANIZATION
	# Include YEAR to make conversion to mp3 tagging cleaner
	'GENRE','RATING','DATE','YEAR','LOCATION','PRODUCER','PUBLISHER',
	'CDDB','ISRC',
	'# e.g. record label, taper group,, etc. ','ORGANIZATION',
	'## TECHNICAL INFORMATION ##',
	'ENCODING',
	'# Useful for tapers etc','SOURCE','SOURCE','SOURCE','SOURCE',
	'# Media recording taken from, eg, cassette, tape, dat, vinyl','SOURCEMEDIA',
	);
	my @discs = ('DISCNUMBER','DISCSUBTITLE','TRACKTOTAL');
	my @disc = ('','## DISC INFO ##',
	'# Leave DISCNUMBER, DISCTOTAL empty if 1 disc set',
	'DISCTOTAL',
	'# Do not leave TRACKTOTAL empty, this is per disc track totals for players',
	@discs,'',
	'## TRACK INFO ##', 
	'# Use of any of above tags between track blocks will switch to the new value.',
	'# To make the value empty use: UNSET as the field value.',
	'# TRACKNUMBER and FILE required, title not known?: suggest TITLE%:Unknown ');
	my @track = ('','TRACKNUMBER','TITLE','VERSION','PART','FILE');
	@collection = map {$_ .= '%:' if /^[A-Z]/; $_;} @collection;
	if (%info && @collection){
		my @working;
		foreach my $item (@collection){
			if ($item =~ /^ARTIST%:/ && $info{'artist'}){
				$item .= $info{'artist'};
			}
			elsif ($item =~ /^ALBUMARTIST%:/ && $info{'artist'}){
				$item .= $info{'artist'};
			}
			elsif ($item =~ /^ALBUM%:/ && ($info{'date-print'} || $info{'location'})){
				$item .= $info{'date-print'} . ', ' if $info{'date-print'};
				$item .= $info{'location'} if $info{'location'};
				$item =~ s/,\s*$//;
			}
			elsif ($item =~ /^DATE%:/ && $info{'date'}){
				$item .= $info{'date'};
			}
			elsif ($item =~ /^YEAR%:/ && $info{'year'}){
				$item .= $info{'year'};
			}
			elsif ($item =~ /^LOCATION%:/ && $info{'location'}){
				$item .= $info{'location'};
			}
			elsif ($item =~ /^PERFORMER%:/ && $info{'performers'}){
				$item .= shift @{$info{'performers'}} if @{$info{'performers'}};
			}
			push(@working,$item);
		}
		@collection = @working if @working;
	}
	# say Data::Dumper::Dumper \@collection;
	@disc = map {$_ .= '%:' if /^[A-Z]/; $_;} @disc;
	@discs = map {$_ .= '%:' if /^[A-Z]/; $_;} @discs;
	if ($run{'autotag-single'} && @$files){
		@disc = map {$_ .= create_track_total(scalar (@$files)) if $_ eq 'TRACKTOTAL%:'; $_;} @disc;
	}
	if ($run{'autotag-multi'} && @$files){
		$autotag_multi =~ s/%/[1-9]/g;
		$autotag_multi =~ s/@/[A-Z]/g;
		# say "$autotag_multi";
		foreach (@$files){
			if (/^($autotag_multi)/i){
				$starter = $1;
				# $counter++;
			}
			else {
				main::error_handler('autotag-multi',
				 "$autotag_multi filename start pattern not found in file:\n$_!!",1);
			}
			if ($holder ne $starter){
				$j++;
				$holder = $starter;
				$multi[$j] = 1;
				# say "$starter $j";
			}
			else {
				$multi[$j]++;
			}
		}
		shift @multi;# get rid of first element
		($counter,$j,$holder,$starter) = ($start,0,'','');
		# this handles the first block of DISC info
		if (scalar @multi > 1){
			# say 'm:', $multi[0], ' sm: ', scalar @multi;
			@disc = map {$_ .= scalar @multi if $_ eq 'DISCTOTAL%:'; $_;} @disc;
			@disc = map {$_ .= create_track_total($multi[0]) if $_ eq 'TRACKTOTAL%:'; $_;} @disc;
			@disc = map {$_ .= 1 if $_ eq 'DISCNUMBER%:'; $_;} @disc;
		}
	}
	# say Data::Dumper::Dumper \@multi;
	@tags = (@collection,@disc);
	@track = map {$_ .= '%:' if /^[A-Z]/; $_;} @track;
	my (@disc_working,@info_working);
	if ($info{'tracks'}){
		if (scalar(@{$info{'tracks'}}) == scalar(@$files)){
			say "File/$INFO_FILE track counts match: " . scalar(@$files);
			@info_working = @{$info{'tracks'}};
		}
		else {
			main::error_handler('track-counts',"Prefill track count mismatch: Files: " . scalar(@$files) . 
			 '; Info Tracks: ' . scalar(@{$info{'tracks'}}),1);
		}
	}
	foreach (@$files){
		my @track_working = @track;
		if ($run{'autotag-multi'} && scalar @multi > 1){
			if (/^($autotag_multi)/i){
				$starter = $1;
			}
			if ($holder ne $starter){
				$holder = $starter;
				# say "$starter";
				if (!$b_first){
					$counter = $start;
					$j++;
					@disc_working = @discs;
					# and this handles all subsequent new disc/set block
					$disc_working[0] .= $j+1; # disc number
					$disc_working[2] .= create_track_total($multi[$j]); # track total
					# then we add in the tracks for the previous disk/set, and start
					# the next block
					@tags = (@tags,'',@disc_working);
				}
				$b_first = 0;
			}
		}
		if ($run{'autotag-single'} || $run{'autotag-multi'}){
			$track_working[1] = $track[1] . $counter;
		}
		$track_working[5] = $track[5] . $_;
		$track_working[2] = $track[2] . shift(@info_working) if @info_working;
		if (!$run{'no-replaygain'}){
			@replaygain = get_replaygain(main::escape_item("$_"));
			# we want the replaygain data right before FILE
			splice (@track_working, 5, 0, @replaygain) if @replaygain;
		}
		@tags = (@tags,@track_working);
		# this allows for 0 track numbers
		$counter++;
	}
	if ($b_test){
		say join "\n", @tags;
	}
	else {
		main::writer($TAG_FILE,\@tags);
	}
}
sub image_embedder{
	my ($args,$cmd,$error_message,@image_args,$item,$print_file,
	$result,$working_dir);
	$list_type = 'file';
	$extension = $INPUT_TYPE;
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	chdir "$start_dir";
	chdir "$SOURCE_DIRECTORY";
	if ($embed_image ne 'remove' && ! -e $embed_image){
		$error_message = "Embed image $embed_image could not be located!\n";
		$error_message .= "Source directory: $SOURCE_DIRECTORY\n";
		$error_message .= "Please make sure your embed image file name or path is correct.\n";
		main::error_handler('file-missing', $error_message,1);
	}
	foreach $item (sort { "\L$a" cmp "\L$b" } @found_list){
		$print_file = $working_dir = $item;
		$print_file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $VERBOSITY < 3;
		print "Processing: $print_file...";
		$item = main::escape_item("$item");
		if ($run{'remove-images'}){
			image_remover("$item");
		}
		if ($embed_image ne 'remove'){
			@image_args = image_handler("$item",("$embed_image"));
			$args = join ' ', @image_args;
			$cmd = qq($COMMAND_METAFLAC $args "$item");
			say "\n", $cmd if $b_debug;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
				say 'Image embedded';
			}
			else {
				say 'Test mode only';
			}
		}
		else {
			say 'Image and padding data removed';
		}
		$b_dest_changed = 1;
	}
	if (!@found_list){
		say "No $INPUT_TYPE files found.";
	}
}
sub image_remover {
	my ($file) = @_;
	my ($cmd,$error_message) = ('','');
	print "Removing images... ";
	$cmd = qq($COMMAND_METAFLAC --remove --block-type=PICTURE,PADDING --dont-use-padding "$file");
	if (!$b_test){
		qx($cmd);
		if ($? > 0){
			$error_message = "$COMMAND_METAFLAC returned error: $?";
			main::error_handler('application-error', $error_message,1);
		}
	}
	say "\n", $cmd if $b_debug;
}
# note: metaflac is ignring type integer and assigning 3, not sure why
sub image_handler {
	my ($file,@images) = @_;
	my ($size,@args,@result,$working);
	my $cmd = qq($COMMAND_METAFLAC --list --block-type=PICTURE "$file");
	@result = qx($cmd);
	@result = grep {/type:.*\(PICTURE\)/} @result if @result;
	# filename: type: 6 (PICTURE) 3||||images/cover.jpg
	# --import-picture-from="3||||front.jpg"
	foreach (@images){
		$working = (split /\|/, $_)[-1];
		if (@result){
			say "\n  Skipping $working (pre-existing image data)... ";
		}
		else {
			if (-e $working){
				$size = sprintf("%.1f", File::stat::stat("$working")->size / 1024);
				push @args, qq(--import-picture-from="$_");
				say "\n  Embedding $working ($size KiB)... ";
			}
			else {
				say "\n  File $working not found... ";
			}
		}
	}
	return @args;
}
# The idea here is that the track total will show the full number including
# removed start tracks. Not a common situation, but does happen
sub create_track_total {
	my $working = $_[0];
	# note: 0 start, track number to 14, 15 tracks, would show 14/15, so make shwo 14/14
	my ($total) = (0);
	if ($start == 0){
		$total = $working - 1;
	}
	# the normal, simple scalar of the found files. Default behavior
	elsif ($start == 1){
		$total = $working;
	}
	# ex: 15 original tracks, first 2 removed, start, file numbering == 03
	# 13 actual tracks, start 3, subtract 1.
	else {
		$total = $working + $start - 1;
	}
	# say "ctt: $start $total";
	return $total;
}
sub get_replaygain {
	my ($input_file) = @_;
	my (@tags);
	my %replaygain = main::get_flac_tags('replaygain',$input_file);
	foreach (keys %replaygain){
		push @tags, "$_%:$replaygain{$_}" if $replaygain{$_};
	}
	return @tags;
}
# --preserve-modtime --remove-all-tags --remove-tag
## end of AutoTag
}

#### -------------------------------------------------------------------
#### CHECKSUMS
#### -------------------------------------------------------------------

## Checksums 
{
package Checksums;
my ($print_src,%raw_ffps);
sub process {
	say $line_large;
	my $type = 'checksum processing';
	if ($run{'analyze'}){
		$type = 'flac analysis';
	}
	elsif ($run{'duplicates'}){
		$type = 'ffp duplicate tests';
	}
	elsif ($run{'checksum-ffps'}){
		$type = 'ffp collection';
	}
	say "Starting $type in: " . main::sourcer("$SOURCE_DIRECTORY");
	process_directories();
	say $line_small;
	say "Completed $type.";
	say $line_large;
}
sub process_directories {
	my (@files,$item,$result);
	my $qualify = '';
	if ($run{'no-ffp'}){
		$qualify .= " (Skipping ffp processing)";
	}
	if ($run{'no-md5'} && !$run{'duplicates'} && !$run{'checksum-ffps'}){
		$qualify .= " (Skipping md5 processing)";
	}
	$list_type = 'dir';
	say $line_small;
	say "Checking directories...$qualify";
	@found_list = ();
	chdir "$start_dir";
	File::Find::find(\&main::wanted, @source_glob);
	say 'start dir: ', $start_dir if $b_debug;
	foreach $item (sort { "\L$a" cmp "\L$b" } @found_list){
		my $b_valid;
		$print_src = $item;
		$print_src =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $VERBOSITY < 3;
		# if ($VERBOSITY > 2){
		#	say Cwd::getcwd();
		#	system 'pwd';
		# }
		chdir "$start_dir";
		chdir "$item";
		if ($b_debug){
			say 'srcdir: ', $SOURCE_DIRECTORY;
			say 'item: ', $item;
			say 'cwd: ', Cwd::getcwd();
			system 'pwd';
		}
		say " Processing: $print_src";
		@files = main::globber("*.{flac,FLAC,Flac}");
		# say "\n", Data::Dumper::Dumper \@files;
		if (grep -f, @files){
			if (!$run{'analyze'}){
				delete_checksums() if $run{'checksum-delete'};
				generate_checksums() if $run{'checksum'};
				$b_dest_changed = 1;
			}
			else {
				Analyze::run('data',\@files);
			}
		}
		else {
			say "  No $INPUT_TYPE files";
		}
		if ($run{'checksum-verify'}){
			verify_checksums(@files);
		}
	}
	if ($run{'duplicates'}){
		check_ffp_duplicates();
	}
}
sub generate_checksums {
	if (!$run{'duplicates'} && !$run{'checksum-ffps'}){
		say "  Generating checksums:";
		print "   File: $FFP_FILE.ffp: ";
	}
	else {
		say "  Collecting ffps...";
	}
	if ($b_debug){
		say 'cwd: ', Cwd::getcwd();
		system('pwd');
	}
	if (!$run{'no-ffp'}){
		generate_ffp() if !$run{'no-ffp'};
	}
	else {
		say 'skipped';
	}
	if (!$run{'no-md5'} && !$run{'duplicates'}){
		print "   File: $MD5_FILE.md5: ";
		generate_md5();
	}
}
sub generate_ffp {
	my ($error_message,@output);
	# system("$COMMAND_METAFLAC --show-md5sum *.flac > $FFP_FILE.ffp");
	# explicit --with-filename required in cases of 1 flac in directory
	@output = qx($COMMAND_METAFLAC --with-filename --show-md5sum *.flac);
	if ($? == -1 || $? > 0){
		$error_message = "$COMMAND_METAFLAC returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	else {
		chomp (@output);
		if ($run{'duplicates'}){
			$raw_ffps{$print_src} = \@output;
		}
		elsif (!$b_test && !$run{'checksum-ffps'}){
			main::writer("$FFP_FILE.ffp",\@output);
			say 'created for ' . scalar(@output) . ' files';
		}
		else {
			say '' if !$run{'duplicates'} && !$run{'checksum-ffps'};
			say "   Files: " . scalar(@output), "\n    ", join("\n    ", @output);
		}
	}
}
sub generate_md5 {
	my ($error_message,@output);
	# system("$COMMAND_MD5 *.* > $MD5_FILE.md5");
	@output = qx($COMMAND_MD5 -b *.*);
	if ($? == -1 || $? > 0){
		$error_message = "$COMMAND_MD5 returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	else {
		chomp (@output = grep {$_ !~ m^($TAG_FILE|\.ffp|\.md5)^} @output);
		if (!$b_test){
			main::writer("$MD5_FILE.md5",\@output);
			say 'created for ' . scalar(@output) . ' files';
		}
		else {
			say "\n   Files: " . scalar(@output), "\n    ", join("\n    ", @output);
		}
	}
}
sub verify_checksums {
	my (@files) = @_;
	verify_flacs() if !$run{'no-ffp'} && grep -f, @files;
	verify_md5() if !$run{'no-md5'};
}
# NOTE: something is wrong with how flac outputs to stderr and
# creates invisible text strings, maybe unicode related
sub verify_flacs {
	my ($b_app_error,$error_message,$err_nu,@errors);
	print "  Checking $INPUT_TYPE file ffps (be patient): ";
	# note, flac sends output to stderr
	# NOTE: $_ =~ s/([^\x20-\x7E])/sprintf '\x{%02x}', ord $1/eg;
	# shows the weird hidden text this command creates
	# say 'cwd: ', Cwd::getcwd();
	if (!(grep -f, main::globber("*.$INPUT_TYPE"))){
		say "No $INPUT_TYPE files found.";
		return;
	}
	my @results = qx($COMMAND_FLAC -wt *.flac 2>&1);
	$err_nu = $?;
	chomp @results;
	if ($b_debug){
		say "\@result count: ", scalar @results, "\n  ", join("\n  ",@results);
	}
	@results = grep {
		!/^\s*$/ && 
		!/(Xiph\.org|^flac\s[0-9]|this is free soft|for details)/ig} @results;
	@results = map {
		$_ =~ s/\s+$//;
		$_ =~ s/(testing.*complete|\x{08})//gi;
		$_ =~ s/[^[:print:]]+//g;
		$_;
	} @results;
# 	foreach (@results){
# 		$_ =~ s/([^\x20-\x7E])/sprintf '\x{%02x}', ord $1/eg;
# 		say "##$_##";
# 	}
	if ($err_nu > 0){
		$b_app_error = 1;
		$error_message = "$COMMAND_FLAC returned error: $?";
		print '  ';
		main::error_handler('application-error', $error_message,0);
		say "   Error Result:\n    ", join("\n    ",@results) if $VERBOSITY > 1;
	}
	$err_nu = 0;
	# @results = grep {/\.$INPUT_TYPE:\s/i} @results;
	# track.flac: testing, 33% completetesting, 65% completetesting, 98% completeok
	my $index = 0;
	my ($b_start,@temp);
	foreach (@results){
		# say length($_);
		# $_ =~ s/\s+$//; # moved to map
		# say "${_}::";
		# next if /^\s*$/; # moved to grep
		$b_start = 1 if !$b_start && $_ =~ /\.$INPUT_TYPE:/;
		next if !$b_start;
		#$_ =~ s/(testing.*complete|\x{08})//gi; # moved to map
		#$_ =~ s/[^[:print:]]+//g; # moved to map
		# say length($_);
		# say $_;
		# the poor design of flac output is hard to put into words
		# not only do they use those backspace hidden things, but
		# sometimes they decide to put the ok/failed/warning on its own line!!!
		# .flac: WARNING, cannot check MD5 signature since it was unset in the STREAMINFO
		# ok - or more odd, say it's ok after giving a warning
		if (/\.$INPUT_TYPE:/i){
			$index = scalar @temp;
			push(@temp, $_);
		}
		else {
			$_ =~ s/^\s+|\s+$//g;
			my $append = (lc($_) eq 'ok') ? " $_" : " :: $_" ;
			$temp[$index] .= $append if scalar @temp > 0;
		}
	}
	@results = @temp;
	# say scalar @results, "\n", "@results";
	# NOTE: cases found where ok and rest of string prints on next line!!
	@errors = grep {!/\.$INPUT_TYPE:\s+ok$/i} @results;
	@results = grep {/\.$INPUT_TYPE:\s+ok$/i} @results;
	# say scalar @results, "\n", "@errors";
	# say "errors:\n", join "\n", @errors;
	if (@errors){
		say '' if !$b_app_error;
		say "   Files with errors:\n    ", join("\n    ", @errors);
	}
	if (@results){
		if ($VERBOSITY > 1 || $b_app_error){
			say '' if !$b_app_error && !@errors;
			say "   Verified files:\n    ",  join("\n    ", @results);
		}
		else {
			say "Verified";
		}
	}
	else {
		say "No verified $INPUT_TYPE files";
	}
}
sub verify_md5 {
	my (@data,@errors,@results,@working);
	my ($b_bad,$b_break,$cmd,$hash,$hash2,$error_message,$msg,$result);
	my @checksums = main::globber("*.{md5,md5.txt}");
	foreach my $file (@checksums){
		print "  Checking md5 checksums in: $file: ";
		@data = main::reader($file,'strip');
		# say "data\n", join ("\n", @data);
		$b_break = 0;
		foreach my $track (@data){
			# say "track: $track";
			($hash,$hash2) = ('','');
			$track =~ /^([a-f0-9]+)([\s\*]+)(.*)$/;
			if ($1 && $3){
				$hash = $1;
				$track = $3;
				# convert to local paths, windows vs nix
				$track =~ s^[/|\\]^$path_separator^g;
				# say 't: ', $track;
				if ($VERBOSITY > 1){
					say '' if !$b_break;
					print "   Checking: $track: ";
					$b_break = 1;
				}
				if (-e $track){
					my $escaped = main::escape_item("$track");
					$cmd = qq($COMMAND_MD5 "$escaped");
					$result = qx($cmd);
					$hash2 = (split /\s/, $result)[0];
				}
				else {
					$hash2 = 'missing';
				}
				if ($hash2){
					if ($hash eq $hash2){
						say "Matched" if $VERBOSITY > 1;
					}
					else {
						say '' if !$b_break;
						print "   $track: " if $VERBOSITY < 2;
						$msg = ($hash2 ne 'missing') ? "FAILED" : "FAILED: File Not Found";
						say $msg;
						$b_bad = 1;
						$b_break = 1;
					}
					if ($VERBOSITY > 2){
						say "    MD5 Test: $hash Actual: $hash2";
					}
				}
			}
		}
		say "All Files Matched" if !$b_bad && $VERBOSITY < 2;
	}
}
sub delete_checksums {
	my $error_message = '';
	# note: some checksum generators tack on a .txt to the filename.
	# seen case like: "verbose stuff md5.txt
	my @checksums = main::globber("*{.ffp,ffp.txt,.md5,md5.txt}");
	# say Data::Dumper::Dumper @checksums;
	foreach my $file (@checksums){
		print "   Deleting $file: ";
		if ($b_test){
			say "test deletion";
		}
		elsif (unlink($file)){
			say "deleted";
		}
		else {
			main::error_handler('checksum-delete', "Failed to delete: $file");
		}
	}
}
sub check_ffp_duplicates {
	# say Data::Dumper::Dumper \%raw_ffps;
	my (%dupes,%orig,@ffps);
	my ($count,$i,$pad) = (0,0,2);
	say $line_small;
	say "Starting duplicate verification...";
	foreach my $dir (sort keys %raw_ffps){
		# say 'd1: ', $dir;
		foreach my $item (@{$raw_ffps{$dir}}){
			my @track = split(/:/,$item);
			if (!grep {$_ eq $track[-1]} @ffps){
				push(@ffps, $track[-1]);
			}
			else {
				if ($VERBOSITY > 2){
					say " Duplicate found in:\n  $dir:";
					say "   ffp:  $track[-1]";
					say "   file: $track[0]";
				}
				push(@{$dupes{$dir}},$item);
			}
		}
	}
	say $line_small;
	if (%dupes){
		$count = keys %dupes;
		$pad = get_pad($count);
		say "The following $count directories had ffp duplicates:";
		foreach my $dir (sort keys %dupes){
			$i++;
			say ' ', sprintf("%0${pad}d: ", $i), $dir;
			# if ($VERBOSITY > 1){
				say "  dupe: ", join("\n  dupe: ", sort @{$dupes{$dir}});
			# }
		}
		say $line_small;
		say "These were first found in:";
		foreach my $dir (sort keys %dupes){
			 #say 'd2: ', $dir;
			foreach my $item (@{$dupes{$dir}}){
				my $ffp = (split(/:/,$item))[-1];
				FFP:
				foreach my $dir1 (sort keys %raw_ffps){
					# say 'd3: ', $dir1;
					# this fails in instance where dupes are in same dir
					# next if $dir eq $dir1;
					FFP1:
					# say 'd4: ', $dir1;
					foreach my $item1 (@{$raw_ffps{$dir1}}){
						next FFP1 if $dir eq $dir1 && $item eq $item1;
						my $ffp1 = (split(/:/,$item1))[-1];
						if ($ffp eq $ffp1){
							if ($VERBOSITY > 2){
								say " $dir1";
								say "  item: $item1";
							}
							if (!grep {$_ eq $item1} @{$orig{$dir1}}){
								push(@{$orig{$dir1}},$item1);
							}
							next FFP;
						}
					}
				}
			}
		}
		if (%orig){
			$i = 0;
			$count = keys %orig;
			$pad = get_pad($count);
			foreach my $dir (sort keys %orig){
				$i++;
				say ' ', sprintf("%0${pad}d: ", $i), $dir;
				# if ($VERBOSITY > 1){
					say "  orig: ", join("\n  orig: ", sort @{$orig{$dir}});
				# }
			}
		}
	}
	else {
		say "No ffp duplicates found!! Great!!";
	}
}
sub get_pad {
	my $count = $_[0];
	my $pad = 2;
	if ($count < 10){
		$pad = 1;}
	elsif ($count < 100){
		$pad = 2;}
	elsif ($count < 1000){
		$pad = 3;}
	elsif ($count < 10000){
		$pad = 4;}
	return $pad;
}
}

#### -------------------------------------------------------------------
#### CLEANING
#### -------------------------------------------------------------------

## CleanCollection
{
package CleanCollection;

sub process {
	say $line_large;
	say "Starting cleanup of: " . main::sourcer("$DESTINATION_DIRECTORY");
	process_type('directory');
	process_type('file');
	say $line_small;
	say 'Completed cleanup checks.';
	say $line_large;
	exit if !$run{'clean-sync'};
}
sub process_type {
	my ($type) = @_;
	my ($b_deleted,$item,$result);
	$list_type = ($type eq 'directory') ? 'dir-clean': 'file-clean';
	say $line_small;
	say "Checking $type removal...";
	@found_list = ();
	File::Find::find(\&main::wanted, $DESTINATION_DIRECTORY);
	if (@found_list && confirm_deletion($type)){
		foreach $item (sort { "\L$a" cmp "\L$b" } @found_list){
			$result = 'UNSET';
			say "Deleting $type: $item";
			$result = File::Path::rmtree("$item") if !$b_test;
			$b_deleted = 1;
			$b_dest_changed = 1;
			say "Delete $type result: $result" if $VERBOSITY > 1;
		}
	}
	main::print_not_found("$type-cleaned") if ! $b_deleted;
}
sub confirm_deletion {
	my ($type) = @_;
	my ($b_confirm,$response) = (0,'');
	say $line_small;
	say join("\n", @found_list);
	say $line_small;
	say "The preceding $type items will be deleted. Deletions cannot";
	say "be restored! BE AWARE!!";
	say "Please type 'delete' + 'enter' to remove them, or hit 'enter' to skip.";
	say "If you are unsure, hit 'enter' to see the file list." if $type eq 'directory';
	chomp($response = <STDIN>);
	if (lc($response) eq 'delete'){
		say "Are you SURE you want to delete these items?";
		say "Type 'yes' + 'enter' to confirm, or hit 'enter' to skip.";
		chomp($response = <STDIN>);
		return 1 if lc($response) eq 'yes';
	}
	say "Skipping deletion for this $type group.";
	return 0;
}
## end package 
}

#### -------------------------------------------------------------------
#### INFO FILE PROCESSING
#### -------------------------------------------------------------------

## InfoFix
{
package InfoFix;
sub process {
	my (@files,$item,$print_src,$result);
	$list_type = 'dir';
	say $line_small;
	say "Checking directories for: $INFO_FILE";
	@found_list = ();
	chdir "$start_dir";
	File::Find::find(\&main::wanted, @source_glob);
	say 'start dir: ', $start_dir if $b_debug;
	foreach $item (sort { "\L$a" cmp "\L$b" } @found_list){
		my $b_valid;
		$print_src = $item;
		$print_src =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $VERBOSITY < 3;
		chdir "$start_dir";
		chdir "$item";
		if ($b_debug){
			say 'srcdir: ', $SOURCE_DIRECTORY;
			say 'item: ', $item;
			say 'cwd: ', Cwd::getcwd();
			system 'pwd';
		}
		say " Processing: $print_src";
		if (-r "$INFO_FILE"){
			# say $line_small;
			say "  Working on file: $INFO_FILE";
			run_fixes();
		}
		else {
			say "  No $INFO_FILE found";
		}
	}
	if (!@found_list){
		say "No directories found.";
	}
}
sub run_fixes {
	my (@prepped);
	my ($newlines) = (0);
	my @data = open_info_file('info-fixes');
	@data = date_fix(\@data) if $run{'infofix-date'};
	@data = Analyze::run('info',\@data) if $run{'infofix-quality'};
	# say Data::Dumper::Dumper \@data;
	# we want these to be set to uppercase again after autoformat runs
	my $upper = 'Aud|Cdr?|Sd?b|Ips|Eac|Ak|Az|Ca|Co|Ct|Dc|De|Dk|Fl|Flac|Hd|Hi|Il|';
	$upper .= 'Ma|Md|Mkw|Mo|Nc|Nh|Nj|Nm|Nyc?|Pa|Ri|Sbd?|Sf|Shn|Tn|Usa|Ut|Wa|';
	$upper .= 'Wav|Wi|Va|Vt';
	foreach my $row (@data){
		if ($run{'infofix-upper'}){
			foreach my $style (qw(highlight)){
				$row = Text::Autoformat::autoformat($row, {case => $style, left=>1, right=>1000});
			}
			# set back to upper common abbreviations, states, etc
			# don't do Or or Me or Oh!
			$row =~ s/\b($upper)\b/\U$1/g;
			$row =~ s/\bCD[\s-]?([1-6])/Disc $1/g;
			$row =~ s/\bSB\b/SBD/g;
		}
		$row =~ s/[\r\n]+//g; # has to be AFTER autoformat
		$row =~ s/\s\s+/ /g;
		$row =~ s/\s+$//g;
		$row =~ s/\(\s+/\(/g;
		$row =~ s/\s+\)/\)/g;
		$row =~ s/^\s+$//;
		if ($row !~ /^$/){
			$newlines = 0;
		}
		else {
			$newlines++;
		}
		# 1-4 / 1-12 / 12 / 213
		if (($run{'infofix-no'} || $run{'infofix-title'}) && 
		 $row =~ /^(\s*(([1-9]-)([0-9]{1,2})|([0-9]{1,2}|[0-9]{3}))(\]\s*|\.\s*|\s*-\s*|\s*\)\s*|:\s*|\s+))/){
			# say "$1 '$6'";
			if ($run{'infofix-no'}){
				# say "$1 $2 $3";
				my $nu = (defined $4) ? $4 : $5;
				my $disc = (defined $3) ? $3 : '';
				my $pattern = $1;
				if ($nu =~ /^([1-9])([0-9]{2})$/){
					$nu = $2;
					$disc = $1 . '-';
				}
				$nu = sprintf('%02d',$nu);
				$nu = $disc . $nu if $disc;
				$row =~ s/^\Q$pattern\E/$nu. /;
			}
			if ($run{'infofix-title'}){
				foreach my $style (qw(highlight)){
					$row = Text::Autoformat::autoformat($row, { case => $style, left=>1, right=>1000 });
					$row =~ s/[\r\n]+//g; # has to be AFTER autoformat
				}
				$row =~ s/\s+[\(\[]?([0-9]{1,2}[\.:]([0-9\.:]+))[\)\]]?\s*$/ ($1)/;
			}
		}
		# $row =~ s//'/g;
		# $row =~ s/�/'/g;
		# say $row;
		push(@prepped,$row) if $newlines < 2;
	}
	print '  Processing completed. ';
	if (!$run{'infofix-write'}){
		say "Write changes to $INFO_FILE by adding 'w':";
		say $line_small;
		print "   Fix: ";
		say join("\n   Fix: ",@prepped);
	}
	else {
		say "Writing changes to $INFO_FILE:";
		say $line_small;
		print '   ';
		say join("\n   ",@prepped);
		my $contents = join("\r\n",@prepped);
		open(my $fh, '>', $INFO_FILE) or die "failed to open for writing: $INFO_FILE";
		print $fh $contents;;
		close $fh if $fh;
		say $line_small;
		say "  Changes written to $INFO_FILE.";
	}
}
sub date_fix {
	my ($ref) = @_;
	my ($dd,$mm,$regex,$yyyy,@data);
	foreach (@$ref){
		($dd,$mm,$regex,$yyyy) =  ('','','','');
		# fix D month, YY, month D, YY, month-DD-YYYY
		# regex: 1: total regex; 2: container for day start; 3: day start
		# 4: optional nd/rd 5: month; 6: container for day; 7: day;
		# 8: optional nd/rd etc; 9: year; 10: 19..; 11: 20..
		if (/\b(((0?[1-9]|[12][0-9]|30|31)(nd|rd|st|th)?\s+)?(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\S*?([\s\/,-]+(0?[1-9]|[12][0-9]|30|31)(nd|rd|st|th)?)?[\s\/,-]+((19)?[4-9][0-9]|(20)?[012][0-9]))\b/i){
			$regex = $1;
			$yyyy = $9;
			# say "rx: $regex 5: $5 9: $9";
			my $month = lc($5);
			if ($3){$dd = sprintf('%02d',$3)}
			elsif ($7){$dd = sprintf('%02d',$7)}
			if ($month eq 'jan'){$mm = '01';}
			elsif ($month eq 'feb'){$mm = '02';}
			elsif ($month eq 'mar'){$mm = '03';}
			elsif ($month eq 'apr'){$mm = '04';}
			elsif ($month eq 'may'){$mm = '05';}
			elsif ($month eq 'jun'){$mm = '06';}
			elsif ($month eq 'jul'){$mm = '07';}
			elsif ($month eq 'aug'){$mm = '08';}
			elsif ($month eq 'sep'){$mm = '09';}
			elsif ($month eq 'oct'){$mm = '10';}
			elsif ($month eq 'nov'){$mm = '11';}
			elsif ($month eq 'dec'){$mm = '12';}
			# say "y: $yyyy m: $mm d: $dd";
		}
		# Change m/d/yy or m-d-yy or m.d.yy to yyyy-mm-dd 09/19/54
		elsif (/\b((0?[1-9]|1[0-2])[\/\.-](0?[1-9]|[12][0-9]|30|31)[\/\.-]((19)?[4-9][0-9]|(20)?[0-2][0-9]))\b/){
			$regex = $1;
			$mm = sprintf('%02d',$2);
			$dd = sprintf('%02d',$3);
			$yyyy = $4;
		}
		elsif (/\b((19[4-9][0-9]|20[0-2][0-9])[\._-]?(0?[1-9]|1[0-2])[\._-]?(0?[1-9]|[12][0-9]|30|31))\b/){
			$regex = $1;
			$yyyy = $2;
			$mm = sprintf('%02d',$3);
			$dd = sprintf('%02d',$4);
		}
		if ($yyyy =~ /^[4-9][0-9]$/){
			$yyyy = '19' . $yyyy;
		}
		elsif ($yyyy =~ /^[0-2][0-9]$/){
			$yyyy = '20' . $yyyy;
		}
		if ($mm && $dd && $yyyy){
			$_ =~ s/\Q$regex\E/$yyyy-$mm-$dd/i;
		}
		push(@data,$_);
	}
	return @data;
}
sub open_info_file {
	my ($source) = @_;
	my (@data);
	my ($in1) = ('  ');
	if ($source eq 'prefill'){
		chdir "$start_dir";
		chdir "$SOURCE_DIRECTORY";
		($in1) = ('');
	}
	print $in1 . "Checking $INFO_FILE... ";
	if (! -r $INFO_FILE){
		main::error_handler('open',"$INFO_FILE not readable or not present!",1) ;
	}
	else {
		open(my $fh, '<', $INFO_FILE) or 
		main::error_handler('open', "Failed to open: $INFO_FILE with error:\n:$!",1);
		chomp(@data = <$fh>);
		close $fh if $fh;
		say 'File found and read';
		my $count = scalar @data;
		if ($count < 15){
			main::error_handler('info-file',"$INFO_FILE only had $count lines",1);
		}
		push(@data,'') if @data;
	}
	return @data;
}
}

#### -------------------------------------------------------------------
#### SYNCING
#### -------------------------------------------------------------------

## SyncCollection 
{
package SyncCollection; 

sub process {
	my (@extension_files);
	eval $print_line_heavy;
	if ($VERBOSITY > 1){
		say 'Syncing: ' . main::sourcer("$DESTINATION_DIRECTORY") . ' (destination) with:';
		say '  ' . main::sourcer("$SOURCE_DIRECTORY") . ' (source)';
	}
	elsif ($VERBOSITY > 0){
		say 'Starting sync of: ' . main::sourcer("$SOURCE_DIRECTORY");
		say ' to: ' . main::sourcer("$DESTINATION_DIRECTORY");
	}
	update_directories();
	$list_type = 'file';
	foreach (@extension_list){
		eval $print_line_large;
		$extension = $_;
		@found_list = ();
		File::Find::find(\&main::wanted, @source_glob);
		# say Dumper \@found_list;
		if ($VERBOSITY > 1){
			say "PROCESSING DATA TYPE: $extension";
		}
		elsif ($VERBOSITY > 0){
			print "\n" . main::dotify("Processing $extension data type");
		}
		if (@found_list){
			update_files();
		}
		else {
			main::print_not_found('extension');
		}
	}
}
# Recreate the directory hierarchy.
sub update_directories {
	my ($b_created,$dest_dir,$dir,$result);
	$list_type = 'dir';
	@found_list = ();
	File::Find::find(\&main::wanted, @source_glob);
	eval $print_line_large;
	# say Dumper \@found_list;
	if ($VERBOSITY > 1){
		say "Checking if $self_name needs to create destination directories...";
	}
	elsif ($VERBOSITY > 0){
		print main::dotify("Updating destination directories");
	}
	foreach $dir (sort { "\L$a" cmp "\L$b" } @found_list){
		# say "\nd1:$dir";
		$result = 'UNSET';
		next if $dir eq $SOURCE_DIRECTORY || $dir eq $DESTINATION_DIRECTORY;
		$dir =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||; # strip out source path
		next if !$dir;
		$dest_dir = $DESTINATION_DIRECTORY . $path_separator . $dir;
		# say "d2:$dir";
		# check to see if the destination dir already exists
		if (! stat("$dest_dir")){
			# stat failed so create the directory
			eval $print_line_small;
			if ($VERBOSITY > 1){
				say "CREATING NEW DIRECTORY:\n $dest_dir";
			}
			elsif ($VERBOSITY > 0){
				print "\nCreating new directory: $dest_dir";
			}
			$dest_dir =~ s/\`/\'/g; # get rid of weird characters
			$result = mkdir("$dest_dir") if !$b_test;
			$b_created = 1;
			$b_dest_changed = 1;
			say "Create Directory result: $result" if $VERBOSITY > 1;
		}
	}
	main::print_not_found('dirs') if ! $b_created;
}

sub update_files {
	my ($b_created);
	my ($dest_file,$file,$result,$action,$src_file) = ('','','','','');
	my ($dest_info,$dest_mod_time,$src_info, $src_mod_time) = ('',0,'',0);
	my $pm = new Parallel::ForkManager($FORK) if $b_fork;
	foreach $file (sort { "\L$a" cmp "\L$b" } @found_list){
		next if ! $file;
		$dest_file = $src_file = $file;
		# say "\nIF: $src_file";
		$dest_file =~ s|^$SOURCE_DIRECTORY|$DESTINATION_DIRECTORY|;
		$dest_file =~ s/\`/\'/g;
		# $dest_file =~ s/\$/\\\$/g;
		# get rid of escape sequences in case someone used them: \40
		# $src_file =~ s/\0//g; 
		$dest_file =~ s/\0//g;
		# Figure out what the destination file would be...
		if (lc($extension) eq $INPUT_TYPE){
			$dest_file =~ s/\.$INPUT_TYPE$/\.$OUTPUT_TYPE/i;
		}
		# say "OF: $dest_file";
		($action,$result,$dest_mod_time,$src_mod_time) = ('UNSET','UNSET',0,0);
		# Now stat the destinationFile, and see if it's date is more recent
		# than that of the original file. If so, we re-encode.
		# We also re-encode if the user supplied --force
		$src_info = File::stat::stat("$src_file") or 
		  main::error_handler('stat-infile', "No $src_file: $!",1);
		$src_mod_time = $src_info->mtime if $src_info;
		$dest_info = File::stat::stat("$dest_file");
		if ($dest_info){
			$dest_mod_time = $dest_info->mtime;
			#  :: FORCE: $b_force
# 			say "DEST_MOD: $dest_mod_time :: SRC_MOD: $src_mod_time"; 
# 		} else {
# 			say "NOT EXISTS: $dest_file "; 
# 			say "P1: $file ==> \n  $dest_file"; 
		}
		# If the destination file does not exist, or the user specified force,
		# or the srcfile is more recent then the dest file, we encode/copy.
		# say "src-mt: $src_mod_time dest-mt:$dest_mod_time";
		if (!$dest_info || $b_force || ($src_mod_time > $dest_mod_time)){
			# these have to be set before the forking
			$b_created = 1;
			$b_dest_changed = 1;
			if (lc($extension) eq $INPUT_TYPE){
				$pm->start and next if $b_fork; # do the fork 
				my @returns = convert_file($src_file, $dest_file);
				$result = $returns[0];
				$action = $returns[1];
				$pm->finish if $b_fork;
			} 
			else {
				$action = 'Copy';
				$result = copy_file($file, $src_file, $dest_file);
			}
			# NOTE: for forking > 1, this will not print out for the output/input conversion files 
			say "$action result: $result" if $VERBOSITY > 1;
		} 
	}
	# wait for all the forks to finish before terminating 
	# the parent.. otherwise terminating the parent force kills 
	# all the forks 
	$pm->wait_all_children if $b_fork;
	main::print_not_found('files') if ! $b_created;
}

sub copy_file {
	my ($file, $src_file, $dest_file) = @_;
	my $result = 'UNSET';
	my ($src_print,$dest_print) = ($src_file, $dest_file);
	if ($VERBOSITY < 3){
		$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E||;
	}
	eval $print_line_small;
	if ($VERBOSITY > 1){
		say "COPY: $src_print ==> ";
		say "      $dest_print"; 
	}
	elsif ($VERBOSITY > 0){
		print "\nCopying $src_print...";
	}
	if (!$b_test){
		$result = File::Copy::copy($src_file, $dest_file) or 
			main::error_handler('cp-file', "cp failure: $src_file =>\n$dest_file\nCode: $!",1);
	}
	return $result;
}

sub convert_file { 
	my ($src_file, $dest_file) = @_;
	my ($src_print,$dest_print) = ($src_file,$dest_file);
	my ($result,$cmd,$action) = (1000,'','unset'); 
	my ($encoding,$encoded) = ('Encoding','Encoded');
	if ($run{'resample'}){
		($encoding,$encoded) = ('Resampling','Resampled');
	}
	# escape characters for conversion processing
	$src_file = main::escape_item("$src_file");
	$dest_file = main::escape_item("$dest_file");
# 	$src_file =~ s/"/\\"/g;
# 	$dest_file =~ s/"/\\"/g;
# 	$src_file =~ s/`/\\`/g;
# 	$dest_file =~ s/`/\\`/g;
# 	$src_file =~ s/\$/\\\$/g;
# 	$dest_file =~ s/\$/\\\$/g;
	if ($VERBOSITY < 3){
		$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E||;
	}
	# with forking, the printing gets messed up unless it's done 
	# just like this.
	if (!$b_fork){
		eval $print_line_small;
		if ($VERBOSITY > 1){
			say uc($encoding) . ": $src_print ==> ";
			say "        $dest_print"; 
		}
		elsif ($VERBOSITY > 0){
			# add line break only when file exists
			print main::dotify("\n$encoding $src_print to $OUTPUT_TYPE");
		}
	}
	if ($OUTPUT_TYPE eq 'aac' || $OUTPUT_TYPE eq 'm4a'){
		$action = "To $OUTPUT_TYPE";
		if (!$b_test){
			# note: sample depth is taken usually from originating file, like shn or wav, but 
			# mp3 does not seem to do this in my tests, and outputs to 24 bit
			# note that -aq / -q:a does not seem to do anything, and ffmpeg reverts to default 5 level
			my $sample_depth = ($INPUT_TYPE eq 'mp3') ? '-sample_fmt s16' : '';
			qx($COMMAND_FFMPEG $silent_ffmpeg -y -i "$src_file" -b:a ${quality}k -c:a $codec $sample_depth "$dest_file");
			$result = $?;
		}
	}
	elsif ($OUTPUT_TYPE eq 'flac'){
		$action = (!$run{'resample'}) ? 'To flac' : 'to ' . $run{'resample'}->[0] . ':' . $run{'resample'}->[1];
		# note: sample depth is taken usually from originating file, like shn or wav, but 
		# mp3 does not seem to do this in my tests, and outputs to 24 bit
		# note that -aq / -q:a does not seem to do anything, and ffmpeg reverts to default 5 level
		my $sample_data = '';
		if ($INPUT_TYPE eq 'mp3'){
			$sample_data = '-sample_fmt s16';
		}
		elsif ($run{'resample'}){
			$sample_data = '-sample_fmt s' . $run{'resample'}->[0] . ' -ar ' . $run{'resample'}->[1];
		}
		$cmd = qq($COMMAND_FFMPEG $silent_ffmpeg -y -i "$src_file" -compression_level $quality $sample_data "$dest_file");
		if (!$b_test){
			qx($cmd);
			$result = $?;
		}
		else {
			say "Would have run: $cmd";
		}
	}
	elsif ($OUTPUT_TYPE eq 'mp3'){
		$action = 'To mp3';
		if (!$b_test){
			# Modified: Odd @2011-03-23 01:51:26 - Include ID3 copying
			$cmd = main::flac2mp3_cmd("$src_file","$dest_file");
			qx($cmd);
			$result = $?;
		}
	}
	elsif ($OUTPUT_TYPE eq 'ogg'){
		$action = 'To ogg';
		# ffmpeg -i 'file.flac'  -map_metadata:s:a 0:g 'file.ogg'
		# my $meta_data = '--map_metadata:s:a 0:g';
		if (!$b_test){
			if (!$run{'ffmpeg'}){
				qx($COMMAND_OGG $silent_flac -q $quality -o "$dest_file" "$src_file");
				$result = $?;
			}
			else {
				qx($COMMAND_FFMPEG $silent_ffmpeg -y -i "$src_file" -map_metadata:s:a 0:s -aq $quality "$dest_file");
				$result = $?;
			}
		}
	}
	elsif ($OUTPUT_TYPE eq 'opus'){
		$action = 'To opus';
		if (!$b_test){
			qx($COMMAND_OPUS $silent_opus --bitrate $quality "$src_file" "$dest_file");
			$result = $?;
		}
	}
	if ($b_fork){
		eval $print_line_small;
		if ($VERBOSITY > 1){
			say uc($encoded) . ": $src_print ==> ";
			say "        $dest_print"; 
			say "$action result: $result";
		}
		elsif ($VERBOSITY > 0){
			# add line break only when file exists
			print main::dotify("\n$encoded $src_print to $OUTPUT_TYPE");
		}
	}
	# this return only works with non forking
	return ($result,$action); 
}
## end package 
}

#### -------------------------------------------------------------------
#### TAGGING
#### -------------------------------------------------------------------

# Added: Odd @2011-03-23 01:52:31
sub flac2mp3_cmd {
	my ($i_file, $o_file) = @_;
	my %tags = get_flac_tags('standard',"$i_file");
	my $lame_params = '';
	foreach (keys %tags){
		$tags{$_} = escape_item($tags{$_});
	}
	# say Dumper \%tags;
	if ($tags{'TRACKNUMBER'} && $tags{'TRACKTOTAL'}){
		$tags{'TRACKNUMBER'} .= "/$tags{'TRACKTOTAL'}";
	}
	if ($tags{'DISKNUMBER'} && $tags{'DISKTOTAL'}){
		$lame_params .= "--tv \"TPOS=$tags{'DISKNUMBER'}/$tags{'DISKTOTAL'}\" ";
	}
	$lame_params .= ' --ta "' . $tags{'ARTIST'} . '"';
	$lame_params .= ' --tl "' . $tags{'ALBUM'} . '"';
	$lame_params .= ' --tt "'. $tags{'TITLE'} . '"';
	$lame_params .= ' --tg "' . $tags{'GENRE'} . '"';
	$lame_params .= ' --ty "' . $tags{'DATE'} . '"';
	$lame_params .= ' --tn "' . $tags{'TRACKNUMBER'} . '"';
	$lame_params .= ' - "' . $o_file . '"';
	# $lame_params .= ' --tt \"$tags{'TRACKTOTAL'}\" --tg \"$tags{'DISKNUMBER'}\"';
	my $cmd = "$COMMAND_FLAC $silent_flac -d -c \"$i_file\" | ";
	$cmd .= "$COMMAND_LAME $silent_lame -h -V $quality $lame_params";
	# say $cmd;
	return $cmd;
}

# Added: Odd @2011-03-23 01:52:17
# args: $type: standard|replaygain; $i_file: file to work on
# For this function to work reliably, it should be passed tag queries in the order of:
# artist, album, title, genre, date, tracknumber
sub get_flac_tags {
	my ($type,$i_file) = @_;
	my (%tag_list,@tags,@working);
	if ($type eq 'standard'){
		@tags = ('ARTIST', 'ALBUM', 'TITLE','GENRE', 'DATE', 'TRACKNUMBER', 
		'TRACKTOTAL','DISKNUMBER','DISKTOTAL');
	}
	elsif ($type eq 'replaygain'){
		@tags = ('REPLAYGAIN_TRACK_PEAK','REPLAYGAIN_TRACK_GAIN',
		'REPLAYGAIN_ALBUM_PEAK','REPLAYGAIN_ALBUM_GAIN','WAVEFORMATEXTENSIBLE_CHANNEL_MASK');
	}
	my $cmd = "$COMMAND_METAFLAC \"$i_file\" ";
	foreach (@tags){
		$cmd .= "--show-tag=\"$_\" ";
	}
	my @orig_tags = qx($cmd);
	chomp @orig_tags;
	foreach (@orig_tags){
		@working = split /=/,$_;
		$tag_list{$working[0]} = $working[1];
	}
	# create missing hash keys
	foreach (@tags){
		$tag_list{$_} = '' if ! defined $tag_list{$_};
	}
	# say Dumper \%tag_list;
	return %tag_list;
}

#########################################################################
### PROGRAM TOOLS ###
#########################################################################

#### -------------------------------------------------------------------
#### UTILITIES
#### -------------------------------------------------------------------

# $1 - Perl module to check
sub check_module {
	my ($module) = @_;
	my $b_present = 0;
	eval "require $module";
	$b_present = 1 if !$@;
	return $b_present;
}

sub dotify {
	my $string = $_[0];
	while (length($string) < 53){
		$string .= '.';
	}
	$string .= ' ';
	return $string;
}

sub escape_item {
	my ($file) = @_;
	$file =~ s/"/\\"/g;
	$file =~ s/`/\\`/g;
	$file =~ s/\$/\\\$/g;
	$file =~ s/\@/\\\@/g;
	return $file;
}
# args: 1 - string value to glob
# Note: because of spaces and other strange user file paths, need to use 
# bsd glob, which returns space agnostic globs, as you'd expect. 
sub globber {
	# my @files = glob qq{"$_[0]"};
	# say Data::Dumper::Dumper @files;
	# say $_[0];
	# return @files;
	return <$_[0]>;
}
# args: 1 size in KiB
sub print_size {
	my ($size) = $_[0];
	return 'Error' unless $size;
	my ($j,$k) = ($VERBOSITY < 2) ? (1,2): (2,3);
	my ($unit);
	if ($size < 1024){
		$unit = 'KiB';
	}
	elsif ($size < 1024**3) {
		$unit = 'MiB';
		$size = sprintf("%.${j}f",$size/1024);
	}
	else {
		$unit = 'GiB';
		$size = sprintf("%.${k}f",$size/1024**3);
	}
	return "$size $unit";
}
# args: 1 - time in seconds
sub print_time {
	my ($seconds) = $_[0];
	return 0 unless $seconds;
	my ($hours,$minutes,$secs,$cents,$time) = (0,0,0,0,'');
	if ($seconds > 60**2){
		$hours = int($seconds/60**2);
		$seconds -= ($hours*60**2);
	}
	if ($seconds > 60){
		$minutes = int($seconds/60);
		$seconds -= ($minutes*60);
	}
	$cents = sprintf("%.2f",($seconds - int($seconds)));
	if ($hours){
		$minutes = sprintf("%02d",$minutes);
		$time = "$hours:";
	}
	$seconds = sprintf("%02d",int($seconds));
	$cents = sprintf("%02d",$cents*100);
	$time .= "$minutes:$seconds.$cents";
	return $time;
}
# arg: 1 - full file path, returns array of file lines.
# 2 - 'strip': strip and clean data
# note: chomp has to chomp the entire action, not just <$fh>
sub reader {
	my ($file,$strip) = @_;
	open(my $fh, '<', $file) or error_handler('open', $file, $!);
	chomp(my @rows = <$fh>);
	if ($strip && @rows){
		@rows = grep {!/^\s*#|^\s*$/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	return @rows;
}
# returns either printed source, or in case of ., return full path
sub sourcer {
	($_[0] eq '.') ? Cwd::getcwd() : $_[0];
}
sub trimmer {
	my ($str) = @_;
	$str =~ s/^\s+|\s+$//g; 
	return $str;
}

sub unescape_item {
	my ($file) = @_;
	$file =~ s/\\\"/"/g;
	$file =~ s/\\\`/`/g;
	$file =~ s/\\\$/\$/g;
	return $file;
}
# NOTE: File::Find will not follow symbolic links
sub wanted {
	state @pruned;
	state $b_first;
	return if -l; # skip symbolic links
	# https://www.perlmonks.org/?node_id=358502 more on prune and exclude diretortories
	# make test more general, only prune from results when actually not readable
	# since on rare occasions, the non readable file might be a file, not a directory, 
	# no test for -d
	# if ($File::Find::name =~ m/\Qlost+found\E/){
	# say $File::Find::name;
	# run the recursion level tests
	if (-d $File::Find::name){
		my $b_skip = 0;
		if ($recurse > -1){
			my $working = $File::Find::name;
			$working =~ s|^\Q$SOURCE_DIRECTORY\E$path_separator?||;
			# my $count = $working =~ tr/$path_separator//;
			my $count = scalar(split (m|$path_separator|, $working));
			$b_skip = 1 if $count > $recurse;
			# say "$working :: $path_separator :: re: $recurse c: $count";
		}
		if (! -r $File::Find::name || $b_skip){
			if (! grep { $_ eq $File::Find::name } @pruned){
				say $line_small if !$b_first;
				$b_first = 1;
				my $message = ($b_skip) ? 'recursion': 'unreadable';
				say "SKIPPING ($message):\n $File::Find::name";
				# say $line_small;
				push @pruned, $File::Find::name;
			}
			$File::Find::prune = 1;
			return;
		}
	}
	if ($list_type eq 'dir' || $list_type eq 'file'){
		return if $list_type eq 'dir' && ! -d; # skip files
		return if $list_type eq 'file' &&  -d; # skip directories
		return if $File::Find::name =~ m/^\Q$DESTINATION_DIRECTORY\E/;
		# skip any dot files/directories
		if (!$run{'dot'} && $File::Find::name =~ m/\/\./){
			$File::Find::prune = 1;
			return; 
		}
		# handle excludes
		if ($run{'sync'} && (
		 (@excludes && (grep {$File::Find::name =~ /\Q$_\E/} @excludes)) ||
		 ($list_type eq 'dir' && @excludes_stripped && 
		 (grep {$File::Find::name =~ /\Q$_\E$/} @excludes_stripped)))
		){
			$File::Find::prune = 1;
			return;
		}
		if ($list_type eq 'file'){
			# extension can be either a full file name, or extension
			return if $File::Find::name !~ /(\.|\/)$extension$/i;
		}
	}
	elsif ($list_type eq 'dir-clean' || $list_type eq 'file-clean'){
		return if $list_type eq 'dir-clean' && ! -d; # skip files
		return if $list_type eq 'file-clean' &&  -d; # skip directories
		my $working = $File::Find::name;
		$working =~ s|^\Q$DESTINATION_DIRECTORY\E|$SOURCE_DIRECTORY|;
		# we want to exclude files that are themselves contained in a sym linked directory
		if ($list_type eq 'file-clean'){
			return if -l File::Basename::dirname($working);
		}
		$working =~ s/\.$OUTPUT_TYPE$/\.$INPUT_TYPE/i if $list_type eq 'file-clean';
		# say '1: ', "$File::Find::name\n$working";
		# return if: 1. file/directory not found in destination 
		# 2. string in exclude array found in destination path
		# 3. if directory and  string found at end of path after trimming off trailing slash.
		# NOTE: if we modify $_, that modification goes back into the array, who would have thunk?
		return unless ! -e $working || (@excludes && 
		(grep {$File::Find::name =~ /\Q$_\E/} @excludes) ||
		($list_type eq 'dir-clean' && @excludes_stripped &&
		(grep {$File::Find::name =~ /\Q$_\E$/} @excludes_stripped)));
		# say '2: ', "$File::Find::name"; print "$_ ::";
	}
	# say $File::Find::name;
	push (@found_list, $File::Find::name);
	return;
}

# arg: 1 file full  path to write to; 2 - arrayof data to write. 
# note: turning off strict refs so we can pass it a scalar or an array reference.
sub writer {
	my ($path, $ref_content) = @_;
	my ($content);
	no strict 'refs';
	# say Dumper $ref_content;
	if (ref $ref_content eq 'ARRAY'){
		$content = join "\n", @$ref_content or die "failed with error $!";
	}
	else {
		$content = scalar $ref_content;
	}
	open(my $fh, ">", $path) or 
	 error_handler('open',"$path failed to open for writing.\nMessage: $!",1);
	print $fh $content;
	close $fh;
}

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------

## SelfUpdater
{
package SelfUpdater;
my $self_source = "$SELF_DIRECTORY$path_separator$self_name";
my $man_source = "$MAN_DIRECTORY$path_separator$self_name.1";

sub update {
	say $line_large;
	say "Starting $self_name self updater.";
	validate();
	grab();
	say "Completed self updates.";
	say $line_large;
	exit 0;
}
sub grab {
	my ($cmd,@content);
	say "Downloading $self_name.";
	$cmd = "$COMMAND_CURL -L https:/smxi.org/acxi";
	say $line_small;
	@content = qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Self update error: curl returns: $?.",1);
	}
	chomp(@content);
	say $line_small;
	print "Verifying $self_name data... ";
	if (! grep {/###\*\*EOF\*\*###/} @content){
		main::error_handler('self-updater',"Self update error: Download data corrupted.",1);
	}
	else {
		print "Verified.\nWriting to $self_name location... ";
		main::writer($self_source,\@content);
		say 'File updated';
	}
	say "Downloading $self_name.1 man page.";
	$cmd = "$COMMAND_CURL -L https:/smxi.org/acxi.1";
	say $line_small;
	@content = qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Man update error: curl returns: $?.",1);
	}
	chomp(@content);
	say $line_small;
	print "Verifying $self_name.1 data... ";
	if (! grep {/\Qis a fork and full rewrite of flac2ogg.pl.\E/} @content){
		main::error_handler('self-updater',"Man update error: Download data corrupted.",1);
	}
	else {
		print "Verified.\nWriting to $self_name.1 location... ";
		main::writer($man_source,\@content);
		say 'File updated';
	}
}
sub validate {
	print 'Validating data... ';
	if (!$ALLOW_UPDATES){
		main::error_handler('self-updater',"Self Updater has been disabled by package maintainer.",1);
	}
	if (!-e $self_source){
		main::error_handler('self-updater',"Only updating $self_name at $self_source supported.",1);
	}
	if (!-e $man_source){
		main::error_handler('self-updater',"Only updating man at $man_source supported.",1);
	}
	if (!-x $COMMAND_CURL){
		main::error_handler('self-updater',"Downloader: $COMMAND_CURL missing or not executable.",1);
	}
	if (!-w $self_source){
		main::error_handler('self-updater',"$self_source is not writeable. Need superuser rights?",1);
	}
	if (!-w $man_source){
		main::error_handler('self-updater',"$man_source is not writeable. Need superuser rights?.",1);
	}
	say 'Valid';
}
}

#### -------------------------------------------------------------------
#### VALIDATION - ERROR HANDLING
#### -------------------------------------------------------------------

## Args: 1: error id; 2: error message; 3: extt 0/1 [f/t]
sub error_handler {
	my ($error,$message,$b_exit) = @_;
	my ($br,$error_text) = ("\n",'');
	state $b_valid = 1;
	state $error_no = 0;
	# validation error block:
	if ($error eq 'unsupported-type'){$error_no = 2;$b_valid=0;}
	elsif ($error eq 'dest-dir'){$error_no = 1;$b_valid=0;}
	elsif ($error eq 'dest-eq-src-dir'){$error_no = 9;$b_valid=0;$br=''}
	elsif ($error eq 'missing-app'){$error_no = 3;$b_valid=0;}
	elsif ($error eq 'quality-invalid'){$error_no = 4;$b_valid=0;}
	elsif ($error eq 'bad-level'){$error_no = 5;$b_valid=0;}
	elsif ($error eq 'bad-fork'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-nlink'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-resample'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-exclude-file'){$error_no = 19;$b_valid=0;}
	elsif ($error eq 'prefill-error'){$error_no = 32;$b_valid=0;}
	# end validation error block
	elsif ($error eq 'self-updater'){$error_no = 17;}
	elsif ($error eq 'open'){$error_no = 14;}
	elsif ($error eq 'file-exists'){$error_no = 16;}
	elsif ($error eq 'file-missing'){$error_no = 15;}
	elsif ($error eq 'stat-infile'){$error_no = 6;}
	elsif ($error eq 'missing-arg'){$error_no = 7;
		$message = "Option: $message";$br=''}
	elsif ($error eq 'application-error'){$error_no = 11;}
	elsif ($error eq 'checksum-delete'){$error_no = 12;}
	elsif ($error eq 'invalid-options'){$error_no = 13;$br=''}
	elsif ($error eq 'unsupported-option'){$error_no = 8;$br=''}
	elsif ($error eq 'autotag-multi'){$error_no = 18;}
	elsif ($error eq 'track-counts'){$error_no = 30;}
	elsif ($error eq 'analyze'){$error_no = 31;}
	if ($error eq 'validation-errors'){
		if (!$b_valid){
			$message = "${br}Failed pretests. Please correct the listed errors.";
		}
		else {
			$message = "Pretests passed. Continuing." if $VERBOSITY > 0;
			$b_exit = 0;
		}
	}
	else {
		$message = "${br}Error $error_no: $message";
	}
	say "$message" if $message;
	exit $error_no if $b_exit;
}

## Validation 
{
package Validation;
my ($b_valid_in_out);
sub run {
	start_text();
	check_src_dest_directories();
	check_in_out_types();
	if ($b_valid_in_out){
		check_quality() if $b_check_out;
		check_application_paths();
	}
	check_codecs();
	check_excludes();
	check_fork();
	check_resample() if $run{'resample'};
	check_nlink();
	check_verbosity();
	main::error_handler('validation-errors', '',1);
}
sub start_text {
	if ($VERBOSITY > 0){
		eval $print_line_heavy;
		say "Running $self_name pretests.";
	}
}
sub check_application_paths {
	my ($b_error,$error_message) = (0,'');
	my @app_paths; 
	if ($VERBOSITY > 0){
		print main::dotify("Checking required tools paths");
	}
	if ($b_check_out){
		if ($OUTPUT_TYPE =~ /^(aac|flac|m4a)$/){
			if (!grep {$_ eq $COMMAND_FFMPEG} @app_paths){
				push(@app_paths,$COMMAND_FFMPEG);
			}
			if (! -x "$COMMAND_FFMPEG"){
				$b_error = 1;
				$error_message .= "\n Encoding application not available: $COMMAND_FFMPEG";
			}
		}
		elsif ($OUTPUT_TYPE eq 'ogg' || $OUTPUT_TYPE eq 'opus'){
			if (!$run{'ffmpeg'}){
				if ($OUTPUT_TYPE eq 'ogg'){
					if (!grep {$_ eq $COMMAND_OGG} @app_paths){
						push(@app_paths,$COMMAND_OGG);
					}
					if (! -x "$COMMAND_OGG"){
						$b_error = 1;
						$error_message .= "\n Encoding application not available: $COMMAND_OGG";
					}
				}
				elsif ($OUTPUT_TYPE eq 'opus'){
					if (!grep {$_ eq $COMMAND_OPUS} @app_paths){
						push(@app_paths,$COMMAND_OPUS);
					}
					if (!$run{'ffmpeg'}){
						if (! -x "$COMMAND_OPUS"){
							$b_error = 1;
							$error_message .= "\n Encoding application not available: $COMMAND_OPUS";
						}
					}
				}
			}
			else {
				if (!grep {$_ eq $COMMAND_FFMPEG} @app_paths){
					push(@app_paths,$COMMAND_FFMPEG);
				}
				if (! -x "$COMMAND_FFMPEG"){
					$b_error = 1;
					$error_message .= "\n Encoding application not available: $COMMAND_FFMPEG";
				}
			}
		}
		elsif ($OUTPUT_TYPE eq 'mp3'){
			if (!grep {$_ eq $COMMAND_LAME} @app_paths){
				push(@app_paths,$COMMAND_LAME);
			}
			if (! -x "$COMMAND_LAME"){
				$b_error = 1;
				$error_message .= "\n Encoding application not available: $COMMAND_LAME";
			}
			if (!grep {$_ eq $COMMAND_FLAC} @app_paths){
				push(@app_paths,$COMMAND_FLAC);
			}
			if (! -x "$COMMAND_FLAC"){
				$b_error = 1;
				$error_message .= "\n Input processor $COMMAND_FLAC needed by lame ";
				$error_message .= "not available.";
			}
			if (!grep {$_ eq $COMMAND_METAFLAC} @app_paths){
				push(@app_paths,$COMMAND_METAFLAC);
			}
			# Added: Odd @2011-03-23 01:55:28
			if (! -x "$COMMAND_METAFLAC"){
				$b_error = 1;
				$error_message .= "\n $COMMAND_METAFLAC not found. Required to copy ";
				$error_message .= "ID3 tags from Flac to MP3.";
			}
		}
	}
	else {
		# Note: -AK but not -AV
		if ($run{'checksum'} || $run{'checksum-verify'}){
			if (!$run{'no-md5'}){
				if (!grep {$_ eq $COMMAND_MD5} @app_paths){
					push(@app_paths,$COMMAND_MD5);
				}
				# Added: Odd @2011-03-23 01:55:28
				if (! -x "$COMMAND_MD5"){
					$b_error = 1;
					$error_message .= "\n $COMMAND_MD5 not found. Required to generate ";
					$error_message .= "md5 checksum files.";
				}
			}
			if ($run{'checksum'} && !$run{'no-ffp'}){
				if (!grep {$_ eq $COMMAND_METAFLAC} @app_paths){
					push(@app_paths,$COMMAND_METAFLAC);
				}
				# Added: Odd @2011-03-23 01:55:28
				if (! -x "$COMMAND_METAFLAC"){
					$b_error = 1;
					$error_message .= "\n $COMMAND_METAFLAC not found. Required to generate ";
					$error_message .= "ffp checksum files.";
				}
			}
			if ($run{'checksum-verify'} && !$run{'no-ffp'}){
				if (!grep {$_ eq $COMMAND_FLAC} @app_paths){
					push(@app_paths,$COMMAND_FLAC);
				}
				if (! -x "$COMMAND_FLAC"){
					$b_error = 1;
					$error_message .= "\n $COMMAND_FLAC not found. Required to verify ";
					$error_message .= "$INPUT_TYPE files.";
				}
			}
		}
		if ($run{'autotag'}){
			if (!grep {$_ eq $COMMAND_METAFLAC} @app_paths){
				push(@app_paths,$COMMAND_METAFLAC);
			}
			# Added: Odd @2011-03-23 01:55:28
			if (! -x "$COMMAND_METAFLAC"){
				$b_error = 1;
				$error_message .= "\n $COMMAND_METAFLAC not found. Required auto-tag ";
				$error_message .= "operations.";
			}
		}
		if ($run{'infofix-quality'} || $run{'analyze'}){
			if (!grep {$_ eq $COMMAND_METAFLAC} @app_paths){
				push(@app_paths,$COMMAND_METAFLAC);
			}
			# Added: Odd @2011-03-23 01:55:28
			if (! -x "$COMMAND_METAFLAC"){
				$b_error = 1;
				$error_message .= "\n $COMMAND_METAFLAC not found. Required for ";
				$error_message .= "analyzing $INPUT_TYPE files.";
			}
		}
		if ($run{'infofix-title'} || $run{'infofix-upper'}){
			if (!grep {$_ eq 'Module Text::Autoformat'} @app_paths){
				push(@app_paths,'Module Text::Autoformat');
			}
			if (!main::check_module('Text::Autoformat')){
				$b_error = 1;
				$error_message .= "\n Perl module Text::Autoformat not found. Required ";
				$error_message .= "for -Xt / -Xu.";
			}
			else {
				import Text::Autoformat;
			}
		}
	}
	if ($b_error){
		main::error_handler('missing-app',$error_message,0);
	}
	elsif ($VERBOSITY > 0){
		my ($join,$joiner) = ($VERBOSITY > 1) ? ("\n ","\n "): (' ','; ');
		say "Available:$join" .  join($joiner,@app_paths);
	}
}
sub check_codecs {
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		eval $print_line_large;
		print main::dotify("Checking codecs");
	}
	if ($codec && $OUTPUT_TYPE !~ /^(aac|m4a)$/i){
		$b_error = 1;
		$error_message .= "--codec only is supported for output types aac/m4a.\n";
	}
	if ($OUTPUT_TYPE =~ /^(aac|m4a)$/i){
		if (!$codec){
			$codec = $CODEC_AAC;
		}
		if (!$codec || ($codec && $codec !~ /^(libfdk_aac|aac)$/)){
			$b_error = 1;
			$error_message .= "Only libfdk_aac or aac codecs supported for $OUTPUT_TYPE.\n";
		}
	}
	if ($b_error){
		main::error_handler('unsupported-type',$error_message,0);
	}
	else {
		if ($VERBOSITY > 0){
			say 'Valid';
		}
	}
}
sub check_excludes {
	my ($b_error,$error_message) = (0,'');
	if ($EXCLUDE){
		if ($VERBOSITY > 0){
			print main::dotify("Checking EXCLUDE data");
		}
		if ($EXCLUDE =~ /\Q$EXCLUDE_BASE\E/){
			if (! -e $EXCLUDE){
				$b_error = 1;
				$error_message .= "\n You must provide a valid exclude file path. ";
				$error_message .= "You used: $EXCLUDE";
			}
		}
		else {
			if ($EXCLUDE =~ /\Q^^^^\E/ || $EXCLUDE =~ /\Q^^\E$/){
				$b_error = 1;
				$error_message .= "\n You have an empty value in your EXCLUDE data. ";
				$error_message .= "You used: $EXCLUDE";
			}
		}
		if ($b_error){
			main::error_handler('bad-exclude-file',$error_message,0);
		}
		elsif ($VERBOSITY > 0){
			say "Supported: $FORK";
		}
	}
}
sub check_fork {
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		print main::dotify("Checking FORK value");
	}
	if ($FORK !~ m/^[0-9]+$/){
		$b_error = 1;
		$error_message .= "\n FORK requires value: 0 or more. ";
		$error_message .= "You used: $FORK";
	}
	# note: tests show fork == 1 slower than no forking!!
	if (!$b_error && $FORK > 0){
		if (!main::check_module('Parallel::ForkManager')){
			$b_error = 1;
			$error_message .= "\n Perl module Parallel::ForkManager not found. Required ";
			$error_message .= "for --fork / -F.";
		}
		else {
			import Parallel::ForkManager;
			$b_fork = 1;
		}
	}
	if ($b_error){
		main::error_handler('bad-fork',$error_message,0);
	}
	elsif ($VERBOSITY > 0){
		say "Supported: $FORK";
	}
}
sub check_in_out_types {
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		eval $print_line_large;
		print main::dotify("Checking input and output types");
	}
	if ($run{'ffmpeg'} && ($INPUT_TYPE !~ /^(flac)$/ || $OUTPUT_TYPE !~ m/^(flac|ogg|opus)$/i)){
		$b_error = 1;
		$error_message .= "\n The --ffmpeg input/output type combination you entered is not supported: ";
		$error_message .= "in: $INPUT_TYPE out: $OUTPUT_TYPE";
	}
	if ($INPUT_TYPE !~ m/^(aiff?|flac|mp3|raw|shn|wav)$/i){
		$b_error = 1;
		$error_message .= "\n The input type you entered is not supported: ";
		$error_message .= "$INPUT_TYPE";
	}
	if (($run{'checksum'} || $run{'checksum-verify'} || $run{'autotag'} || 
	 $run{'analyze'} || $run{'info-quality'} || $run{'resample'}) && 
	 $INPUT_TYPE !~ m/^(flac)$/i){
		$b_error = 1;
		$error_message .= "\n The input type you entered is not supported for ";
		$error_message .= "\n analyze/checksum/resample/tagging operations: ";
		$error_message .= "$INPUT_TYPE";
	}
	if ($b_check_out){
		if ($OUTPUT_TYPE !~ m/^(aac|flac|m4a|mp3|ogg|opus)$/i){
			$b_error = 1;
			$error_message .= "\n  The output type you entered is not supported: ";
			$error_message .= "$OUTPUT_TYPE";
		}
		if ($OUTPUT_TYPE =~ /^(m4a|mp3|aac)$/i && $INPUT_TYPE ne lc('flac')){
			$b_error = 1;
			$error_message .= "\n The output type $OUTPUT_TYPE you entered ";
			$error_message .= "only supports input type: flac";
		}
		if (($run{'resample'} || $INPUT_TYPE =~ m/^(aac|aiff?|m4a|mp3|raw|shn)$/i) &&
		 $OUTPUT_TYPE ne lc('flac')){
			$b_error = 1;
			$error_message .= "\n The input type $INPUT_TYPE you entered ";
			$error_message .= "only supports output type: flac";
		}
	}
	if ($b_error){
		main::error_handler('unsupported-type',$error_message,0);
	}
	else {
		$b_valid_in_out = 1;
		if ($VERBOSITY > 0){
			say "Valid: $INPUT_TYPE(in) $OUTPUT_TYPE(out)";
		}
	}
}
sub check_nlink {
	my ($b_error,$error_message) = (0,'');
	if (defined $DONT_USE_NLINK && $DONT_USE_NLINK ne '0'){
		if ($VERBOSITY > 0){
			print main::dotify("Checking DONT_USE_NLINK value");
		}
		if ($DONT_USE_NLINK !~ m/^[01]$/){
			$b_error = 1;
			$error_message .= "\n DONT_USE_NLINK only supports 0-1. ";
			$error_message .= "You used: $DONT_USE_NLINK";
		}
		if ($b_error){
			main::error_handler('bad-nlink',$error_message,0);
		}
		elsif ($VERBOSITY > 0){
			say "Supported: $DONT_USE_NLINK";
		}
	}
}
sub check_quality{
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		print main::dotify("Checking quality support for $OUTPUT_TYPE");
	}
	## NOTE: this is not used
	if (lc($OUTPUT_TYPE) eq 'flac'){
		if ($QUALITY_FLAC !~ m/^[0-8]$/){
			$b_error = 1;
			$error_message .= "\n $OUTPUT_TYPE only supports ";
			$error_message .= "0 to 8 quality levels. You entered: $QUALITY_FLAC";
		}
		else {
			$quality = $QUALITY_FLAC;
		}
	}
	if (lc($OUTPUT_TYPE) eq 'ogg'){
		if ($QUALITY_OGG !~ m/^-?[0-9]+(\.[0-9]+)?$/ || 
		 $QUALITY_OGG < -1 || $QUALITY_OGG > 10){
			$b_error = 1;
			$error_message .= "\n $OUTPUT_TYPE only supports ";
			$error_message .= "-1 to 10 quality levels. You entered: $QUALITY_OGG";
		}
		else {
			$quality = $QUALITY_OGG;
		}
	}
	if (lc($OUTPUT_TYPE) eq 'aac' || lc($OUTPUT_TYPE) eq 'm4a'){
		if ($QUALITY_AAC !~ m/^[0-9]+$/ || $QUALITY_AAC < 10 || $QUALITY_AAC > 500){
			$b_error = 1;
			$error_message .= "\n $OUTPUT_TYPE only supports ";
			$error_message .= "10 to 500 quality levels. You entered: $QUALITY_AAC";
		}
		else {
			$quality = $QUALITY_AAC;
		}
	}
	# supports fractional quality levels
	elsif (lc($OUTPUT_TYPE) eq 'opus'){
		if ($QUALITY_OPUS !~ m/^[0-9]+$/ || $QUALITY_OPUS < 6|| $QUALITY_OPUS > 256){
			$b_error = 1;
			$error_message .= "\n $OUTPUT_TYPE only supports ";
			$error_message .= "6 to 256 bitrate quality levels. You entered: $QUALITY_OPUS";
		}
		else {
			$quality = $QUALITY_OPUS;
		}
	}
	elsif (lc($OUTPUT_TYPE) eq 'mp3'){
		if ($QUALITY_MP3 !~ m/^[0-9]$/){
			$b_error = 1;
			$error_message .= "\n $OUTPUT_TYPE only supports 0-9 quality levels. ";
			$error_message .= "You entered: $QUALITY_MP3";
		}
		else {
			$quality = $QUALITY_MP3;
		}
	}
	if ($b_error){
		main::error_handler('quality-invalid',$error_message,0);
	}
	elsif ($VERBOSITY > 0){
		say "Supported: $quality ($OUTPUT_TYPE)";
	}
}
# check only runs if $run{'resample'} loaded
sub check_resample {
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		eval $print_line_large;
		print main::dotify("Checking resample values");
	}
	if (!$run{'resample-override'}) {
		if ($run{'resample'}->[0] !~ /(16|20|24)/ || 
		 $run{'resample'}->[1] !~ /(44\.1|48|88\.2|96|192)/){
			$b_error = 1;
			$error_message = 'Invalid resample values. Supported bit depths: 16/20/24; ';
			$error_message .= "\n sample rates: 44.1/48/88.2/96/192";
		}
	}
	else{
		if (($run{'resample'}->[0] < 4 || $run{'resample'}->[0] > 32) || 
		 ($run{'resample'}->[1] < 1 || $run{'resample'}->[1] > 655)){
			$b_error = 1;
			$error_message = 'Invalid resample values. Supported bit depths: 4-32; ';
			$error_message .= "\n sample rates: 1-655khz";
		}
	}
	if ($b_error){
		main::error_handler('bad-resample',$error_message,0);
	}
	else {
		if ($VERBOSITY > 0){
			my $info = 'Valid: ' . $run{'resample'}->[0];
			$info .= ':' .  $run{'resample'}->[1];
			say $info;
		}
		# ffmpeg uses the raw hz values, not khz
		$run{'resample'}->[1] = $run{'resample'}->[1] * 1000;
	}
}
sub check_src_dest_directories {
	my $missing_dirs = '';
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		eval $print_line_large;
		print main::dotify("Checking source / destination directories");
	}
	if (! -d $SOURCE_DIRECTORY){
		$b_error = 1;
		$missing_dirs .= "\n Source Directory: $SOURCE_DIRECTORY";
	}
	if ($b_check_dest && ! -d $DESTINATION_DIRECTORY){
		$b_error = 1;
		$missing_dirs .= "\n Destination Directory: $DESTINATION_DIRECTORY";
	}
	if ($b_error){
		my $error_message = "The paths for the following directories are missing:";
		$error_message .= "$missing_dirs";
		$error_message .= "\nPlease check the directory paths you provided.";
		main::error_handler('dest-dir',$error_message,0);
	} 
	elsif ($VERBOSITY > 0){
		say 'Directories: exist';
	}
	if ($b_check_dest && !$b_error && $DESTINATION_DIRECTORY eq $SOURCE_DIRECTORY){
		$error_message = "Destination directory cannot be same as Source directory!";
		main::error_handler('dest-eq-src-dir',$error_message,0);
	}
	if ($run{'prefill'} && 
	 !(main::globber("$SOURCE_DIRECTORY${path_separator}*.$INPUT_TYPE"))){
		my $error_message = "The --prefill option can only be run on a directory ";
		$error_message .= "containing\n$INPUT_TYPE files. None found in: ";
		$error_message .= "$SOURCE_DIRECTORY";
		main::error_handler('prefill-error',$error_message,0);
	}
}
sub check_verbosity {
	my ($b_error,$error_message) = (0,'');
	if ($VERBOSITY > 0){
		print main::dotify("Checking verbosity output level");
	}
	if ($VERBOSITY !~ m/^([0-4])$/){
		$b_error = 1;
		$error_message .= "\n VERBOSITY only supports 0-4. ";
		$error_message .= "You used: $VERBOSITY";
	}
	if ($b_error){
		main::error_handler('bad-level',$error_message,0);
	}
	elsif ($VERBOSITY > 0){
		say "Supported: $VERBOSITY";
	}
}
# end Validation
}

#### -------------------------------------------------------------------
#### HELP/VERSION/MESSAGES
#### -------------------------------------------------------------------
sub print_completion_message {
	eval $print_line_heavy;
	if ($b_dest_changed){
		if ($VERBOSITY > 1){
			say 'All done updating. Enjoy your music!';
		}
		elsif ($VERBOSITY > 0){
			say "\nUpdating completed. Enjoy your music!";
		}
	}
	elsif ($VERBOSITY > 0){
		say "\nThere was nothing to update today in your collection.";
	}
	exit 0;
}

sub print_not_found {
	my ($message,$none);
	if ($_[0] eq 'files'){
		$message = "No files to update of type: $extension";
		$none = "None to update";
	}
	elsif ($_[0] eq 'extension'){
		$message = "No files found of type: $extension";
		$none = "None found";
	}
	elsif ($_[0] eq 'dirs'){
		$message = 'No new directories required. Continuing...';
		$none = "None required";
	}
	elsif ($_[0] eq 'directory-cleaned'){
		$message = 'No directories to remove. Continuing...';
		$none = "None to remove\n";
	}
	elsif ($_[0] eq 'file-cleaned'){
		$message = 'No files to remove. Continuing...';
		$none = "None to remove\n";
	}
	if ($VERBOSITY > 1){
		say $message;
	}
	elsif ($VERBOSITY > 0){
		print $none;
	}
}

sub show_options {
	# so it shows the user config data if present
	UserConfigs::set(); 
	# but this should override the config data so follows
	set_basic_data();
	my $output = "$self_name v: $self_version :: Supported Options:\n";
	$output .= "Examples: $self_name -q 8 --destination /music/main/ogg\n";
	$output .= "$self_name --input flac --output ogg -a md5\n";
	$output .= "$self_name --copy doc,docx,bmp\n";
	$output .= $line_small . "\n";
	$output .= "Syncing options:\n";
	$output .= "--append, -a      Add extension type(s) to existing extension copy list.\n";
	$output .= "                  1 or more, comma separated, no spaces.\n";
	$output .= "--clean           Clean directories and files from destination not found in\n";
	$output .= "                  source music directory. Will show you directories/files to\n";
	$output .= "                  be deleted then ask you to confirm (twice) that you want to\n";
	$output .= "                  remove that set of files or directories. Exits at end.\n";
	$output .= "                  optional value 'sync' is used: --clean sync\n";
	$output .= "--codec           {libfdk-aac|aac} - if you want to use alternate codec.\n";
	$output .= "                  Output -o aac/m4a only\n";
	$output .= "--copy, -c        List of alternate data types to copy to Output type\n";
	$output .= "                  directories. Comma separated, no spaces. See sample above.\n";
	$output .= "                  Current copy types: ";
	$output .= (length(join(' ',@extension_list))>40) ? "\n                  " : '';
	$output .= "@extension_list\n";
	$output .= "--destination, -d Path to the directory where you want the processed\n";
	$output .= "                  (eg, ogg) files to go.\n";
	$output .= "                  Current value: $DESTINATION_DIRECTORY\n";
	$output .= "--exclude, -x     Exclude a list of unique strings separated by ^^. Excludes\n";
	$output .= "                  sync/copy action to destination directory. Replaces\n";
	$output .= "                  \$EXCLUDE values if present. Anything matching in file path\n";
	$output .= "                  will be excluded. Can also be path to a file of excludes.\n";
	$output .= "                  Sample: --exclude='artwork^^Daisy Queen^^Bon Jovi'\n";
	$output .= "                  Sample: --exclude='/home/me/music/excludes/$EXCLUDE_BASE.txt\n";
	$output .= "--exclude-append, -y\n";
	$output .= "                  Append an item to the list of excludes or file.\n";
	$output .= "                  Sample: --exclude-append='My Sharona^^Dancing Queen'\n";
	$output .= "--ffmpeg          Force flac to ogg/opus conversions to use ffmpeg. Useful if\n";
	$output .= "                  you want to include embedded images to oggs (Experimental).\n";
	$output .= "--force, -f       Force overwrite the mp3/ogg/opus/jpg/txt/etc. files, even\n"; 
	$output .= "                  if they already exist.\n";
	$output .= "--fork, -F        [0-x] - Number of forks/threads to use. 0 default, disables.\n";
	$output .= "                  Requires Perl module: Parallel::ForkManager. Current: $FORK\n";
	$output .= "--input, -i       Input type: {aif,flac,raw,shn,wav}. shn requires codec\n";
	$output .= "                  shorten. raw,shn only output to flac. Current value: $INPUT_TYPE\n";
	$output .= "--output, -o      Output type: {aac, flac. m4a, mp3, ogg, opus. aac/m4a/mp3}\n";
	$output .= "                  require input type flac. To preserve flac tags for aac, use\n";
	$output .= "                  m4a. Current value: $OUTPUT_TYPE\n";
	$output .= "--quality, -q {n} Qualities for output types:\n";
	$output .= "                  flac: n between 0 and 8. 8 best, but > 4 generally pointless.\n";
	$output .= "                  aac/m4a: n between 10 and 500. 500 best quality.\n";           
	$output .= "                  ogg: n between -1 and 10. Fractions ok. 10 best quality.\n";
	$output .= "                  opus: n between 6-256. Variable bit rate. 256 best quality.\n";
	$output .= "                  mp3: n between 0-9. Variable bit rate, 0 best quality.\n";
	$output .= "                  Current values: $QUALITY_AAC (aac/m4a); $QUALITY_MP3 (mp3); \n";
	$output .= "                  $QUALITY_OGG (ogg); $QUALITY_OPUS (opus)\n";
	$output .= "--resample        {bit depth:sample rate khz} - Supports bit depth 16|20|24 and\n";
	$output .= "                  sample rates 44.1|48|88.2|96|192. Read manual for more info.\n";
	$output .= "                  Example --resample 16:48\n";
	$output .= "--resample-override\n";
	$output .= "                  Allows all supported flac resampling values: 2-32 bit depths;\n";
	$output .= "                  1-655 khz sampling rates (decimals ok).\n";
	$output .= "--source, -s      Path to the top-most directory containing your source files.\n";
	$output .= "                  Current value: $SOURCE_DIRECTORY\n";
	$output .= "--source-glob, -g {Path inside -s directory with wildcards}\n";
	$output .= "                  Wildcard path, using *, paths relative to -s path.\n";
	$output .= "                  Allows work on only a subset of directories in -s path.\n";
	$output .= $line_small . "\n";
	$output .= "Specialized options (tagging, checksums, prefills, etc):\n";
	$output .= "--aggregate, -G   [filename|extension] Copy file name or extension type to\n";
	$output .= "                  --destination directory. If no argument given, copies over\n";
	$output .= "                  $TAG_FILE. Do not use . in extension (jpg good, .jpg bad)\n";
	$output .= "                  You can supply more than one filename or extension:\n";
	$output .= "                  (file name): acxi -d ~/music/cdinfo --aggregate info.txt\n";
	$output .= "                  (extension): acxi -d ~/music/cdinfo --aggregate jpg\n";
	$output .= "                  (several): acxi -d ~/music/cdinfo --aggregate png,jpg,info.txt\n";
	$output .= "--analyze, -Z     Analyze contents of directories, creates screen report per\n";
	$output .= "                  file/directory. Currently only supports flac. Shows total\n";
	$output .= "                  time, size, ffp avg kbs, etc. Similar to -Xq but prints to\n";
	$output .= "                  screen. -v2 adds ffp,changes to 1 key:value pair per line,\n";
	$output .= "                  -v 3 adds precision.\n";
	$output .= "--autotag, -A     Requires auto.tag formatted file in each directory. Flac only.\n";
	$output .= "                  Deletes all existing tags, then creates a fully tagged set of\n";
	$output .= "                  files.\n";
	$output .= "--autotag-create, -C\n";
	$output .= "                  Create $TAG_FILE template in source directory. Will be\n";
	$output .= "                  populated with file names for recording filled in already in\n";
	$output .= "                  track listing. Preserves existing REPLAYGAIN values. Not\n";
	$output .= "                  recommended, use -S or -M instead.\n";
	$output .= "--autotag-create-multi, -M {disc ID}\n";
	$output .= "                  Required argument tells logic how to determine your disc\n";
	$output .= "                  numbering method. % is used to indicate the value is a number\n";
	$output .= "                  between 1-9. @ is used to indicate a letter between A-Z. \n";
	$output .= "                  Will complete TRACKTOTAL, DISCNUMBER, TRACKNUMBER values\n";
	$output .= "                  in auto.tag file, which saves a time. See -E for more prefill\n";
	$output .= "                  options.\n";
	$output .= "                  Samples: -M d% [d1track02.flac]; -M d\%- [d2-track04.flac];\n";
	$output .= "                  -M % [112.flac]; -M 2015-03-21.d%. [2015-03-21.d1.t03.flac]\n";
	$output .= "                  -M @ [A12.flac]; -M d\@- [da-track02.flac];\n";
	$output .= "                  Flac input type only.\n";
	$output .= "--autotag-create-single, -S\n";
	$output .= "                  For single disc recordings, will also add TRACKTOTAL and\n";
	$output .= "                  TRACKNUMBER counts when creating and populating the\n";
	$output .= "                  $TAG_FILE file. See -E for more prefill options.\n";
	$output .= "--checksum, -K    Create .ffp and .md5 checksum files in your source directory.\n";
	$output .= "                  Checksum files are only created inside directories where flac\n";
	$output .= "                  files are found. Use --checksum-delete if you also want\n";
	$output .= "                  to delete existing checksum files. Only flac type\n";
	$output .= "                  is supported.\n";
	$output .= "                  Do not use together with cleaning/syncing options!\n";
	$output .= "--checksum-delete, -D\n";
	$output .= "                  Delete all existing .ffp, .md5, .ffp.txt, and md5.txt files\n";
	$output .= "                  before creating the new checksum files. Files only deleted in\n";
	$output .= "                  directories where flac files are found.\n";
	$output .= "--checksum-ffps, --ffps\n";
	$output .= "                  Prints only ffps to screen, turns off md5 tests\n";
	$output .= "--checksum-verify, -V\n";
	$output .= "                  Verifies FLAC files and confirms MD5 file data matches actual\n";
	$output .= "                  files found. Can be run alone or with --checksum options.\n";
	$output .= "--dot             Also sync files and directories starting with a '.'. Don't\n";
	$output .= "                  blame $self_name if this creates unintended consequences!!\n";
	$output .= "--duplicates, --dupes\n";
	$output .= "                  Test a directory of many releases for duplicated ffp files.\n";             
	$output .= "--image, -I {jpg,png image file name|remove}\n";
	$output .= "                  Embed image file into single recording directory. 'remove'\n";
	$output .= "                  value only removes images.\n";
	$output .= "--infofix, -X [dnqtuw]\n";
	$output .= "                  Fix info.txt files. Use any combination. Always cleans white\n";
	$output .= "                  space issues.\n";
	$output .= "                  d: make iso date: YYYY-MM-DD from various random date formats\n";
	$output .= "                  n: make track numbering 'NN. ' (0 padded) or 'N-NN. '\n";
	$output .= "                  q: add FLAC/Quality: /[quality] items to info file\n";
	$output .= "                  t: fix upper/lower case track titles\n";
	$output .= "                  u: fix entire file upper/lower\n";
	$output .= "                  w: write changes to file\n";
	$output .= "                  t and u use Title upper case main words.\n";
	$output .= "--info-rating {2-xxx}\n";
	$output .= "                  Change default rating value for --infofix q. Current: $INFO_RATING;\n";
	$output .= "--nlink           Set \$File::Find::dont_use_nlink = 0. Expert use only.\n";
	$output .= "--no-dot          Override user configuration setting for DOT (--dot) [default].\n";
	$output .= "--no-ffp          Skips ffp processing on --checksum or --checksum-verify.\n";
	$output .= "--no-md5          Skips md5 processing on --checksum or --checksum-verify.\n";
	$output .= "--no-nlink        Set \$File::Find::dont_use_nlink = 1 [default].\n";
	$output .= "                  Expert use only.\n";
	$output .= "--prefill, -E     Attempt to prefill auto.tag file using info.txt data. See man\n";
	$output .= "                  for required syntax and structure of data in info file.\n";
	$output .= "--prefill-file {file name}\n";
	$output .= "                  Alternate file name to use for --prefill.\n";
	$output .= "--no-replaygain   Does not preserve REPLAYGAIN values for autotag-create.\n";
	
	$output .= "--recurse {0-xx}  Set directory recursion levels. Default infinite. Useful\n";
	$output .= "                  for having syncing or checksum tools ignore sub directories.\n";
	$output .= "--remove-images, -R\n";
	$output .= "                  Remove all embedded images and image padding from file\n";
	$output .= "                  before autotagging.\n";
	$output .= "--remove-padding, -P\n";
	$output .= "                  For --autotag and --tag also removes block padding. Slows.\n";
	$output .= "                  tagging down significantly.\n";
	$output .= "--start {0-xx}    For auto.tag, starts tag numbering of tracks at supplied\n";
	$output .= "                  integer value. Useful if tracks start at 00.flac or 07.flac\n";
	$output .= "--tag, -T         {\"TAG1%:tag value^^TAG2%:tag value}\n";
	$output .= "                  Updates one or more recordings with the supplied FLAC\n";
	$output .= "                  tag/value pairs. Removes existing sets of the given type.\n";
	$output .= "                  Use ^^ to separate tag key/value pairs, and %: to separate\n";
	$output .= "                  the tag name and its value. Value 'UNSET' removes the tag.\n";
	if ($ALLOW_UPDATES){
		$output .= "--update, -U      Update $self_name and man page. Set paths if not Linux.\n";
		$output .= "                  Current values: $self_name: $SELF_DIRECTORY\n";
		$output .= "                  man $self_name.1: $MAN_DIRECTORY\n";
	}
	$output .= $line_small . "\n";
	$output .= "Display output and debugging options:\n";
	$output .= "--debug           Trigger advanced output debugging data.\n";
	$output .= "--help, -h        This help menu.\n";
	$output .= "--quiet           Turns off most screen output, except for error messages.\n";
	$output .= "                  Only disables screen output is logical to do so. Same as -v 0\n";
	$output .= "--test            Test copy, sync, autotag, checksum without actually doing\n";
	$output .= "                  the action.\n";
	$output .= "--version         Show $self_name version.\n";
	$output .= "--verbosity, -v   {0-3} Dynamically set VERBOSITY. Current value: $VERBOSITY\n";
	$output .= "                  0: Turns off all output, except for error messages.\n";
	$output .= "                  1: Basic single line per operation output, default value.\n";
	$output .= "                  2: Without full verbosity of -v3, no flac/lame/oggenc/opusenc\n";
	$output .= "                  for conversion process screen output.\n";
	$output .= "                  3: Full output, including full verbosity of ffmpeg/flac/\n";
	$output .= "                  lame/oggenc/opusenc conversion process for aac, m4a, mp3, ogg,\n";
	$output .= "                  or opus output.\n";
	$output .= $line_small . "\n";
	$output .= "User Configs ";
	if (!$CONFIG_DIRECTORY){
		$output .= "(checked in this order):\n/etc/$self_name.conf\n";
		$output .= "\$XDG_CONFIG_HOME/$self_name.conf\n";
		$output .= "\$HOME/.config/$self_name.conf\n";
		$output .= "\$HOME/.$self_name.conf\n";
	}
	else {
		$output .= "(manually set):\n$CONFIG_DIRECTORY/$self_name.conf\n";
	}
	$output .= "Requires this syntax (any user modifiable variable can be used)\n";
	$output .= "SOURCE_DIRECTORY=/home/me/music/flac\n";
	$output .= "DESTINATION_DIRECTORY=/home/me/music/opus\n";
	$output .= "Do not use \$, \", or \' in config options or values (except in path names).\n";
	say $output;
	exit 0;
}

sub show_version {
	say "$self_name version: $self_version ($self_date)";
	exit 0;
}

#### -------------------------------------------------------------------
#### SET RUNTIME VALUES
#### -------------------------------------------------------------------
sub set_basic_data {
	$start_dir = getcwd();
	# if --copy/-c is set, then use that data instead of default copy types
	if (defined $COPY_TYPES){
		@extension_list = split(/,\s*/, $COPY_TYPES);
	}
	$DESTINATION_DIRECTORY =~ s|$path_separator$||;
	$SOURCE_DIRECTORY =~ s|$path_separator$||;
	$CONFIG_DIRECTORY =~ s|$path_separator$|| if $CONFIG_DIRECTORY;
	$INPUT_TYPE = lc($INPUT_TYPE) if $INPUT_TYPE;
	$OUTPUT_TYPE = lc($OUTPUT_TYPE) if $OUTPUT_TYPE;
	@extension_list = (@extension_list,$INPUT_TYPE);
	$File::Find::dont_use_nlink = $DONT_USE_NLINK;
	if ($run{'source-glob'}){
		$run{'source-glob'} =~ s|$path_separator$||;
		# say $start_dir;
		chdir $SOURCE_DIRECTORY;
		my @temp = globber($run{'source-glob'});
		foreach (@temp){
			push(@source_glob,$SOURCE_DIRECTORY . $path_separator . $_);
		}
		# say Data::Dumper::Dumper \@source_glob;exit;
		chdir $start_dir;
	}
	else {
		push(@source_glob,$SOURCE_DIRECTORY);
	}
	if ($EXCLUDE){
		if ($EXCLUDE =~ /\Q$EXCLUDE_BASE\E/){
			@excludes = reader($EXCLUDE, 'strip');
		}
		else {
			@excludes = split /\Q^^\E/, $EXCLUDE;
		}
		if ($exclude_append){
			my @temp = split /\Q^^\E/, $exclude_append;
			@excludes = (@excludes,@temp);
		}
		@excludes_stripped = map { my $temp = $_;$temp =~ s|/$||;$temp} @excludes if @excludes;
		# say Data::Dumper::Dumper \@excludes;
		# say Data::Dumper::Dumper \@excludes_stripped;
	}
}

sub set_display_data {
	if ($VERBOSITY < 3){
		if ($OUTPUT_TYPE eq 'mp3'){
			$silent_flac = '--silent'; # flac output 
			$silent_lame = '--silent'; # lame output
		}
		elsif (!$run{'ffmpeg'} && $OUTPUT_TYPE eq 'ogg'){
			$silent_flac = '--quiet'; # for oggenc output
		}
		elsif ($OUTPUT_TYPE =~ /^(aac|m4a)$/){
			$silent_ffmpeg = '-v quiet'; # for ffmpeg output
		}
		elsif (($run{'ffmpeg'} && $OUTPUT_TYPE =~ /^(ogg)$/) || $OUTPUT_TYPE eq 'flac'){
			# -nostats -loglevel 0
			# -hide_banner -loglevel panic
			# -v quiet
			$silent_ffmpeg = '-hide_banner -loglevel panic'; # 
		}
		elsif ($OUTPUT_TYPE eq 'opus'){
			$silent_opus = '--quiet'; # for oggenc output
		}
	}
	if ($VERBOSITY < 2){
		$print_line_heavy = '';
		$print_line_large = '';
		$print_line_small = '';
	}
	else {
		$print_line_heavy = 'say $line_heavy';
		$print_line_large = 'say $line_large';
		$print_line_small = 'say $line_small';
	}
}

# get defaults from user config files if present
## UserConfigs
{
package UserConfigs;

sub set {
	my (@config_files,$file,$user_config);
	# set list of supported config files
	@config_files = ("/etc/$self_name.conf");
	if ($ENV{'XDG_CONFIG_HOME'} && -r "$ENV{XDG_CONFIG_HOME}/$self_name.conf"){
		$user_config = "$ENV{'XDG_CONFIG_HOME'}/$self_name.conf";
	}
	elsif (-r "$ENV{HOME}/.config/$self_name.conf"){
		$user_config = "$ENV{HOME}/.config/$self_name.conf";
	}
	elsif (-r "$ENV{HOME}/.$self_name.conf"){
		$user_config = "$ENV{HOME}/.$self_name.conf";
	}
	elsif (-r "$CONFIG_DIRECTORY/$self_name.conf"){
		$user_config = "$CONFIG_DIRECTORY/$self_name.conf";
	}
	@config_files = (@config_files,$user_config) if $user_config;
	foreach $file (@config_files){
		next unless -r $file && open (my $fh,'<',$file);
		while (<$fh>){
			chomp;                  # no newline
			s/#.*//;                # no comments
			s/^\s+//;               # no leading white
			s/\s+$//;               # no trailing white
			s/('|"|\$|\s)//g;       # get rid of all non valid characters
			next unless length;     # anything left?
			my ($var, $value) = split(/\s*=\s*/, $_, 2);
			if (defined $var && defined $value){
				assign_value($var, $value);
			}
		}
	}
}
sub assign_value {
	my ($var,$value) = @_;
	if ($var eq 'COMMAND_CURL'){$COMMAND_CURL = $value;}
	elsif ($var eq 'COMMAND_FLAC'){$COMMAND_FLAC = $value;}
	elsif ($var eq 'COMMAND_FFMPEG'){$COMMAND_FFMPEG = $value;}
	elsif ($var eq 'COMMAND_LAME'){$COMMAND_LAME = $value;}
	elsif ($var eq 'COMMAND_METAFAC'){$COMMAND_METAFLAC = $value;}
	elsif ($var eq 'COMMAND_OGG'){$COMMAND_OGG = $value;}
	elsif ($var eq 'COMMAND_OPUS'){$COMMAND_OPUS = $value;}
	elsif ($var eq 'CLEAN'){
		$value = get_boolean($value);
		if ($value =~ /^[10]$/){
			$run{'clean'} = $value;
			$run{'clean-sync'} = $value;
		}}
	elsif ($var eq 'SOURCE_DIRECTORY' || $var eq 'DIR_PREFIX_SOURCE'){
		$SOURCE_DIRECTORY = $value;}
	elsif ($var eq 'DESTINATION_DIRECTORY' || $var eq 'DIR_PREFIX_DEST'){
		$DESTINATION_DIRECTORY = $value;}
	elsif ($var eq 'MAN_DIRECTORY'){$MAN_DIRECTORY = $value}
	elsif ($var eq 'SELF_DIRECTORY'){$SELF_DIRECTORY = $value}
	elsif ($var eq 'INPUT_TYPE'){$INPUT_TYPE = $value;}
	# LOG_LEVEL is legacy name, leave in always.
	elsif ($var eq 'LOG_LEVEL' || $var eq 'VERBOSITY'){$VERBOSITY = $value;}
	elsif ($var eq 'OUTPUT_TYPE'){$OUTPUT_TYPE = $value;}
	elsif ($var eq 'CODEC_AAC'){$CODEC_AAC = $value;}
	# legacy configs, sets both
	elsif ($var eq 'QUALITY'){$QUALITY_OGG = $value;$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_AAC'){$QUALITY_AAC = $value}
	elsif ($var eq 'QUALITY_FLAC'){$QUALITY_FLAC = $value}
	elsif ($var eq 'QUALITY_MP3'){$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_OGG'){$QUALITY_OGG = $value;}
	elsif ($var eq 'QUALITY_OPUS'){$QUALITY_OPUS = $value;}
	elsif ($var eq 'COPY_TYPES' || $var eq 'USER_TYPES'){
		$COPY_TYPES = $value;}
	elsif ($var eq 'DONT_USE_NLINK'){$DONT_USE_NLINK = $value}
	elsif ($var eq 'DOT'){
		$value = get_boolean($value);
		$run{'dot'} = $value if $value =~ /^[10]$/;}
	elsif ($var eq 'FORK'){$FORK = $value}
	elsif ($var eq 'FFP_FILE'){$FFP_FILE = $value}
	elsif ($var eq 'INFO_FILE'){$INFO_FILE = $value}
	elsif ($var eq 'INFO_RATING'){$INFO_RATING = $value}
	elsif ($var eq 'MD5_FILE'){$MD5_FILE = $value}
	elsif ($var eq 'TAG_FILE'){$TAG_FILE = $value}
	elsif ($var eq 'EXCLUDE'){$EXCLUDE = $value}
	elsif ($var eq 'EXCLUDE_BASE'){$EXCLUDE_BASE = $value}
}
sub get_boolean {
	my ($value) = @_;
	$value =~ s/^(yes|1|true|enable|on)$/1/;
	$value =~ s/^(no|0|false|disable|off)$/0/;
	return $value;
}
# end ConfigData
}

# Get Options and set values, this overrides defaults 
# from top globals and config files
sub get_options{
	my (@args) = @_;
	my (%test,$msg);
	# single letters used:
	# aAcCdDEfFgGhiIKMoPqRsSTUvVxXyZ
	GetOptions (
	'G|aggregate:s' => sub { 
		my ($opt,$arg) = @_;
		if ($arg){
			if ($arg eq 'file'){
				$run{'aggregate-file'} = 1;
				$arg = $TAG_FILE;
			}
			$run{'ag-file'} = $arg;
		}
		else {
			$run{'ag-file'} = $TAG_FILE;
		}
		$run{'aggregate'} = 1;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'aggregate'} = 1;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
	},
	'analyze|Z' => sub { 
		$run{'checksum'} = 1;
		$run{'analyze'} = 1;
		$run{'duplicates'} = 0;
		$run{'checksum-delete'} = 0;
		$run{'checksum-verify'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'no-md5'} = 1;
		$test{'checksum'} = 1;
		$test{'analyze'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';},
	'a|append:s' => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES .= ',' . $arg if $arg;},
	'A|autotag' => sub { 
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'tag'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'C|autotag-create' => sub { 
		$run{'autotag-create'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'tag-create'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'M|autotag-create-multi:s' => sub { 
		my ($opt,$arg) = @_;
		if (!$arg || $arg !~ /%|@/){
			$msg = "$opt requires multidisk file name identifier. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$autotag_multi = $arg;
		$run{'autotag-create'} = 1;
		$run{'autotag-multi'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'tag-create'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'S|autotag-create-single' => sub { 
		$run{'autotag-create'} = 1;
		$run{'autotag-single'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'tag-create'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	# legacy
	'basic|default' => sub { 
		$VERBOSITY = 1 },
	'K|checksum' => sub { 
		$run{'checksum'} = 1;
		$run{'checksum-verify'} = 0;
		$run{'analyze'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'duplicates'} = 0;
		# $run{'autotag'} = 0;
		$test{'checksum'} = 1;
		$test{'checksum-generate'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'D|checksum-delete' => sub { 
		$run{'checksum'} = 1;
		$run{'checksum-delete'} = 1; 
		$run{'checksum-verify'} = 0;
		$run{'analyze'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'duplicates'} = 0;
		# $run{'autotag'} = 0;
		$test{'checksum'} = 1;
		$test{'checksum-delete'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'checksum-ffps|ffps' => sub { 
		$run{'checksum'} = 1;
		$run{'checksum-verify'} = 0;
		$run{'analyze'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'duplicates'} = 0;
		# $run{'autotag'} = 0;
		$run{'checksum-ffps'} = 1;
		$run{'no-md5'} = 1;
		$test{'checksum'} = 1;
		$test{'checksum-ffps'} = 1;
		$test{'checksum-generate'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'V|checksum-verify' => sub { 
		$run{'checksum-verify'} = 1;
		$run{'checksum-delete'} = 0; 
		$run{'analyze'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$run{'duplicates'} = 0;
		$test{'checksum'} = 1;
		$test{'checksum-verify'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	'clean:s' => sub { 
		my ($opt,$arg) = @_;
		$run{'clean-sync'} = 1 if $arg && $arg eq 'sync';
		$run{'clean'} = 1;
		$test{'clean'} = 1;
		},
	'codec:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires codec.",1) if !$arg;
		$codec = $arg;
		$test{'sync'} = 1;
		},
	# accepts null value so users can not copy anything
	'c|copy:s' => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES = $arg;
		$test{'sync'} = 1;
		},
	'debug' => sub { 
		$b_debug = 1;},
	'd|destination:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$DESTINATION_DIRECTORY = $arg;
		$test{'destination'} = 1;
		},
	'dot' => sub { 
		$run{'dot'} = 1;},
	'dupes|duplicates' => sub { 
		$run{'checksum'} = 1;
		$run{'duplicates'} = 1;
		$run{'no-md5'} = 1;
		$run{'analyze'} = 0;
		$run{'checksum-delete'} = 0;
		$run{'checksum-verify'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$test{'checksum'} = 1;
		$test{'duplicates'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';},
	'x|exclude:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires exclude list or file.",1) if ! $arg;
		$arg = '' if uc($arg) eq 'UNSET';
		$EXCLUDE = $arg;
		$test{'sync'} = 1;
		},
	'y|exclude-append:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires exclude list.",1) if ! $arg;
		$exclude_append = $arg },
	'f|force' => sub { 
		$b_force = 1 },
	'ffmpeg' => sub { 
		$run{'ffmpeg'} = 1 },
	'F|fork:i' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires fork count integer.",1) if not defined $arg;
		$FORK = $arg;
		$test{'sync'} = 1;
		},
	# legacy
	'full' => sub { 
		$VERBOSITY = 3 },
	'h|help|?' => sub { 
		show_options();},
	'I|image:s' => sub { 
		my ($opt,$arg) = @_;
		if (!$arg || $arg !~ /(\.png|\.jpe?g|^remove)$/i){
			$msg = "$opt requires a cover image file name. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$embed_image = $arg;
		$run{'remove-images'} = 1 if $embed_image eq 'remove';
		$run{'embed-image'} = 1;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		$b_check_dest = 0;
		$b_check_out = 0;
		$test{'tag'} = 1;
		},
	'X|infofix:s' => sub { 
		my ($opt,$arg) = @_;
		$run{'infofix'} = 1;
		if ($arg){
			if ($arg =~ /^[dnqutw]+$/i){
				$run{'infofix-date'} = 1 if $arg =~ /d/i;
				$run{'infofix-no'} = 1 if $arg =~ /n/i;
				$run{'infofix-quality'} = 1 if $arg =~ /q/i;
				$run{'infofix-title'} = 1 if $arg =~ /t/i;
				$run{'infofix-upper'} = 1 if $arg =~ /u/i;
				$run{'infofix-write'} = 1 if $arg =~ /w/i;
			}
			else {
				$msg = "For $opt use no arguments, or d n u t w. See -h.";
				error_handler('missing-arg',$msg,1);
			}
		}
		$run{'autotag'} = 0;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'info'} = 1;
		$test{'infofix'} = 1;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
	},
	'info-rating:i' => sub { 
		my ($opt,$arg) = @_;
		if (!$arg || $arg < 2){
			$msg = "$opt requires rating integer > 1. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$INFO_RATING = $arg;
		$test{'info-rating'} = 1;
	},
	'i|input:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$test{'input'} = 1;
		$INPUT_TYPE = $arg;
		$test{'sync'} = 1;
		},
	'link' => sub { 
		$DONT_USE_NLINK = 0 },
	'no-dot' => sub { 
		$run{'dot'} = 0;},
	'no-ffp' => sub { 
		$run{'no-ffp'} = 1 },
	'no-md5' => sub { 
		$run{'no-md5'} = 1 },
	'no-nlink' => sub { 
		$DONT_USE_NLINK = 1 },
	'no-replaygain' => sub { 
		$run{'no-replaygain'} = 1 },
	'o|output:s' => sub {
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$test{'output'} = 1;
		$OUTPUT_TYPE = $arg;
		$test{'sync'} = 1;
		},
	'E|prefill' => sub { 
		$run{'prefill'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$test{'info'} = 1;
		$test{'prefill'} = 1;
		},
	'prefill-file:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires file name.",1) if ! $arg;
		$INFO_FILE = $arg;
		$test{'info'} = 1;
		$test{'prefill'} = 1;
		},
	'q|quality:f' => sub { 
		my ($opt,$arg) = @_;
		if (!defined $arg || $arg !~ /^-?[0-9\.]+$/){
			error_handler('missing-arg',"$opt requires number.",1);
		}
		# validate these later
		$QUALITY_AAC = $arg;
		$QUALITY_FLAC = $arg;
		$QUALITY_MP3 = $arg;
		$QUALITY_OGG = $arg;
		$QUALITY_OPUS = $arg;
		$test{'sync'} = 1;
		}, 
	'quiet|silent' => sub { 
		$b_quiet = 1; 
		$VERBOSITY = 0 },
	'recurse:i' => sub { 
		my ($opt,$arg) = @_;
		if (!defined $arg){
			$msg = "$opt requires directory recursion level value. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$recurse = $arg},
	'R|remove-images' => sub { 
		$run{'remove-images'} = 1;
		$test{'tag'} = 1;
		},
	'P|remove-padding' => sub { 
		$padding = ' --dont-use-padding';
		$test{'tag'} = 1;
		},
	'resample:s' => sub {
		my ($opt,$arg) = @_;
		if (defined $arg && $arg =~ /^([0-9]+):([0-9]+(\.[0-9]+)?)$/){
			$run{'resample'} = [$1,$2];
		}
		else {
			error_handler('missing-arg',"Incorrect syntax for $opt: bits:khz, see -h or man.",1);
		}
		$test{'resample'} = 1;
		},
	'resample-override' => sub {
		$run{'resample-override'} = 1; },
	's|source:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$SOURCE_DIRECTORY = $arg;
		$test{'source'} = 1;
		},
	'g|source-glob:s' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$run{'source-glob'} = $arg;
		$test{'source-glob'} = 1;
		},
	'start:i' => sub { 
		my ($opt,$arg) = @_;
		if (!defined $arg || $start < 0){
			$msg = "$opt requires track number start value. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		$start = $arg;
		$test{'tag-create'} = 1;
		},
	'T|tag:s' => sub { 
		my ($opt,$arg) = @_;
		if (!$arg || $arg !~ /%:/){
			$msg = "$opt requires TAG%:value sets. See -h.";
			error_handler('missing-arg',$msg,1);
		}
		@tags = split /\Q^^\E/, $arg;
		$run{'update-tag'} = 1;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		# $run{'checksum'} = 0;
		$run{'checksum-verify'} = 0;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';
		$test{'tag'} = 1;
		},
	'test' => sub { 
		$b_test = 1 },
	'U|update'=> sub { 
		$run{'update'} = 1; 
		$run{'checksum'} = 0;
		$run{'checksum-delete'} = 0; 
		$run{'checksum-verify'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$b_check_dest = 0;
		$b_check_out = 0;
		$OUTPUT_TYPE = 'UNSET';},
	# legacy
	'verbose'=> sub { 
		$VERBOSITY = 2 },
	'v|verbosity|log:i' => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt verbosity integer.",1) if not defined $arg;
		$VERBOSITY = $arg; },
	'version' => sub { 
		show_version(); },
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unsupported-option', "Unsupported option: $opt",1); }
	);
	# prevent tagging/checksum operations without explicitly set source
	if (!$test{'source'} && ($test{'tag'} || $test{'tag-create'} || 
	$test{'info'} || $test{'aggregate'} || $test{'checksum'})){
		error_handler('invalid-options', 
		 "Explicit --source is required for all tagging/checksum options.",1);
	}
	# prevent running any tagging options with syncing options
	if (($test{'clean'} || $test{'sync'}) && ($test{'tag'} || $test{'tag-create'} || 
	$test{'info'} || $test{'checksum'})){
		error_handler('invalid-options', 
		 "Tagging/checksum options cannot be used with clean/sync options.",1);
	}
	if ($test{'infofix'} && ($test{'prefill'} && $test{'tag-create'})){
		error_handler('invalid-options', 
		 "Info Fix cannot be combined with any other option except --source.",1);
	}
	if ($test{'info-rating'} && !$test{'infofix'}){
		error_handler('invalid-options', 
		 "--info-rating can only be used with --infofix.",1);
	}
	if ($test{'source-glob'} && !$test{'source'}){
		error_handler('invalid-options', 
		 "--source-glob/-g must be used with --source/-s.",1);
	}
	if ($test{'source-glob'} && ($test{'clean'} || $test{'prefill'})){
		error_handler('invalid-options', 
		 "--source-glob/-g cannot be used with --clean/--prefill.",1);
	}
	# prefill options require tag-create options
	if ($test{'prefill'} && !$test{'tag-create'}){
		error_handler('invalid-options', 
		 "Prefill requires either --autotag-create-multi or --autotag-create-single.",1);
	}
	# aggregate requires destination and cannot be used with any other action
	if ($test{'aggregate'} && (!$test{'destination'} || ($test{'sync'} || 
	$test{'tag'} || $test{'tag-create'} || $test{'info'} || $test{'checksum'}))){
		error_handler('invalid-options', 
		 "Aggregate requires destination and cannot be combined with any other actions.",1);
	}
	# checksum can only be run with tagging/image, like -AD -AK
	if ($test{'checksum'} && ($test{'sync'} || $run{'test'} || $test{'tag-create'} || 
	$test{'info'})){
		error_handler('invalid-options', 
		 "Checksum options cannot be used with clean/sync/image/auto.tag-create options.",1);
	}
	# tagging can only be used with checksum or other tagging options like -I, -R
	if ($test{'tag'} && ($test{'sync'} || $test{'clean'} || $test{'tag-create'})){
		error_handler('invalid-options', 
		 "Tagging cannot be used with tag-create/aggregate/clean/sync options.",1);
	}
	# creating auto.tag cannot be combined with sync, checksum, or tagging
	if ($test{'tag-create'} && ($test{'sync'} || $test{'clean'} || $test{'checksum'} || 
	$test{'tag'})){
		error_handler('invalid-options', 
		 "autotag-create cannot be used with tagging/image/clean/sync/checksum options.",1);
	}
	# try to protect against ffmpeg being used with any non sync option
	if (!$test{'sync'} && $run{'ffmpeg'}){
		error_handler('invalid-options', 
		 "You can only use --ffmpeg with sync operations.",1);
	}
	if (($test{'duplicates'} || $test{'checksum-ffps'}) && $run{'no-ffp'}){
		error_handler('invalid-options', 
		 "You cannot use --no-ffp with --duplicates or --checksum-verify.",1);
	}
	if ($test{'checksum'} && $run{'no-ffp'} && $run{'no-md5'}){
		error_handler('invalid-options', 
		 "You cannot use both --no-ffp and --no-md5 with checksum options.",1);
	}
}

#########################################################################
### EXECUTE / PROCESS MUSIC ###
#########################################################################

main();

###**EOF**###
