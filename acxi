#!/usr/bin/perl
#########################################################################
# acxi - audio conversion program
#########################################################################

# Copyright (c) 2010-2019 - Harald Hope - smxi.org 
# Home page: https://github.com/smxi/acxi
# Forum support: https://techpatterns.com/forums/about1491.html
# Download url: https://smxi.org/acxi
#
# Based on flac2ogg.pl
# Copyright (c) 2004 - Jason L. Buberel - jason@buberel.org
# Copyright (c) 2007 - Evan Boggs - etboggs@indiana.edu
# Previous Home page (gone now): 
#   http://www.buberel.org/linux/batch-flac-to-ogg-converter.php
#
# Modified: 2018-12-05 - Cleaned up code, refactored
# Modified: 2011-07-26 - Harald Hope - Added patch for $ in file names; 
#   changed verbosity levels to fit future 3 release, got rid of 
#   $B_SILENT and $b_quiet
# Modified: 2011-03-23 - Odd Eivind Ebbesen - www.oddware.net - 
#   <oddebb at gmail dot com>
#   Added functionality for Flac conversion to MP3, preserving tags.
#########################################################################
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 3 of the License, or 
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
#
# Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
#########################################################################
# Given a source directory tree of original lossless music files 
# (flac, wav, etc), this program will recreate (or add to) a new 
# directory tree of ogg/mp3 files by recursively encoding only new 
# source files to destination types.
# The source and destination directories can be hard-coded using the 
# $SOURCE_DIRECTORY and $DESTINATION_DIRECTORY variables, or passed on 
# the command line, or can be set in the configuration file (recommended).  
#
# See USER MODIFIABLE VALUES for configuration information.

#########################################################################
### NO USER CHANGES IN THIS SECTION ###
#########################################################################
use strict;
use warnings;
# use diagnostics;
use 5.010;
use feature 'state';
use Getopt::Long qw(GetOptions);
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
use File::Basename;
use File::stat;
use File::Find;
use File::Copy qw(copy);
use File::Glob qw(:bsd_glob);
use File::Path qw(rmtree);
use Cwd qw(getcwd);
use Data::Dumper;
# only use for debugging, some distros do not ship with core modules.
#use Data::Dumper qw(Dumper);

#### -------------------------------------------------------------------
#### PROGRAM GLOBALS - DO NOT TOUCH THESE!
#### -------------------------------------------------------------------

## SELF INFO ##
my $SELF_NAME = 'acxi';
my $SELF_VERSION = '3.2.15';
my $SELF_DATE = '2019-07-29';

## GLOBALS ##
my %run;
$run{'sync'} = 1;
my ($b_dest_changed,$b_force,$b_fork,$b_quiet,$b_test);
my ($print_line_heavy,$print_line_large,$print_line_small);
my ($quality,$silent_flac,$silent_flac_out,$silent_lame,
$silent_opus) = (7,'','','','');
my ($extension,@extension_list,@found_list,$list_type);
my ($b_check_dest,$b_check_out) = (1,1);
my $b_win = ($^O =~ /win/i) ? 1 : 0; # detect if $^O returns windows 
my $path_separator = ($b_win) ? '\\' : '/';
## CONSTANTS ##
my $line_heavy = "===========================================================================\n";
my $line_small = "-----------------------------------------------------------------\n";
my $line_large = "---------------------------------------------------------------------------\n";

#########################################################################
### USER MODIFIABLE VALUES ###
#########################################################################
# User config file at:
# Global: /etc/acxi.conf
# User override files checked in the following order (first found used):
# $XDG_CONFIG_HOME/acxi.conf, $HOME/.config/acxi.conf, $HOME/.acxi.conf
#
# Set values like this:
# Do not use the $ preceding the variable name, or the semicolon or 
# single/double quote marks in the config file. Use this syntax for 
# config files:
# SOURCE_DIRECTORY=/home/fred/music/flac
# DESTINATION_DIRECTORY=/home/fred/music/ogg
#
# It's highly recommended to create a config file so you don't have to
# update the values below every time acxi updates.
#
# Anything in configs or in this section will be overridden if you use
# a startup argument.
#### -------------------------------------------------------------------
#### CUSTOM CONFIGURATION FILE LOCATION
#### -------------------------------------------------------------------
# NOTE: only use this if you are running Windows, or any OS without $HOME
# or $XDG_CONFIG_HOME environmental variables. acxi will look for file:
# acxi.conf inside that directory. 
my $CONFIG_DIRECTORY='';

#### -------------------------------------------------------------------
#### APPLICATION PATHS
#### -------------------------------------------------------------------
my $COMMAND_FLAC = '/usr/bin/flac'; 
my $COMMAND_FLAC_OUT = '/usr/bin/ffmpeg';
my $COMMAND_LAME = '/usr/bin/lame';
my $COMMAND_OGG = '/usr/bin/oggenc';
my $COMMAND_OPUS = '/usr/bin/opusenc';
# If you are not generating checksums, you do not need this.
my $COMMAND_MD5 = '/usr/bin/md5sum';
# metaflac is required for flac to mp3, to copy over the ID3 tags, or
# for ffp checksum generator.
# If you are not doing either, you don't need this.
my $COMMAND_METAFLAC = '/usr/bin/metaflac';

#### -------------------------------------------------------------------
#### ASSIGN DIRECTORY PATHS
#### -------------------------------------------------------------------
# Options: -s/--source path -d/--destination path
# $SOURCE_DIRECTORY is the original, working, like flac, wav, etc
# $DESTINATION_DIRECTORY is the processed, ie, ogg, mp3
# CHANGE TO FIT YOUR SYSTEM - do not end in /
# IMPORTANT: DESTINATION_DIRECTORY cannot be equal to SOURCE_DIRECTORY
my $SOURCE_DIRECTORY = '/path/to/source/directory';
my $DESTINATION_DIRECTORY = '/path/to/your/output/directory';

#### -------------------------------------------------------------------
#### CHECKSUM DATA
#### -------------------------------------------------------------------
# These are the file names MINUS the .ffp / .md5 extensions.
my $FFP_FILE='fingerprints';
my $MD5_FILE='md5sums';

#### -------------------------------------------------------------------
#### AUTO TAGGING
#### -------------------------------------------------------------------
# This is the file that contains the syntax found in auto.tag file. But
# you can call it something else if you prefer.
my $TAG_FILE='auto.tag';

#### -------------------------------------------------------------------
#### INPUT/OUTPUT
#### -------------------------------------------------------------------
# Options: -i/--input type ; -o/--output type
# The following are NOT case sensitive,ie flac/FLAC, txt/TXT will be 
# found. INPUT_TYPE and OUTPUT_TYPE will be forced to lower case 
# internally.
my $INPUT_TYPE = 'flac';
my $OUTPUT_TYPE = 'ogg';

# Option: -q/--quality number
# for flac: n can be 0-8. 0 produces largest file, is fastest, anything over 4
# is probably pointless since compression gain is very little vs time required.
# For mp3: n can be 0-9 (variable bit rate), 0 is largest file / highest quality
# For ogg: n can be between -1 and 10. Fractions allowed. 10 is the largest file 
# size / highest quality. 
# For opus: n can be 6-256. 256 is the largest file size / highest quality / 
# maximum bitrate. For flac 0-8 [0 biggest size, fastest]
my $QUALITY_FLAC = 4;
my $QUALITY_MP3 = 3;
my $QUALITY_OGG = 7;
my $QUALITY_OPUS = 160;

# Option: -c/--copy and -a/--append (to append extension types to existing list.
## NOTE: if you want to override $COPY_TYPES in your config files, you
# must use this syntax:
# COPY_TYPES=doc,docx,bmp,jpg,jpeg
# Add or remove types to copy over to ogg directories, do not include
# the input/output audio file types, only extra data types like txt.
# If you want no copying done, simply change to: $COPY_TYPES = 'none';
my $COPY_TYPES = 'bmp,doc,docx,gif,jpg,jpeg,odt,pdf,png,tif,txt';

#### -------------------------------------------------------------------
#### PRINT OUTPUT
#### -------------------------------------------------------------------
# OPtions: --basic -V/--verbose --full --log 0-4
# You can turn these to always on either here or in config file by setting to 
# desired verbosity level here directly, or in config file. 
# 0 = quiet/silent - no output at all; 
# 1 = default - single line per operation. This is the default, so you don't need 
#     to change it.
# 2 = verbose - but without the actual conversion data from codecs
# 3 = debug -  all available information.
# NOTE: with FORK > 1, conversion debugging output can be out of order.
my $LOG_LEVEL = 1;

#### -------------------------------------------------------------------
#### ADVANCED
#### -------------------------------------------------------------------
# Options: --nlink --no-nlink
# Only change to 0 if you encounter file tree failures. This is for File::Find
# values:  0 - use nlink; 1 - don't use nlink [default, only change if you know
# why.
my $DONT_USE_NLINK = 1;

# Option: -F/--fork 0-xx
## number of forks/threads to use. 0 is default, and will not use forking
# note that debugging output gets strange with forking, so debug with fork = 0
# FORK = 1 results in slower times than using no forking so avoid that. 
my $FORK = 0;

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------
# this will be used to update the program and man page. You must have 
# write permissions to the file locations. Linux or BSD only.
# do not end paths with /

my $COMMAND_CURL='/usr/bin/curl';
my $MAN_DIRECTORY='/usr/local/share/man/man1';
my $SELF_DIRECTORY='/usr/local/bin';

#########################################################################
### END USER MODIFIABLE VALUES ###
#########################################################################

########################################################################
#### STARTUP
########################################################################

sub main {
	UserConfigs::set();
	get_options();
	set_display_data();
	SelfUpdater::update() if $run{'update'};
	Validation::check_user_values();
	set_basic_data();
	AutoTag::create_file() if $run{'autotag-create'};
	AutoTag::run_tagger() if $run{'autotag'};
	CleanCollection::process_destination() if $run{'clean'};
	SyncCollection::process_collection() if $run{'sync'};
	Checksums::generate() if $run{'checksum'};
	print_completion_message();
}

#########################################################################
### CLEAN/SYNC MUSIC DIRECTORIES ###-
#########################################################################

#### -------------------------------------------------------------------
#### AUTO-TAGGING
#### -------------------------------------------------------------------

## package AutoTag 
{
package AutoTag;
sub run_tagger {
	print $line_large;
	print "Starting auto-tagging in $SOURCE_DIRECTORY...\n";
	get_tag_files();
	print $line_small;
	print "Completed auto-tagging.\n";
	print $line_large;
}
sub create_file {
	print $line_large;
	print "Creating $TAG_FILE in $SOURCE_DIRECTORY...\n";
	make_file();
	print $line_small;
	print "Completed file creation.\n";
	print $line_large;
}
sub get_tag_files {
	my ($item,$print_file,$result,$working_dir);
	$list_type = 'file';
	File::Find::find( \&main::wanted, "$SOURCE_DIRECTORY");
	foreach $item (@found_list) {
		$print_file = $working_dir = $item;
		$print_file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
		# $working_dir =~ s/[^\/]+$//;
		$working_dir = File::Basename::dirname($item);
		chdir "$working_dir";
		if ($LOG_LEVEL > 3){
			say Cwd::getcwd();
			system 'pwd';
		}
		print "Processing: $print_file...\n";
		process_tags();
		$b_dest_changed = 1;
	}
	if (!@found_list) {
		print "No $TAG_FILE files found.\n";
	}
}
sub process_tags {
	my @tags = main::reader($TAG_FILE,'strip');
	my ($args,$error_message,@main_tags,@track_tags,@working);
	my ($b_tracks);
	my ($cmd,$comments,$tag) = ('','','');
	state %set;
	foreach (@tags){
		@working=split /%:/, $_;
		#print Data::Dumper::Dumper \@working;
		next if ! $working[1];
		print "@working\n" if $LOG_LEVEL > 3;
		$working[1] =~ s/"/\\\"/g;
		$working[1] =~ s/\$/\\\$/g;
		if ($working[0] =~ /^(TITLE|TRACKNUMBER|VERSION|PART)$/){
			$tag = qq(--set-tag=$working[0]="$working[1]");
			push @track_tags, $tag;
		}
		elsif ($working[0] ne 'FILE') {
			# delete all previous items for key, to avoid multi tagging
			if ($b_tracks && (!$set{$working[0]} || $working[1] eq 'UNSET')){
				if ($working[0] eq 'IMAGE'){
					@main_tags = grep {!/^--import-picture-from/} @main_tags;
				}
				else {
					@main_tags = grep {!/^--set-tag=$working[0]/} @main_tags;
				}
				next if $working[1] eq 'UNSET';
			}
			# then set the key flag again
			$set{$working[0]} = 1;
			if ($working[0] eq 'IMAGE'){
				$tag = qq(--import-picture-from="$working[1]");
			}
			else {
				$tag = qq(--set-tag=$working[0]="$working[1]");
			}
			push @main_tags, $tag;
		}
		elsif ($working[0] eq 'FILE'){
			## NOTE: we have to unescape $ in paths for -e tests, but leave it escaped
			## for qq cmd strings. Why? Shell expands it, perl does not.
			my $temp = $working[1];
			$temp =~ s/\\\$/\$/g;
			print "Tagging \"$temp\"... ";
			main::error_handler('file-missing',"Missing file: $temp",1) if ! -e "$temp";
			# note: must be set here, not in qx to avoid quote errors
			# single quotes, in case contains $ symbol
			#say "$working[1]";
			$cmd = qq($COMMAND_METAFLAC --remove-all-tags "$working[1]");
			print "\n", $cmd, "\n" if $LOG_LEVEL > 3;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
			}
			@track_tags = (@main_tags,@track_tags);
			$args = join ' ', @track_tags;
			@track_tags = ();
			# reset all detected @main items
			foreach (keys %set) {
				$set{$_} = 0;
			}
			$cmd = qq($COMMAND_METAFLAC $args "$working[1]");
			print "\n", $cmd, "\n" if $LOG_LEVEL > 3;
			$b_tracks = 1;
			if (!$b_test){
				qx($cmd);
				if ($? > 0){
					$error_message = "$COMMAND_METAFLAC returned error: $?";
					main::error_handler('application-error', $error_message,1);
				}
				say 'tagged';
			}
			
		}
	}
}
sub make_file {
	my ($file,@files);
	chdir $SOURCE_DIRECTORY;
	my $source_dir = $SOURCE_DIRECTORY;
	#$source_dir =~ s|([\(\)\$])|\\$1|g;
	$source_dir =~ s|^\Q$source_dir$path_separator\E||;
	say $source_dir;
	print "Checking for pre-existing $TAG_FILE... ";
	if ($b_test){
		print "Running test mode.\n";
	}
	elsif (-e $source_dir . $path_separator . $TAG_FILE){
		main::error_handler('file-exists', "File $TAG_FILE already exists in:\n$source_dir",1);
	}
	else {
		print "none found. Proceeding.\n";
	}
	if ($LOG_LEVEL > 3){
		say Cwd::getcwd();
		system 'pwd';
	}
	print "Creating $TAG_FILE file... ";
	$extension = $INPUT_TYPE;
	$list_type = 'file';
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	print "\n" if $LOG_LEVEL > 2;
	foreach $file (@found_list) {
		$b_dest_changed = 1;
		$file =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||;
		say $file if $LOG_LEVEL > 2;
		push @files, $file;
	}
	if (@files){
		@files = sort @files; # can be a problem, if track number comes last!
		print "Processing.\n";
		populate_file(\@files);
	}
	else {
		print "No files found to process.\n";
	}
}
sub populate_file {
	my ($files) = @_;
	my (@replaygain,@tags);
	my $counter=0;
	my @collection = (
	'## RECORDING NAME/CREATORS ##',
	'ALBUM','# Name to sort under','ALBUMSORT',
	'ARTIST','# Multi-Artist only','ALBUMARTIST',
	'COMPOSER','# Classical fields','CONDUCTOR','OPUS',
	'# Band members, etc.', 'PERFORMER','PERFORMER','PERFORMER','PERFORMER',
	'## RECORDING COMMENTS. Note: COMMENT preferred over DESCRIPTION ##',
	'COMMENT','COMMENT','COMMENT','COMMENT',
	'## DISPLAY IMAGES ##',
	'# Please see sample auto.tag file for more information on IMAGE',
	'# Format: [TYPE]|[MIME-TYPE]|[DESCRIPTION]|[WIDTHxHEIGHTxDEPTH[/COLORS]]|FILE',
	'# Example: IMAGE%:3||||images/cover.jpg', 
	'IMAGE',
	'## RECORDING INFO ##',
	# note: VENUE and LABEL better handled by xiph spec: LOCATION and ORGANIZATION
	# Include YEAR to make conversion to mp3 tagging cleaner
	'GENRE','RATING','DATE','YEAR','LOCATION','PRODUCER','PUBLISHER',
	'# e.g. record label, taper group,, etc. ','ORGANIZATION',
	'## TECHNICAL INFORMATION ##',
	'ENCODING',
	'# Useful for tapers etc','SOURCE','SOURCE','SOURCE',
	'# Media recording taken from, eg, cassette, tape, dat, vinyl','SOURCEMEDIA',
	);
	my @disk = ('','## DISC INFO ##',
	'# Leave DISCNUMBER, DISCTOTAL empty if 1 disc set',
	'DISCTOTAL','DISCNUMBER','DISCSUBTITLE',
	'# Do not leave empty, this is per disk track totals for players','TRACKTOTAL',
	'', '## TRACK INFO ##', 
	'# Use of any of above tags between track blocks will switch to the new value.',
	'# To make the value empty use: UNSET as the field value.',
	'# TRACKNUMBER and FILE required, title not known?: suggest TITLE%:Unknown ');
	my @track = ('','TRACKNUMBER','TITLE','VERSION','PART','FILE');
	
	@collection = map {$_ .= '%:' if /^[A-Z]/; $_;} @collection;
	@disk = map {$_ .= '%:' if /^[A-Z]/; $_;} @disk;
	if ($run{'autotag-number'} && @$files){
		@disk = map {$_ .= scalar (@$files) if $_ eq 'TRACKTOTAL%:'; $_;} @disk;
	}
	@tags = (@collection,@disk);
	@track = map {$_ .= '%:' if /^[A-Z]/; $_;} @track;
	foreach (@$files){
		$counter++;
		my @track_working = @track;
		$track_working[1] = $track[1] . $counter if $run{'autotag-number'};
		$track_working[5] = $track[5] . $_;
		if (!$run{'no-replaygain'}){
			@replaygain = get_replaygain($_);
			# we want the replaygain data right before FILE
			splice (@track_working, 5, 0, @replaygain) if @replaygain;
		}
		@tags = (@tags,@track_working);
	}
	if ($b_test){
		print join "\n", @tags, "\n";
	}
	else {
		main::writer($TAG_FILE,\@tags);
	}
	sub get_replaygain {
		my ($input_file) = @_;
		my (@tags);
		my %replaygain = main::get_flac_tags('replaygain',$input_file);
		foreach (keys %replaygain){
			push @tags, "$_%:$replaygain{$_}" if $replaygain{$_};
		}
		return @tags;
	}
}
# --preserve-modtime --remove-all-tags --remove-tag
## end of AutoTag
}

#### -------------------------------------------------------------------
#### CHECKSUMS
#### -------------------------------------------------------------------

## package Checksums 
{
package Checksums;
sub generate {
	print $line_large;
	print "Starting checksum generation in $SOURCE_DIRECTORY...\n";
	process_directories();
	print $line_small;
	print "Completed checksum generation.\n";
	print $line_large;
}
sub process_directories {
	my (@files,$item,$print_src,$result);
	$list_type = 'dir';
	print $line_small;
	print "Checking directories...\n";
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	foreach $item (@found_list) {
		$print_src = $item;
		$print_src =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
		#if ($LOG_LEVEL > 2){
		#	say Cwd::getcwd();
		#	system 'pwd';
		#}
		chdir "$item";
		if ($LOG_LEVEL > 3){
			say Cwd::getcwd();
			system 'pwd';
		}
		print "$print_src...\n";
		@files = main::globber("*.{flac,FLAC}");
		#print "\n", Data::Dumper::Dumper @files, "\n";
		if (@files){
			print " Processing...\n";
			delete_checksums() if $run{'checksum-delete'};
			generate_checksums();
			$b_dest_changed = 1;
		}
		else {
			print " No $INPUT_TYPE files\n";
		}
	}
}
sub generate_checksums {
	my ($error_message,@output);
	system('pwd') if $LOG_LEVEL > 2;
	print "  Generating checksums: ";
	print "$MD5_FILE.md5: ";
	# system("$COMMAND_MD5 *.* > $MD5_FILE.md5");
	@output = qx($COMMAND_MD5 *.*);
	if ($? == -1 || $? > 0){
		$error_message = "$COMMAND_MD5 returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	else {
		chomp (@output = grep {$_ !~ m^\.(ffp|md5)^} @output);
		if (!$b_test){
			main::writer("$MD5_FILE.md5",\@output);
			print "created; " ;
		}
		else {
			print "\n", join( "\n", @output),"\n";
		}
	}
	print "$FFP_FILE.ffp: ";
	#system("$COMMAND_METAFLAC --show-md5sum *.flac > $FFP_FILE.ffp");
	@output = qx($COMMAND_METAFLAC --show-md5sum *.flac);
	if ($? == -1 || $? > 0){
		$error_message = "$COMMAND_METAFLAC returned error: $?";
		main::error_handler('application-error', $error_message,1);
	}
	else {
		chomp (@output);
		if (!$b_test){
			main::writer("$FFP_FILE.ffp",\@output);
			say "created" ;
		}
		else {
			print "\n", join( "\n", @output),"\n";
		}
	}
}
sub delete_checksums {
	my $error_message = '';
	# note: some checksum generators tack on a .txt to the filename.
	my @checksums = main::globber("*.{ffp,ffp.txt,md5,md5.txt}");
	# print Data::Dumper::Dumper @checksums, "\n";
	foreach my $file (@checksums){
		print "  Deleting $file: ";
		if ($b_test){
			say "test deletion";
		}
		elsif (unlink($file)){
			say "deleted";
		}
		else {
			main::error_handler('checksum-delete', "Failed to delete: $file");
		}
	}
}
}

#### -------------------------------------------------------------------
#### CLEANING
#### -------------------------------------------------------------------

## package CleanCollection
{
package CleanCollection;

sub process_destination {
	print $line_large;
	print "Starting cleanup of $DESTINATION_DIRECTORY...\n";
	process_type('directory');
	process_type('file');
	print $line_small;
	print "Completed cleanup checks.\n";
	print $line_large;
}
sub process_type {
	my ($type) = @_;
	my ($b_deleted,$item,$result);
	$list_type = ($type eq 'directory') ? 'dir-clean': 'file-clean';
	@found_list = ();
	print $line_small;
	print "Checking $type removal...\n";
	File::Find::find( \&main::wanted, $DESTINATION_DIRECTORY);
	if (@found_list && confirm_deletion($type)){
		foreach $item (@found_list) {
			$result = 'UNSET';
			print "Deleting $type: $item\n";
			$result = File::Path::rmtree("$item") if !$b_test;
			$b_deleted = 1;
			$b_dest_changed = 1;
			print "Delete $type result: $result\n" if $LOG_LEVEL > 1;
		}
	}
	main::print_not_found("$type-cleaned") if ! $b_deleted;
}
sub confirm_deletion {
	my ($type) = @_;
	my ($b_confirm,$response) = (0,'');
	print $line_small;
	print join("\n", @found_list),"\n";
	print $line_small;
	print "The preceding $type items will be deleted. Deletions cannot\n";
	print "be restored! BE AWARE!!\n";
	print "Please type 'delete' + 'enter' to remove them, or hit 'enter' to skip.\n";
	print "If you are unsure, hit 'enter' to see the file list.\n" if $type eq 'directory';
	chomp($response = <STDIN>);
	if (lc($response) eq 'delete'){
		print "Are you SURE you want to delete these items?\n";
		print "Type 'yes' + 'enter' to confirm, or hit 'enter' to skip.\n";
		chomp($response = <STDIN>);
		return 1 if lc($response) eq 'yes';
	}
	print "Skipping deletion for this $type group.\n";
	return 0;
}
## end package 
}

#### -------------------------------------------------------------------
#### SYNCING
#### -------------------------------------------------------------------

## package SyncCollection 
{
package SyncCollection; 

sub process_collection {
	my (@extension_files);
	eval $print_line_heavy;
	if ( $LOG_LEVEL > 1 ) {
		print "Syncing $DESTINATION_DIRECTORY (destination) with\n";
		print "        $SOURCE_DIRECTORY (source)...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Starting sync of $SOURCE_DIRECTORY\n to $DESTINATION_DIRECTORY\n";
	}
	update_directories();
	$list_type = 'file';
	foreach (@extension_list) {
		eval $print_line_large;
		$extension = $_;
		@found_list = ();
		File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
		# print Dumper \@found_list;
		if ( $LOG_LEVEL > 1 ) {
			print "PROCESSING DATA TYPE: $extension\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\n" . main::dotify("Processing $extension data type");
		}
		if (@found_list){
			update_files();
		}
		else {
			main::print_not_found('extension');
		}
	}
}
# Recreate the directory hierarchy.
sub update_directories {
	my ($b_created,$dest_dir,$dir,$result);
	$list_type = 'dir';
	@found_list = ();
	File::Find::find( \&main::wanted, $SOURCE_DIRECTORY);
	eval $print_line_large;
	# print Dumper \@found_list;
	if ( $LOG_LEVEL > 1 ) {
		print "Checking if $SELF_NAME needs to create destination directories...\n";
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print main::dotify("Updating destination directories");
	}
	foreach $dir (@found_list) {
		#print "\nd1:$dir\n";
		$result = 'UNSET';
		next if $dir eq $SOURCE_DIRECTORY || $dir eq $DESTINATION_DIRECTORY;
		$dir =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E||; # strip out source path
		next if !$dir;
		$dest_dir = $DESTINATION_DIRECTORY . $path_separator . $dir;
		#print "d2:$dir\n";
		# check to see if the destination dir already exists
		if ( ! stat("$dest_dir") ) {
			# stat failed so create the directory
			eval $print_line_small;
			if ( $LOG_LEVEL > 1 ) {
				print "CREATING NEW DIRECTORY:\n $dest_dir\n";
			}
			elsif ( $LOG_LEVEL > 0 ) {
				print "\nCreating new directory: $dest_dir";
			}
			$dest_dir =~ s/\`/\'/g; # get rid of weird characters
			$result = mkdir("$dest_dir") if !$b_test;
			$b_created = 1;
			$b_dest_changed = 1;
			print "Create Directory result: $result\n" if $LOG_LEVEL > 1;
		}
	}
	main::print_not_found('dirs') if ! $b_created;
}

sub update_files {
	my ($b_created);
	my ($dest_file,$file,$result,$action,$src_file) = ('','','','','');
	my ($dest_info,$dest_mod_time,$src_info, $src_mod_time) = ('',0,'',0);
	my $pm = new Parallel::ForkManager($FORK) if $b_fork;
	foreach $file (@found_list) {
		next if ! $file;
		$dest_file = $src_file = $file;
		#print "\nIF: $src_file\n";
		$dest_file =~ s|^$SOURCE_DIRECTORY|$DESTINATION_DIRECTORY|;
		$dest_file =~ s/\`/\'/g;
		# $dest_file =~ s/\$/\\\$/g;
		# get rid of escape sequences in case someone used them: \40
		# $src_file =~ s/\0//g; 
		$dest_file =~ s/\0//g;
		# Figure out what the destination file would be...
		if ( lc($extension) eq $INPUT_TYPE ){
			$dest_file =~ s/\.$INPUT_TYPE$/\.$OUTPUT_TYPE/i;
		}
		#print "OF: $dest_file\n";
		($action,$result,$dest_mod_time,$src_mod_time ) = ('UNSET','UNSET',0,0);
		# Now stat the destinationFile, and see if it's date is more recent
		# than that of the original file. If so, we re-encode.
		# We also re-encode if the user supplied --force
		$src_info = File::stat::stat("$src_file") or 
		  main::error_handler('stat-infile', "No $src_file: $!",1);
		$src_mod_time = $src_info->mtime if $src_info;
		$dest_info = File::stat::stat("$dest_file");
		if ( $dest_info ) {
			$dest_mod_time = $dest_info->mtime;
			# print "DEST_MOD: $dest_mod_time :: SRC_MOD: $src_mod_time :: FORCE: $force\n"; 
# 		} else {
# 			print "NOT EXISTS: $destinationFile \n"; 
# 			print "P1: $file ==> \n  $destinationFile\n"; 
		}
		# If the destination file does not exist, or the user specified force,
		# or the srcfile is more recent then the dest file, we encode/copy.
		# print "src-mt: $src_mod_time dest-mt:$dest_mod_time\n";
		if ( !$dest_info || $b_force || ( $src_mod_time > $dest_mod_time) ) {
			# these have to be set before the forking
			$b_created = 1;
			$b_dest_changed = 1;
			if ( lc($extension) eq $INPUT_TYPE ){
				$pm->start and next if $b_fork; # do the fork 
				my @returns = convert_file($src_file, $dest_file);
				$result = $returns[0];
				$action = $returns[1];
				$pm->finish if $b_fork;
			} 
			else {
				$action = 'Copy';
				$result = copy_file($file, $src_file, $dest_file);
			}
			# NOTE: for forking > 1, this will not print out for the output/input conversion files 
			print "$action result: $result\n" if $LOG_LEVEL > 1;
		} 
	}
	# wait for all the forks to finish before terminating 
	# the parent.. otherwise terminating the parent force kills 
	# all the forks 
	$pm->wait_all_children if $b_fork;
	main::print_not_found('files') if ! $b_created;
}

sub copy_file {
	my ($file, $src_file, $dest_file) = @_;
	my $result = 'UNSET';
	my ($src_print,$dest_print) = ($src_file, $dest_file);
	$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	eval $print_line_small;
	if ( $LOG_LEVEL > 1 ) {
		print "COPY: $src_print ==> \n";
		print "      $dest_print\n"; 
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "\nCopying $src_print...";
	}
	if (!$b_test){
		$result = File::Copy::copy($src_file, $dest_file) or 
			main::error_handler('cp-file', "cp failure: $src_file =>\n$dest_file\nCode: $!",1);
	}
	return $result;
}

sub convert_file { 
	my ($src_file, $dest_file) = @_;
	my ($src_print,$dest_print) = ($src_file, $dest_file);
	my ($result,$cmd,$action) = (1000,'','unset'); 
	# escape characters for conversion processing
	$src_file =~ s/"/\\"/g;
	$dest_file =~ s/"/\\"/g;
	$src_file =~ s/\$/\\\$/g;
	$dest_file =~ s/\$/\\\$/g;
	$src_print =~ s|^\Q$SOURCE_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	$dest_print =~ s|^\Q$DESTINATION_DIRECTORY$path_separator\E|| if $LOG_LEVEL < 3;
	# with forking, the printing gets messed up unless it's done 
	# just like this.
	if (!$b_fork){
		eval $print_line_small;
		if ( $LOG_LEVEL > 1 ) {
			print "ENCODE: $src_print ==> \n";
			print "        $dest_print\n"; 
		}
		elsif ( $LOG_LEVEL > 0 ) {
			# add line break only when file exists
			print main::dotify("\nEncoding $src_print to $OUTPUT_TYPE");
		}
	}
	if ( $OUTPUT_TYPE eq 'flac' ){
		$action = 'To flac';
		if (!$b_test){
			qx($COMMAND_FLAC_OUT $silent_flac_out -i "$src_file" "$dest_file" );
			$result = $?;
		}
	}
	elsif ( $OUTPUT_TYPE eq 'ogg' ){
		$action = 'To ogg';
		if (!$b_test){
			qx($COMMAND_OGG $silent_flac -q $quality -o "$dest_file" "$src_file");
			$result = $?;
		}
	}
	elsif ( $OUTPUT_TYPE eq 'opus' ){
		$action = 'To opus';
		if (!$b_test){
			qx($COMMAND_OPUS $silent_opus --bitrate $quality "$src_file" "$dest_file");
			$result = $?;
		}
	}
	elsif ( $OUTPUT_TYPE eq 'mp3' ){
		$action = 'To mp3';
		if (!$b_test){
			# Modified: Odd @2011-03-23 01:51:26 - Include ID3 copying
			$cmd = main::flac2mp3_cmd("$src_file","$dest_file");
			qx($cmd);
			$result = $?;
		}
	}
	if ($b_fork){
		eval $print_line_small;
		if ( $LOG_LEVEL > 1 ) {
			print "ENCODED: $src_print ==> \n";
			print "        $dest_print\n"; 
			print "$action result: $result\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			# add line break only when file exists
			print main::dotify("\nEncoded $src_print to $OUTPUT_TYPE");
		}
	}
	# this return only works with non forking
	return ($result,$action); 
}
## end package 
}

#### -------------------------------------------------------------------
#### TAGGING
#### -------------------------------------------------------------------

# Added: Odd @2011-03-23 01:52:31
sub flac2mp3_cmd {
	my ($i_file, $o_file) = @_;
	my %tags = get_flac_tags('standard',"$i_file");
	my $lame_params = '';
	# print Dumper \%tags;
	if ($tags{'TRACKNUMBER'} && $tags{'TRACKTOTAL'}){
		$tags{'TRACKNUMBER'} .= "/$tags{'TRACKTOTAL'}";
	}
	if ($tags{'DISKNUMBER'} && $tags{'DISKTOTAL'}){
		$lame_params .= "--tv \"TPOS=$tags{'DISKNUMBER'}/$tags{'DISKTOTAL'}\" ";
	}
	$lame_params .= " --ta \"$tags{'ARTIST'}\" --tl \"$tags{'ALBUM'}\"";
	$lame_params .= " --tt \"$tags{'TITLE'}\" --tg \"$tags{'GENRE'}\"";
	$lame_params .= " --ty \"$tags{'DATE'}\" --tn \"$tags{'TRACKNUMBER'}\" - \"$o_file\"";
	# $lame_params .= " --tt \"$tags{'TRACKTOTAL'}\" --tg \"$tags{'DISKNUMBER'}\"";
	my $cmd = "$COMMAND_FLAC $silent_flac -d -c \"$i_file\" | ";
	$cmd .= "$COMMAND_LAME $silent_lame -h -V $quality $lame_params";
	return $cmd;
}

# Added: Odd @2011-03-23 01:52:17
# args: $type: standard|replaygain; $i_file: file to work on
# For this function to work reliably, it should be passed tag queries in the order of:
# artist, album, title, genre, date, tracknumber
sub get_flac_tags {
	my ($type,$i_file) = @_;
	my (%tag_list,@tags,@working);
	if ($type eq 'standard'){
		@tags = ('ARTIST', 'ALBUM', 'TITLE','GENRE', 'DATE', 'TRACKNUMBER', 
		'TRACKTOTAL','DISKNUMBER','DISKTOTAL');
	}
	elsif ($type eq 'replaygain'){
		@tags = ('REPLAYGAIN_TRACK_PEAK','REPLAYGAIN_TRACK_GAIN',
		'REPLAYGAIN_ALBUM_PEAK','REPLAYGAIN_ALBUM_GAIN');
	}
	my $cmd = "$COMMAND_METAFLAC \"$i_file\" ";
	foreach (@tags){
		$cmd .= "--show-tag=\"$_\" ";
	}
	my @orig_tags = qx($cmd);
	chomp @orig_tags;
	foreach (@orig_tags) {
		@working = split /=/,$_;
		$tag_list{$working[0]} = $working[1];
	}
	# create missing hash keys
	foreach (@tags){
		$tag_list{$_} = '' if ! defined $tag_list{$_};
	}
	# print Dumper \%tag_list;
	return %tag_list;
}

#########################################################################
### PROGRAM TOOLS ###
#########################################################################

#### -------------------------------------------------------------------
#### UTILITIES
#### -------------------------------------------------------------------

# $1 - Perl module to check
sub check_module {
	my ($module) = @_;
	my $b_present = 0;
	eval "require $module";
	$b_present = 1 if !$@;
	return $b_present;
}

sub dotify {
	my $string = $_[0];
	while (length($string) < 53){
		$string .= '.';
	}
	$string .= ' ';
	return $string;
}

# args: 1 - string value to glob
# Note: because of spaces and other strange user file paths, need to use 
# bsd glob, which returns space agnostic globs, as you'd expect. 
sub globber {
	#my @files = glob qq{"$_[0]"};
	#print Data::Dumper::Dumper @files;
	#return @files;
	return <$_[0]>;
}

# arg: 1 - full file path, returns array of file lines.
# 2 - optionsl, strip and clean data
# note: chomp has to chomp the entire action, not just <$fh>
sub reader {
	my ($file,$strip) = @_;
	open( my $fh, '<', $file ) or error_handler('open', $file, $!);
	chomp(my @rows = <$fh>);
	if ($strip && @rows){
		@rows = grep {!/^\s*#|^\s*$/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	return @rows;
}

# NOTE: File::Find will not follow symbolic links
sub wanted {
	return if -l; # skip symbolic links
	if ($list_type eq 'dir' || $list_type eq 'file'){
		return if $File::Find::name =~ m/^\Q$DESTINATION_DIRECTORY\E/;
		return if $File::Find::name =~ m/\/\./; # skip any dot files/directories
		if ($list_type eq 'dir'){
			return if ! -d; # only directories
		}
		elsif ($list_type eq 'file') {
			return if -d; # skip directories
			return if $run{'autotag'} && $File::Find::name !~ /\Q$TAG_FILE\E$/;
			return if !$run{'autotag'} && $File::Find::name !~ /\.$extension$/i;
		}
	}
	elsif ($list_type eq 'dir-clean' || $list_type eq 'file-clean'){
		if ($list_type eq 'dir-clean') {
			return if ! -d; # skip non directories
		}
		else {
			return if -d; # skip non directories
		}
		my $working = $File::Find::name;
		$working =~ s|^\Q$DESTINATION_DIRECTORY\E|$SOURCE_DIRECTORY|;
		$working =~ s/\.$OUTPUT_TYPE$/\.$INPUT_TYPE/i if $list_type eq 'file-clean';
		#print '1: ', "$File::Find::name\n$working\n";
		return unless ! -e $working && -e $File::Find::name;
		# print '2: ', "$File::Find::name\n";
	}
	# print $File::Find::name . "\n";
	push (@found_list, $File::Find::name);
	return;
}

# arg: 1 file full  path to write to; 2 - arrayof data to write. 
# note: turning off strict refs so we can pass it a scalar or an array reference.
sub writer {
	my ($path, $ref_content) = @_;
	my ($content);
	no strict 'refs';
	# print Dumper $ref_content, "\n";
	if (ref $ref_content eq 'ARRAY'){
		$content = join "\n", @$ref_content or die "failed with error $!";
	}
	else {
		$content = scalar $ref_content;
	}
	open(my $fh, ">", $path) or 
	 error_handler('open',"$path failed to open for writing.\nMessage: $!",1);
	print $fh $content;
	close $fh;
}

#### -------------------------------------------------------------------
#### SELF UPDATER
#### -------------------------------------------------------------------

## package SelfUpdater
{
package SelfUpdater;
my $self_source = "$SELF_DIRECTORY/$SELF_NAME";
my $man_source = "$MAN_DIRECTORY/$SELF_NAME.1";
my $curl = $COMMAND_CURL;
sub update {
	print $line_large;
	print "Starting $SELF_NAME self updater...\n";
	validate();
	grab();
	print $line_small;
	print "Completed self updates.\n";
	print $line_large;
	exit 0;
}
sub grab {
	my $cmd = "$COMMAND_CURL  -o $self_source -L https:/smxi.org/acxi";
	print "Downloading $SELF_NAME now...\n";
	qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Self update error: curl returns: $?.",1);
	}
	$cmd = "$COMMAND_CURL  -o $man_source -L https:/smxi.org/acxi.1";
	print "Downloading $SELF_NAME.1 man page now...\n";
	qx($cmd);
	if ($? > 0){
		main::error_handler('self-updater',"Man update error: curl returns: $?.",1);
	}
}
sub validate {
	if (!-e $self_source){
		main::error_handler('self-updater',"Only updating $SELF_NAME at $self_source supported.",1);
	}
	if (!-e $man_source){
		main::error_handler('self-updater',"Only updating man at $man_source supported.",1);
	}
	if (!-x $COMMAND_CURL){
		main::error_handler('self-updater',"Downloadert $COMMAND_CURL missing or not executable.",1);
	}
	if (!-w $self_source){
		main::error_handler('self-updater',"$self_source is not writeable. Need superuser rights?",1);
	}
	if (!-w $man_source){
		main::error_handler('self-updater',"$man_source is not writeable. Need superuser rights?.",1);
	}
}
}

#### -------------------------------------------------------------------
#### VALIDATION - ERROR HANDLING
#### -------------------------------------------------------------------

## Args: 1: error id; 2: error message; 3: extt 0/1 [f/t]
sub error_handler {
	my ($error,$message,$b_exit) = @_;
	my ($br,$error_text) = ("\n",'');
	state $b_valid = 1;
	state $error_no = 0;
	if ($error eq 'unsupported-type'){$error_no = 2;$b_valid=0;}
	elsif ($error eq 'dest-dir'){$error_no = 1;$b_valid=0;}
	elsif ($error eq 'dest-eq-src-dir'){$error_no = 9;$b_valid=0;$br=''}
	elsif ($error eq 'missing-app'){$error_no = 3;$b_valid=0;}
	elsif ($error eq 'quality-invalid'){$error_no = 4;$b_valid=0;}
	elsif ($error eq 'bad-level'){$error_no = 5;$b_valid=0;}
	elsif ($error eq 'bad-fork'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'bad-nlink'){$error_no = 9;$b_valid=0;}
	elsif ($error eq 'self-updater'){$error_no = 17;}
	elsif ($error eq 'open'){$error_no = 14;}
	elsif ($error eq 'file-exists'){$error_no = 16;}
	elsif ($error eq 'file-missing'){$error_no = 15;}
	elsif ($error eq 'stat-infile'){$error_no = 6;}
	elsif ($error eq 'missing-arg'){$error_no = 7;
		$message = "Option: $message";$br=''}
	elsif ($error eq 'application-error'){$error_no = 11;}
	elsif ($error eq 'checksum-delete'){$error_no = 12;}
	elsif ($error eq 'invalid-options'){$error_no = 13;$br=''}
	elsif ($error eq 'unsupported-option'){$error_no = 8;$br=''}
	elsif ($error eq 'missing-perl-module'){$error_no = 10;
		$message = "Perl Module not found in system: $message";}
	if ($error eq 'validation-errors'){
		if (!$b_valid ){
			$message = "${br}Failed pretests. Please correct the listed errors.\n";
		}
		else {
			$message = "Pretests passed. Continuing.\n" if $LOG_LEVEL > 0;
			$b_exit = 0;
		}
	}
	else {
		$message = "${br}Error $error_no: $message\n";
	}
	print "$message" if $message;
	exit $error_no if $b_exit;
}

## package Validation 
{
package Validation;
my ($b_valid_in_out) = (0);
sub check_user_values {
	start_text();
	check_log_level();
	check_nlink();
	check_fork();
	check_src_dest_directories();
	check_in_out_types();
	if ($b_valid_in_out){
		check_quality() if $b_check_out;
		check_application_paths();
	}
	main::error_handler('validation-errors', '',1);
}
sub start_text {
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_heavy;
		print "Running $SELF_NAME pretests.\n";
	}
}
sub check_in_out_types {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_large;
		print main::dotify("Checking input and output types");
	}
	if ((!$run{'checksum'} && $INPUT_TYPE !~ m/^(flac|raw|shn|wav)$/i) ||
	 (($run{'checksum'} || $run{'autotag'}) && $INPUT_TYPE !~ m/^(flac)$/i)){
		$b_error = 1;
		$error_message .= "\n  The input type you entered is not supported: ";
		$error_message .= "$INPUT_TYPE";
	}
	if ( $b_check_out && $OUTPUT_TYPE !~ m/^(flac|mp3|ogg|opus)$/i ){
		$b_error = 1;
		$error_message .= "\n  The output type you entered is not supported: ";
		$error_message .= "$OUTPUT_TYPE";
	}
	if ( $b_check_out && $OUTPUT_TYPE eq lc('mp3') && $INPUT_TYPE ne lc('flac') ){
		$b_error = 1;
		$error_message .= "\n  The output type $OUTPUT_TYPE you entered ";
		$error_message .= "only supports input type: flac";
	}
	if ($b_check_out && $INPUT_TYPE =~ m/^(raw|shn)$/ && $OUTPUT_TYPE ne lc('flac')){
		$b_error = 1;
		$error_message .= "\n  The input type $INPUT_TYPE you entered ";
		$error_message .= "only supports output type: flac";
	}
	if ( $b_error ){
		main::error_handler('unsupported-type',$error_message,0);
	}
	else {
		$b_valid_in_out = 1;
		if ( $LOG_LEVEL > 0 ) {
			print "Valid: $INPUT_TYPE(in) $OUTPUT_TYPE(out)\n";
		}
	}
}
sub check_src_dest_directories {
	my $missing_dirs = '';
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		eval $print_line_large;
		print main::dotify("Checking source / destination directories");
	}
	if ( ! -d $SOURCE_DIRECTORY ){
		$b_error = 1;
		$missing_dirs .= "\n  Source Directory: $SOURCE_DIRECTORY";
	}
	if ( $b_check_dest && ! -d $DESTINATION_DIRECTORY ){
		$b_error = 1;
		$missing_dirs .= "\n  Destination Directory: $DESTINATION_DIRECTORY";
	}
	if ( $b_error ) {
		my $error_message = "The paths for the following directories are missing:";
		$error_message .= "$missing_dirs";
		$error_message .= "\nPlease check the directory paths you provided.";
		main::error_handler('dest-dir',$error_message,0);
	} 
	elsif ( $LOG_LEVEL > 0 ) {
		print "Directories: exist\n";
	}
	if ($b_check_dest && !$b_error && $DESTINATION_DIRECTORY eq $SOURCE_DIRECTORY){
		$error_message = "Destination directory cannot be same as Source directory!";
		main::error_handler('dest-eq-src-dir',$error_message,0);
	}
}
sub check_application_paths {
	my ($b_error,$error_message) = (0,'');
	my $app_paths = ''; 
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking required tools paths");
	}
	if ($b_check_out && $OUTPUT_TYPE eq 'flac') {
		$app_paths .= "$COMMAND_FLAC_OUT";
		if ( ! -x "$COMMAND_FLAC_OUT" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_FLAC_OUT";
		}
	}
	elsif ($b_check_out && $OUTPUT_TYPE eq 'ogg' ) {
		$app_paths .= "\n $COMMAND_OGG";
		if ( ! -x "$COMMAND_OGG" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_OGG";
		}
	}
	elsif ($b_check_out && $OUTPUT_TYPE eq 'opus' ) {
		$app_paths .= "\n $COMMAND_OPUS";
		if ( ! -x "$COMMAND_OPUS" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_OPUS";
		}
	}
	elsif ($b_check_out && $OUTPUT_TYPE eq 'mp3' ) {
		$app_paths .= "\n $COMMAND_LAME ";
		if ( ! -x "$COMMAND_LAME" ) {
			$b_error = 1;
			$error_message .= "\n  Encoding application not available: $COMMAND_LAME";
		}
		$app_paths .= "$COMMAND_FLAC ";
		if ( ! -x "$COMMAND_FLAC" ) {
			$b_error = 1;
			$error_message .= "\n  Input processor $COMMAND_FLAC needed by lame ";
			$error_message .= "not available.";
		}
		$app_paths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_METAFLAC not found. Required to copy ";
			$error_message .= "ID3 tags from Flac to MP3.";
		}
	}
	elsif ($run{'checksum'}){
		$app_paths .= "$COMMAND_MD5 ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_MD5" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_MD5 not found. Required to generate ";
			$error_message .= "md5 checksum files.";
		}
		$app_paths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_METAFLAC not found. Required to generate ";
			$error_message .= "ffp checksum files.";
		}
	}
	elsif ($run{'autotag'}){
		$app_paths .= "$COMMAND_METAFLAC ";
		# Added: Odd @2011-03-23 01:55:28
		if ( ! -x "$COMMAND_METAFLAC" ) {
			$b_error = 1;
			$error_message .= "\n  $COMMAND_METAFLAC not found. Required to auto-tag ";
			$error_message .= "collection files.";
		}
	}
	if ( $b_error ) {
		main::error_handler('missing-app',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Available: $app_paths\n";
	}
}
sub check_quality{
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking quality support for $OUTPUT_TYPE");
	}
	## NOTE: this is not used
	if ( lc($OUTPUT_TYPE) eq 'flac') {
		if ($QUALITY_FLAC !~ m/^[0-8]$/ ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "0 to 8 quality levels. You entered: $QUALITY_FLAC";
		}
		else {
			$quality = $QUALITY_FLAC;
		}
	}
	if ( lc($OUTPUT_TYPE) eq 'ogg') {
		if ($QUALITY_OGG !~ m/^-?[0-9]+(\.[0-9]+)?$/ || 
		 $QUALITY_OGG < -1 || $QUALITY_OGG > 10 ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "-1 to 10 quality levels. You entered: $QUALITY_OGG";
		}
		else {
			$quality = $QUALITY_OGG;
		}
	}
	# supports fractional quality levels
	elsif ( lc($OUTPUT_TYPE) eq 'opus') {
		if ($QUALITY_OPUS !~ m/^[0-9]+$/ || $QUALITY_OPUS < 6|| $QUALITY_OPUS > 256 ){
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports ";
			$error_message .= "6 to 256 bitrate quality levels. You entered: $QUALITY_OPUS";
		}
		else {
			$quality = $QUALITY_OPUS;
		}
	}
	elsif ( lc($OUTPUT_TYPE) eq 'mp3') {
		if ( $QUALITY_MP3 !~ m/^[0-9]$/ ) {
			$b_error = 1;
			$error_message .= "\n  $OUTPUT_TYPE only supports 0-9 quality levels. ";
			$error_message .= "You entered: $QUALITY_MP3";
		}
		else {
			$quality = $QUALITY_MP3;
		}
	}
	if ( $b_error ) {
		main::error_handler('quality-invalid',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $quality ($OUTPUT_TYPE)\n";
	}
}
sub check_log_level {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking log/screen output level");
	}
	if ( $LOG_LEVEL !~ m/^([0-4])$/ ) {
		$b_error = 1;
		$error_message .= "\n  LOG_LEVEL only supports 0-4. ";
		$error_message .= "You used: $LOG_LEVEL";
	}
	if ( $b_error ) {
		main::error_handler('bad-level',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $LOG_LEVEL\n";
	}
}
sub check_nlink {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking DONT_USE_NLINK value");
	}
	if ( $DONT_USE_NLINK !~ m/^[01]$/ ) {
		$b_error = 1;
		$error_message .= "\n  DONT_USE_NLINK only supports 0-1. ";
		$error_message .= "You used: $DONT_USE_NLINK";
	}
	if ( $b_error ) {
		main::error_handler('bad-nlink',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $DONT_USE_NLINK\n";
	}
}
sub check_fork {
	my ($b_error,$error_message) = (0,'');
	if ( $LOG_LEVEL > 0 ) {
		print main::dotify("Checking FORK value");
	}
	if ( $FORK !~ m/^[0-9]+$/) {
		$b_error = 1;
		$error_message .= "\n  FORK requires value: 0 or more. ";
		$error_message .= "You used: $FORK";
	}
	if ( $b_error ) {
		main::error_handler('bad-fork',$error_message,0);
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "Supported: $FORK\n";
	}
}
# end Validation
}

#### -------------------------------------------------------------------
#### PRINT HELP/VERSION/MESSAGES
#### -------------------------------------------------------------------
sub print_completion_message {
	eval $print_line_heavy;
	if ( $b_dest_changed ) {
		if ( $LOG_LEVEL > 1 ) {
			print "All done updating. Enjoy your music!\n";
		}
		elsif ( $LOG_LEVEL > 0 ) {
			print "\nUpdating completed. Enjoy your music!\n";
		}
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print "\nThere was nothing to update today in your collection.\n";
	}
	exit 0;
}

sub print_not_found {
	my ($message,$none);
	if ( $_[0] eq 'files'){
		$message = "No files to update of type: $extension\n";
		$none = "None to update";
	}
	elsif ( $_[0] eq 'extension'){
		$message = "No files found of type: $extension\n";
		$none = "None found";
	}
	elsif ($_[0] eq 'dirs') {
		$message = "No new directories required. Continuing...\n";
		$none = "None required";
	}
	elsif ($_[0] eq 'directory-cleaned') {
		$message = "No directories to remove. Continuing...\n";
		$none = "None to remove\n";
	}
	elsif ($_[0] eq 'file-cleaned') {
		$message = "No files to remove. Continuing...\n";
		$none = "None to remove\n";
	}
	if ( $LOG_LEVEL > 1 ) {
		print $message;
	}
	elsif ( $LOG_LEVEL > 0 ) {
		print $none;
	}
}

sub print_help {
	# so it shows the user config data if present
	UserConfigs::set(); 
	# but this should override the config data so follows
	set_basic_data();
	my $output = "$SELF_NAME v: $SELF_VERSION :: Supported Options:\n";
	$output .= "Examples: $SELF_NAME -q 8 --destination /music/main/ogg\n";
	$output .= "$SELF_NAME --input flac --output ogg -a md5\n";
	$output .= "$SELF_NAME --copy doc,docx,bmp\n";
	$output .= $line_small;
	$output .= "Syncing options:\n";
	$output .= "--append, -a      Add extenssion type(s) to existing extension copy list.\n";
	$output .= "                  1 or more, comma separated, no spaces.\n";
	$output .= "--clean           Clean directories and files from destination not found in\n";
	$output .= "                  source music directory. Will show you directories/files to\n";
	$output .= "                  be deleted then ask you to confirm (twice) that you want to\n";
	$output .= "                  remove that set of files or directories.\n";
	$output .= "--copy, -c        List of alternate data types to copy to Output type\n";
	$output .= "                  directories. Comma separated, no spaces. See sample above.\n";
	$output .= "                  Current copy types: ";
	$output .= (length(join(' ',@extension_list))>40) ? "\n                  " : '';
	$output .= "@extension_list\n";
	$output .= "--destination, -d Path to the directory where you want the processed\n";
	$output .= "                  (eg, ogg) files to go.\n";
	$output .= "                  Current value: $DESTINATION_DIRECTORY\n";
	$output .= "--force, -f       Force overwrite the mp3/ogg/opus/jpg/txt/etc. files, even\n"; 
	$output .= "                  if they already exist.\n";
	$output .= "--fork, -F        [0-x] - Number of forks/threads to use. 0 default, disables.\n";
	$output .= "                  Requires Perl module: Parallel::ForkManager. Current: $FORK\n";
	$output .= "--input, -i       Input type: flac, wav, raw, shn. shn requires codec shorten. \n";
	$output .= "                  raw, shn only output to flac.\n";
	$output .= "                  Current value: $INPUT_TYPE\n";
	$output .= "--output, -o      Output type: mp3, ogg, opus. mp3 requires input type flac.\n";
	$output .= "                  Current value: $OUTPUT_TYPE\n";
	$output .= "--quality n, -q n ogg: n between -1 and 10. Fractions ok. 10 best quality.\n";
	$output .= "                  opus: n between 6-256. Variable bit rate. 256 best quality.\n";
	$output .= "                  mp3: n between 0-9. Variable bit rate, 0 best quality.\n";
	$output .= "                  Current values: $QUALITY_MP3 (mp3); $QUALITY_OGG (ogg); $QUALITY_OPUS (opus)\n";
	$output .= "--source, -s      Path to the top-most directory containing your source files.\n";
	$output .= "                  Current value: $SOURCE_DIRECTORY\n";
	$output .= "--test            Test copy and sync without actually doing the copy/sync. Also\n";
	$output .= "                  activates --full for more complete path outputs.\n";
	$output .= $line_small;
	$output .= "Specialized options:\n";
	$output .= "--autotag         Requires auto.tag formatted file in each directory. Flac only.\n";
	$output .= "                  Deletes all existing tags, then creates a fully tagged set of\n";
	$output .= "                  files.\n";
	$output .= "--autotag-create  Create $TAG_FILE template in source directory. Will be\n";
	$output .= "                  populated with file names for recording filled in already in\n";
	$output .= "                  track listing. Preserves existing REPLAYGAIN values.\n";
	$output .= "--autotag-create-single\n";
	$output .= "                  For single disc recordings, will also add TRACKTOTAL and\n";
	$output .= "                  TRACKNUMBER counts when creating and populating the\n";
	$output .= "                  $TAG_FILE file.\n";
	$output .= "--checksum        Create .ffp and .md5 checksum files in your source directory.\n";
	$output .= "                  Checksum files are only created inside directories where flac\n";
	$output .= "                  files are found. Use --checksum-delete if you also want\n";
	$output .= "                  to delete existing checksum files. Only flac type\n";
	$output .= "                  is supported.\n";
	$output .= "                  Do not use together with other cleaning/syncing options!\n";
	$output .= "--checksum-delete Delete all existing .ffp, .md5, .ffp.txt, and md5.txt files\n";
	$output .= "                  before creating the new checksum files. Files only deleted in\n";
	$output .= "                  directories where flac files are found.\n";
	$output .= "--nlink           Set \$File::Find::dont_use_nlink = 0. Expert use only.\n";
	$output .= "--no-nlink        Set \$File::Find::dont_use_nlink = 1 [default].\n";
	$output .= "                  Expert use only.\n";
	$output .= "--no-replaygain   Does not preserve REPLAYGAIN values for autotag-create.\n";
	$output .= "-U                Update $SELF_NAME and man page. Set paths if not Linux.\n";
	$output .= "                  $SELF_NAME must be in $SELF_DIRECTORY.\n";
	$output .= $line_small;
	$output .= "Display output and debugging options:\n";
	$output .= "--basic           Basic single line per operation screen output, default value.\n";
	$output .= "                  Same as --log 1\n";
	$output .= "--full            Full screen output, including full verbosity of \n";
	$output .= "                  flac/lame/oggenc/opusenc conversion process for mp3, ogg,\n";
	$output .= "                  or opus output. Same as --log 3\n";
	$output .= "--debug           Trigger advanced output debugging data. Same as --log 4\n";
	$output .= "--help, -h        This help menu.\n";
	$output .= "--log             [0-4] Dynamically set LOG_LEVEL. Current value: $LOG_LEVEL\n";
	$output .= "--quiet           Turns off all screen output, except for error messages.\n";
	$output .= "                  Same as --log 0\n";
	$output .= "--verbose         Without full verbosity of full, no flac/lame/oggenc/opusenc\n";
	$output .= "                  for conversion process screen output. More verbose than\n";
	$output .= "                  --basic. Same as --log 2\n";
	$output .= "--version, -v     Show $SELF_NAME version.\n";
	$output .= $line_small;
	$output .= "User Configs ";
	if (!$CONFIG_DIRECTORY){
		$output .= "(checked in this order):\n/etc/$SELF_NAME.conf\n";
		$output .= "\$XDG_CONFIG_HOME/$SELF_NAME.conf\n";
		$output .= "\$HOME/.config/$SELF_NAME.conf\n";
		$output .= "\$HOME/.$SELF_NAME.conf\n";
	}
	else {
		$output .= "(manually set):\n$CONFIG_DIRECTORY/$SELF_NAME.conf\n";
	}
	$output .= "Requires this syntax (any user modifiable variable can be used)\n";
	$output .= "SOURCE_DIRECTORY=/home/me/music/flac\n";
	$output .= "DESTINATION_DIRECTORY=/home/me/music/ogg\n";
	$output .= "Do not use \$, \", or \' in config options or values (except in path names).\n";
	$output .= "\n";
	print $output;
	exit 0;
}

sub print_version {
	print "$SELF_NAME version: $SELF_VERSION ($SELF_DATE)\n";
	exit 0;
}

#### -------------------------------------------------------------------
#### SET RUNTIME VALUES
#### -------------------------------------------------------------------
sub set_basic_data {
	# if --copy/-c is set, then use that data instead of default copy types
	if ( defined $COPY_TYPES ){
		@extension_list = split( /,\s*/, $COPY_TYPES );
	}
	$DESTINATION_DIRECTORY =~ s|/$||;
	$SOURCE_DIRECTORY =~ s|/$||;
	$CONFIG_DIRECTORY =~ s|/$|| if $CONFIG_DIRECTORY;
	$INPUT_TYPE = lc($INPUT_TYPE) if $INPUT_TYPE;
	$OUTPUT_TYPE = lc($OUTPUT_TYPE) if $OUTPUT_TYPE;
	@extension_list = (@extension_list,$INPUT_TYPE);
	$File::Find::dont_use_nlink = $DONT_USE_NLINK;
	# note: tests show fork == 1 slower than no forking!!
	if ( $FORK > 0 ){
		if (!check_module('Parallel::ForkManager')){
			error_handler('missing-perl-module', 'Parallel::ForkManager',1);
		}
		else {
			import Parallel::ForkManager;
			$b_fork = 1;
		}
	}
}

sub set_display_data {
	if ( $LOG_LEVEL < 3 ) {
		if ( $OUTPUT_TYPE eq 'mp3' ) {
			$silent_flac = '--silent'; # flac output 
			$silent_lame = '--silent'; # lame output
		}
		elsif ( $OUTPUT_TYPE eq 'ogg' ) {
			$silent_flac = '--quiet'; # for oggenc output
		}
		elsif ( $OUTPUT_TYPE eq 'flac' ) {
			# -nostats -loglevel 0
			# -v quiet
			$silent_flac_out = '-nostats -loglevel error'; # 
		}
		elsif ( $OUTPUT_TYPE eq 'opus' ) {
			$silent_opus = '--quiet'; # for oggenc output
		}
	}
	if ( $LOG_LEVEL < 2 ) {
		$print_line_heavy = '';
		$print_line_large = '';
		$print_line_small = '';
	}
	else {
		$print_line_heavy = 'print $line_heavy';
		$print_line_large = 'print $line_large';
		$print_line_small = 'print $line_small';
	}
}
# get defaults from user config files if present
## Package UserConfigs
{
package UserConfigs;

sub set {
	my (@config_files,$file,$user_config);
	# set list of supported config files
	@config_files = ("/etc/$SELF_NAME.conf");
	if ($ENV{'XDG_CONFIG_HOME'} && -r "$ENV{XDG_CONFIG_HOME}/$SELF_NAME.conf"){
		$user_config = "$ENV{'XDG_CONFIG_HOME'}/$SELF_NAME.conf";
	}
	elsif ( -r "$ENV{HOME}/.config/$SELF_NAME.conf"){
		$user_config = "$ENV{HOME}/.config/$SELF_NAME.conf";
	}
	elsif (-r "$ENV{HOME}/.$SELF_NAME.conf"){
		$user_config = "$ENV{HOME}/.$SELF_NAME.conf";
	}
	elsif (-r "$CONFIG_DIRECTORY/$SELF_NAME.conf"){
		$user_config = "$CONFIG_DIRECTORY/$SELF_NAME.conf";
	}
	@config_files = (@config_files,$user_config) if $user_config;
	foreach $file (@config_files) {
		next unless -r $file && open (my $fh,'<',$file);
		while (<$fh>) {
			chomp;                  # no newline
			s/#.*//;                # no comments
			s/^\s+//;               # no leading white
			s/\s+$//;               # no trailing white
			s/('|"|\$|\s)//g;       # get rid of all non valid characters
			next unless length;     # anything left?
			my ($var, $value) = split(/\s*=\s*/, $_, 2);
			if (defined $var && defined $value){
				assign_value($var, $value);
			}
		}
	}
}
sub assign_value {
	my ($var,$value) = @_;
	if ($var eq 'COMMAND_FLAC'){$COMMAND_FLAC = $value;}
	elsif ($var eq 'COMMAND_FLAC_OUT'){$COMMAND_FLAC_OUT = $value;}
	elsif ($var eq 'COMMAND_LAME'){$COMMAND_LAME = $value;}
	elsif ($var eq 'COMMAND_METAFAC'){$COMMAND_METAFLAC = $value;}
	elsif ($var eq 'COMMAND_OGG'){$COMMAND_OGG = $value;}
	elsif ($var eq 'COMMAND_OPUS'){$COMMAND_OPUS = $value;}
	elsif ($var eq 'CLEAN'){
		$value =~ s/^(yes|1|true|enable|on)$/1/;
		$value =~ s/^(no|0|false|disable|off)$/0/;
		$run{'clean'} = $value if $value =~ /^[10]$/;}
	elsif ($var eq 'SOURCE_DIRECTORY' || $var eq 'DIR_PREFIX_SOURCE'){
		$SOURCE_DIRECTORY = $value;}
	elsif ($var eq 'DESTINATION_DIRECTORY' || $var eq 'DIR_PREFIX_DEST'){
		$DESTINATION_DIRECTORY = $value;}
	elsif ($var eq 'INPUT_TYPE'){$INPUT_TYPE = $value;}
	elsif ($var eq 'LOG_LEVEL'){$LOG_LEVEL = $value;}
	elsif ($var eq 'OUTPUT_TYPE'){$OUTPUT_TYPE = $value;}
	# legacy configs, sets both
	elsif ($var eq 'QUALITY'){$QUALITY_OGG = $value;$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_FLAC'){$QUALITY_FLAC = $value}
	elsif ($var eq 'QUALITY_MP3'){$QUALITY_MP3 = $value}
	elsif ($var eq 'QUALITY_OGG'){$QUALITY_OGG = $value;}
	elsif ($var eq 'QUALITY_OPUS'){$QUALITY_OPUS = $value;}
	elsif ($var eq 'COPY_TYPES' || $var eq 'USER_TYPES'){
		$COPY_TYPES = $value;}
	elsif ($var eq 'DONT_USE_NLINK'){$DONT_USE_NLINK = $value}
	elsif ($var eq 'FORK'){$FORK = $value}
	elsif ($var eq 'FFP_FILE'){$FFP_FILE = $value}
	elsif ($var eq 'MD5_FILE'){$MD5_FILE = $value}
	elsif ($var eq 'TAG_FILE'){$TAG_FILE = $value}
}
# end ConfigData
}

# Get Options and set values, this overrides defaults 
# from top globals and config files
sub get_options{
	my (@args) = @_;
	GetOptions (
	"a|append:s" => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES .= ',' . $arg if $arg;},
	"autotag" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag'} = 1;
		$run{'autotag-create'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"autotag-create" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag-create'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"autotag-create-single" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'autotag-create'} = 1;
		$run{'autotag-number'} = 1;
		$run{'autotag'} = 0;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'checksum'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"basic|default" => sub { 
		$LOG_LEVEL = 1 },
	"checksum" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 1;
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"checksum-delete" => sub { 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 1;
		$run{'checksum-delete'} = 1; 
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';
		},
	"clean" => sub { 
		$run{'clean'} = 1 },
	# accepts null value so users can not copy anything
	"c|copy:s" => sub { 
		my ($opt,$arg) = @_;
		$COPY_TYPES = $arg;},
	"debug" => sub { 
		$LOG_LEVEL = 4},
	"d|destination:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$DESTINATION_DIRECTORY = $arg },
	"f|force" => sub { 
		$b_force = 1 },
	"F|fork:i" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires fork count integer.",1) if not defined $arg;
		$FORK = $arg; },
	"full" => sub { 
		$LOG_LEVEL = 3 },
	"h|help|?" => sub { 
		print_help();},
	"i|input:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$INPUT_TYPE = $arg },
	"log:i" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt log level integer.",1) if not defined $arg;
		$LOG_LEVEL = $arg; },
	"o|output:s" => sub {
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires type.",1) if ! $arg;
		$OUTPUT_TYPE = $arg;},
	"nlink" => sub { 
		$DONT_USE_NLINK = 0 },
	"no-nlink" => sub { 
		$DONT_USE_NLINK = 1 },
	"no-replaygain" => sub { 
		$run{'no-replaygain'} = 1 },
	"q|quality:f" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires number.",1) if ! defined $arg || $arg !~ /^-?[0-9\.]+$/;
		# validate these later
		$QUALITY_FLAC = $arg;
		$QUALITY_MP3 = $arg;
		$QUALITY_OGG = $arg;
		$QUALITY_OPUS = $arg;}, 
	"s|source:s" => sub { 
		my ($opt,$arg) = @_;
		error_handler('missing-arg',"$opt requires path.",1) if ! $arg;
		$SOURCE_DIRECTORY = $arg;},
	"quiet|silent" => sub { 
		$b_quiet = 1; 
		$LOG_LEVEL = 0 },
	"test" => sub { 
		$LOG_LEVEL = 3;
		$b_test = 1 },
	'U'=> sub { 
		$run{'update'} = 1; 
		$b_check_dest = 0;
		$b_check_out = 0;
		$run{'checksum'} = 0;
		$run{'checksum-delete'} = 0; 
		$run{'sync'} = 0;
		$run{'clean'} = 0;
		$run{'autotag'} = 0;
		$OUTPUT_TYPE = 'UNSET';},
	"V|verbose" => sub { 
		$LOG_LEVEL = 2 },
	"v|version" => sub { 
		print_version(); },
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unsupported-option', "Unsupported option: $opt",1); }
	);
	if ($run{'checksum'} && ($run{'sync'} || $run{'clean'} || 
	 $run{'autotag'} || $run{'autotag-create'})){
		error_handler('invalid-options', 
		 "You cannot use --checksum with any clean, sync, or autotag options.",1);
	}
	if ($run{'autotag'} && ($run{'sync'} || $run{'clean'} || 
	 $run{'checksum'} || $run{'autotag-create'})){
		error_handler('invalid-options', 
		 "You cannot use --autotag with autotag-generate, clean, sync, or checksum options.",1);
	}
	if ($run{'autotag-create'} && ($run{'sync'} || $run{'clean'} || 
	 $run{'checksum'} || $run{'autotag'})){
		error_handler('invalid-options', 
		 "You cannot use --autotag-generate with autotag, clean, sync, or checksum options.",1);
	}
}

#########################################################################
### EXECUTE / PROCESS MUSIC ###
#########################################################################

main();

###**EOF**###
